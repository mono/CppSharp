//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        public unsafe partial class ExprIterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr I;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratorC2EPPNS_4StmtE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratormiEm")]
                internal static extern clang.ExprIterator.Internal OperatorMinus_0(global::System.IntPtr instance, ulong i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ExprIteratorplEm")]
                internal static extern clang.ExprIterator.Internal OperatorPlus_0(global::System.IntPtr instance, ulong i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ExprIteratormiERKS0_")]
                internal static extern int OperatorMinus_1(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ExprIteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ExprIteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ExprIteratorgtERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreater_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ExprIteratorgeERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual_0(global::System.IntPtr instance, global::System.IntPtr R);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprIterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprIterator>();

            private readonly bool __ownsNativeInstance;

            public static ExprIterator __CreateInstance(global::System.IntPtr native)
            {
                return new ExprIterator((ExprIterator.Internal*) native);
            }

            public static ExprIterator __CreateInstance(ExprIterator.Internal native)
            {
                return new ExprIterator(native);
            }

            private static ExprIterator.Internal* __CopyValue(ExprIterator.Internal native)
            {
                var ret = (ExprIterator.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private ExprIterator(ExprIterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExprIterator(ExprIterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ExprIterator(clang.Stmt i)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(i, null) ? global::System.IntPtr.Zero : i.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            public ExprIterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExprIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static clang.ExprIterator operator ++(clang.ExprIterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                clang.ExprIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ExprIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ExprIterator) clang.ExprIterator.NativeToManagedMap[__ret];
                else __result0 = clang.ExprIterator.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.ExprIterator operator -(clang.ExprIterator __op, ulong i)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = i;
                var __ret = Internal.OperatorMinus_0(arg0, arg1);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public static clang.ExprIterator operator +(clang.ExprIterator __op, ulong i)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = i;
                var __ret = Internal.OperatorPlus_0(arg0, arg1);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public static int operator -(clang.ExprIterator __op, clang.ExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorMinus_1(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(clang.ExprIterator __op, clang.ExprIterator R)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RNull = ReferenceEquals(R, null);
                if (__opNull || RNull)
                    return __opNull && RNull;
                var arg0 = __op.__Instance;
                var arg1 = R.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as ExprIterator;
            }

            public static bool operator !=(clang.ExprIterator __op, clang.ExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <(clang.ExprIterator __op, clang.ExprIterator R)
            {
                return !(__op > R);
            }

            public static bool operator >(clang.ExprIterator __op, clang.ExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorGreater_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <=(clang.ExprIterator __op, clang.ExprIterator R)
            {
                return !(__op >= R);
            }

            public static bool operator >=(clang.ExprIterator __op, clang.ExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                return __ret;
            }
        }

        public unsafe partial class ConstExprIterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr I;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstExprIteratorC2EPKPKNS_4StmtE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstExprIteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstExprIteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstExprIteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratorplEm")]
                internal static extern clang.ConstExprIterator.Internal OperatorPlus_0(global::System.IntPtr instance, ulong i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratormiEm")]
                internal static extern clang.ConstExprIterator.Internal OperatorMinus_0(global::System.IntPtr instance, ulong i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratormiERKS0_")]
                internal static extern int OperatorMinus_1(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratorgtERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreater_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstExprIteratorgeERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual_0(global::System.IntPtr instance, global::System.IntPtr R);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstExprIterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstExprIterator>();

            private readonly bool __ownsNativeInstance;

            public static ConstExprIterator __CreateInstance(global::System.IntPtr native)
            {
                return new ConstExprIterator((ConstExprIterator.Internal*) native);
            }

            public static ConstExprIterator __CreateInstance(ConstExprIterator.Internal native)
            {
                return new ConstExprIterator(native);
            }

            private static ConstExprIterator.Internal* __CopyValue(ConstExprIterator.Internal native)
            {
                var ret = (ConstExprIterator.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private ConstExprIterator(ConstExprIterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstExprIterator(ConstExprIterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ConstExprIterator(clang.Stmt i)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(i, null) ? global::System.IntPtr.Zero : i.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            public ConstExprIterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ConstExprIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static clang.ConstExprIterator operator ++(clang.ConstExprIterator __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                clang.ConstExprIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ConstExprIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ConstExprIterator) clang.ConstExprIterator.NativeToManagedMap[__ret];
                else __result0 = clang.ConstExprIterator.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.ConstExprIterator operator +(clang.ConstExprIterator __op, ulong i)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = i;
                var __ret = Internal.OperatorPlus_0(arg0, arg1);
                return clang.ConstExprIterator.__CreateInstance(__ret);
            }

            public static clang.ConstExprIterator operator -(clang.ConstExprIterator __op, ulong i)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = i;
                var __ret = Internal.OperatorMinus_0(arg0, arg1);
                return clang.ConstExprIterator.__CreateInstance(__ret);
            }

            public static int operator -(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorMinus_1(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RNull = ReferenceEquals(R, null);
                if (__opNull || RNull)
                    return __opNull && RNull;
                var arg0 = __op.__Instance;
                var arg1 = R.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as ConstExprIterator;
            }

            public static bool operator !=(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                return !(__op > R);
            }

            public static bool operator >(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorGreater_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <=(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                return !(__op >= R);
            }

            public static bool operator >=(clang.ConstExprIterator __op, clang.ConstExprIterator R)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Stmt - This represents one statement.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Stmt - This represents one statement.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class Stmt : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4StmtC2ENS0_9StmtClassENS0_10EmptyShellE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4StmtC2ENS0_9StmtClassE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4StmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt12getStmtClassEv")]
                internal static extern clang.Stmt.StmtClass getStmtClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt16getStmtClassNameEv")]
                internal static extern global::System.IntPtr getStmtClassName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt12addStmtClassENS0_9StmtClassE")]
                internal static extern void addStmtClass_0(clang.Stmt.StmtClass s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt16EnableStatisticsEv")]
                internal static extern void EnableStatistics_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt10PrintStatsEv")]
                internal static extern void PrintStats_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt4dumpERNS_13SourceManagerE")]
                internal static extern void dump_1(global::System.IntPtr instance, global::System.IntPtr SM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt4dumpERN4llvm11raw_ostreamERNS_13SourceManagerE")]
                internal static extern void dump_2(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr SM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt9dumpColorEv")]
                internal static extern void dumpColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt10dumpPrettyERKNS_10ASTContextE")]
                internal static extern void dumpPretty_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt11printPrettyERN4llvm11raw_ostreamEPNS_13PrinterHelperERKNS_14PrintingPolicyEj")]
                internal static extern void printPretty_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Helper, global::System.IntPtr Policy, uint Indentation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt7viewASTEv")]
                internal static extern void viewAST_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt14IgnoreImplicitEv")]
                internal static extern global::System.IntPtr IgnoreImplicit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt16IgnoreContainersEb")]
                internal static extern global::System.IntPtr IgnoreContainers_0(global::System.IntPtr instance, bool IgnoreCaptured);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt24stripLabelLikeStatementsEv")]
                internal static extern global::System.IntPtr stripLabelLikeStatements_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt11child_beginEv")]
                internal static extern void child_begin_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Stmt9child_endEv")]
                internal static extern void child_end_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Stmt7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextEb")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Context, bool Canonical);
            }

            public enum StmtClass : uint
            {
                NoStmtClass = 0,
                GCCAsmStmtClass = 1,
                MSAsmStmtClass = 2,
                firstAsmStmtConstant = 1,
                lastAsmStmtConstant = 2,
                AttributedStmtClass = 3,
                BreakStmtClass = 4,
                CXXCatchStmtClass = 5,
                CXXForRangeStmtClass = 6,
                CXXTryStmtClass = 7,
                CapturedStmtClass = 8,
                CompoundStmtClass = 9,
                ContinueStmtClass = 10,
                DeclStmtClass = 11,
                DoStmtClass = 12,
                BinaryConditionalOperatorClass = 13,
                ConditionalOperatorClass = 14,
                firstAbstractConditionalOperatorConstant = 13,
                lastAbstractConditionalOperatorConstant = 14,
                AddrLabelExprClass = 15,
                ArraySubscriptExprClass = 16,
                ArrayTypeTraitExprClass = 17,
                AsTypeExprClass = 18,
                AtomicExprClass = 19,
                BinaryOperatorClass = 20,
                CompoundAssignOperatorClass = 21,
                firstBinaryOperatorConstant = 20,
                lastBinaryOperatorConstant = 21,
                BlockExprClass = 22,
                CXXBindTemporaryExprClass = 23,
                CXXBoolLiteralExprClass = 24,
                CXXConstructExprClass = 25,
                CXXTemporaryObjectExprClass = 26,
                firstCXXConstructExprConstant = 25,
                lastCXXConstructExprConstant = 26,
                CXXDefaultArgExprClass = 27,
                CXXDefaultInitExprClass = 28,
                CXXDeleteExprClass = 29,
                CXXDependentScopeMemberExprClass = 30,
                CXXFoldExprClass = 31,
                CXXNewExprClass = 32,
                CXXNoexceptExprClass = 33,
                CXXNullPtrLiteralExprClass = 34,
                CXXPseudoDestructorExprClass = 35,
                CXXScalarValueInitExprClass = 36,
                CXXStdInitializerListExprClass = 37,
                CXXThisExprClass = 38,
                CXXThrowExprClass = 39,
                CXXTypeidExprClass = 40,
                CXXUnresolvedConstructExprClass = 41,
                CXXUuidofExprClass = 42,
                CallExprClass = 43,
                CUDAKernelCallExprClass = 44,
                CXXMemberCallExprClass = 45,
                CXXOperatorCallExprClass = 46,
                UserDefinedLiteralClass = 47,
                firstCallExprConstant = 43,
                lastCallExprConstant = 47,
                CStyleCastExprClass = 48,
                CXXFunctionalCastExprClass = 49,
                CXXConstCastExprClass = 50,
                CXXDynamicCastExprClass = 51,
                CXXReinterpretCastExprClass = 52,
                CXXStaticCastExprClass = 53,
                firstCXXNamedCastExprConstant = 50,
                lastCXXNamedCastExprConstant = 53,
                ObjCBridgedCastExprClass = 54,
                firstExplicitCastExprConstant = 48,
                lastExplicitCastExprConstant = 54,
                ImplicitCastExprClass = 55,
                firstCastExprConstant = 48,
                lastCastExprConstant = 55,
                CharacterLiteralClass = 56,
                ChooseExprClass = 57,
                CompoundLiteralExprClass = 58,
                ConvertVectorExprClass = 59,
                DeclRefExprClass = 60,
                DependentScopeDeclRefExprClass = 61,
                DesignatedInitExprClass = 62,
                ExprWithCleanupsClass = 63,
                ExpressionTraitExprClass = 64,
                ExtVectorElementExprClass = 65,
                FloatingLiteralClass = 66,
                FunctionParmPackExprClass = 67,
                GNUNullExprClass = 68,
                GenericSelectionExprClass = 69,
                ImaginaryLiteralClass = 70,
                ImplicitValueInitExprClass = 71,
                InitListExprClass = 72,
                IntegerLiteralClass = 73,
                LambdaExprClass = 74,
                MSPropertyRefExprClass = 75,
                MaterializeTemporaryExprClass = 76,
                MemberExprClass = 77,
                ObjCArrayLiteralClass = 78,
                ObjCBoolLiteralExprClass = 79,
                ObjCBoxedExprClass = 80,
                ObjCDictionaryLiteralClass = 81,
                ObjCEncodeExprClass = 82,
                ObjCIndirectCopyRestoreExprClass = 83,
                ObjCIsaExprClass = 84,
                ObjCIvarRefExprClass = 85,
                ObjCMessageExprClass = 86,
                ObjCPropertyRefExprClass = 87,
                ObjCProtocolExprClass = 88,
                ObjCSelectorExprClass = 89,
                ObjCStringLiteralClass = 90,
                ObjCSubscriptRefExprClass = 91,
                OffsetOfExprClass = 92,
                OpaqueValueExprClass = 93,
                UnresolvedLookupExprClass = 94,
                UnresolvedMemberExprClass = 95,
                firstOverloadExprConstant = 94,
                lastOverloadExprConstant = 95,
                PackExpansionExprClass = 96,
                ParenExprClass = 97,
                ParenListExprClass = 98,
                PredefinedExprClass = 99,
                PseudoObjectExprClass = 100,
                ShuffleVectorExprClass = 101,
                SizeOfPackExprClass = 102,
                StmtExprClass = 103,
                StringLiteralClass = 104,
                SubstNonTypeTemplateParmExprClass = 105,
                SubstNonTypeTemplateParmPackExprClass = 106,
                TypeTraitExprClass = 107,
                TypoExprClass = 108,
                UnaryExprOrTypeTraitExprClass = 109,
                UnaryOperatorClass = 110,
                VAArgExprClass = 111,
                firstExprConstant = 13,
                lastExprConstant = 111,
                ForStmtClass = 112,
                GotoStmtClass = 113,
                IfStmtClass = 114,
                IndirectGotoStmtClass = 115,
                LabelStmtClass = 116,
                MSDependentExistsStmtClass = 117,
                NullStmtClass = 118,
                OMPAtomicDirectiveClass = 119,
                OMPBarrierDirectiveClass = 120,
                OMPCriticalDirectiveClass = 121,
                OMPFlushDirectiveClass = 122,
                OMPForDirectiveClass = 123,
                OMPForSimdDirectiveClass = 124,
                OMPParallelForDirectiveClass = 125,
                OMPParallelForSimdDirectiveClass = 126,
                OMPSimdDirectiveClass = 127,
                firstOMPLoopDirectiveConstant = 123,
                lastOMPLoopDirectiveConstant = 127,
                OMPMasterDirectiveClass = 128,
                OMPOrderedDirectiveClass = 129,
                OMPParallelDirectiveClass = 130,
                OMPParallelSectionsDirectiveClass = 131,
                OMPSectionDirectiveClass = 132,
                OMPSectionsDirectiveClass = 133,
                OMPSingleDirectiveClass = 134,
                OMPTargetDirectiveClass = 135,
                OMPTaskDirectiveClass = 136,
                OMPTaskwaitDirectiveClass = 137,
                OMPTaskyieldDirectiveClass = 138,
                OMPTeamsDirectiveClass = 139,
                firstOMPExecutableDirectiveConstant = 119,
                lastOMPExecutableDirectiveConstant = 139,
                ObjCAtCatchStmtClass = 140,
                ObjCAtFinallyStmtClass = 141,
                ObjCAtSynchronizedStmtClass = 142,
                ObjCAtThrowStmtClass = 143,
                ObjCAtTryStmtClass = 144,
                ObjCAutoreleasePoolStmtClass = 145,
                ObjCForCollectionStmtClass = 146,
                ReturnStmtClass = 147,
                SEHExceptStmtClass = 148,
                SEHFinallyStmtClass = 149,
                SEHLeaveStmtClass = 150,
                SEHTryStmtClass = 151,
                CaseStmtClass = 152,
                DefaultStmtClass = 153,
                firstSwitchCaseConstant = 152,
                lastSwitchCaseConstant = 153,
                SwitchStmtClass = 154,
                WhileStmtClass = 155,
                firstStmtConstant = 1,
                lastStmtConstant = 155
            }

            [Flags]
            public enum NumStmtBits : uint
            {
                NumStmtBits = 8
            }

            [Flags]
            public enum NumExprBits : uint
            {
                NumExprBits = 16
            }

            public enum APFloatSemantics : uint
            {
                IEEEhalf = 0,
                IEEEsingle = 1,
                IEEEdouble = 2,
                x87DoubleExtended = 3,
                IEEEquad = 4,
                PPCDoubleDouble = 5
            }

            /// <summary>
            /// <para>Child Iterators: All subclasses must implement 'children' to
            /// permit easy iteration over the substatements/subexpessions of an AST
            /// node. This permits easy iteration over all nodes in the AST.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Child Iterators: All subclasses must implement
            /// 'children'</para>
            /// <para>  /// to permit easy iteration over the
            /// substatements/subexpessions of an</para>
            /// <para>  /// AST node.  This permits easy iteration over all nodes
            /// in the AST.</para>
            /// </remarks>
            protected internal unsafe partial class StmtBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint sClass;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt13StmtBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtBitfields>();

                private readonly bool __ownsNativeInstance;

                public static StmtBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new StmtBitfields((StmtBitfields.Internal*) native);
                }

                public static StmtBitfields __CreateInstance(StmtBitfields.Internal native)
                {
                    return new StmtBitfields(native);
                }

                private static StmtBitfields.Internal* __CopyValue(StmtBitfields.Internal native)
                {
                    var ret = (StmtBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private StmtBitfields(StmtBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StmtBitfields(StmtBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public StmtBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.StmtBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class CompoundStmtBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(1)]
                    public uint NumStmts;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt21CompoundStmtBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CompoundStmtBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CompoundStmtBitfields>();

                private readonly bool __ownsNativeInstance;

                public static CompoundStmtBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new CompoundStmtBitfields((CompoundStmtBitfields.Internal*) native);
                }

                public static CompoundStmtBitfields __CreateInstance(CompoundStmtBitfields.Internal native)
                {
                    return new CompoundStmtBitfields(native);
                }

                private static CompoundStmtBitfields.Internal* __CopyValue(CompoundStmtBitfields.Internal native)
                {
                    var ret = (CompoundStmtBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private CompoundStmtBitfields(CompoundStmtBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CompoundStmtBitfields(CompoundStmtBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CompoundStmtBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.CompoundStmtBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class ExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(1)]
                    public uint ValueKind;

                    [FieldOffset(1)]
                    public uint ObjectKind;

                    [FieldOffset(1)]
                    public uint TypeDependent;

                    [FieldOffset(1)]
                    public uint ValueDependent;

                    [FieldOffset(1)]
                    public uint InstantiationDependent;

                    [FieldOffset(1)]
                    public uint ContainsUnexpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt13ExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ExprBitfields((ExprBitfields.Internal*) native);
                }

                public static ExprBitfields __CreateInstance(ExprBitfields.Internal native)
                {
                    return new ExprBitfields(native);
                }

                private static ExprBitfields.Internal* __CopyValue(ExprBitfields.Internal native)
                {
                    var ret = (ExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ExprBitfields(ExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExprBitfields(ExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.ExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class CharacterLiteralBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt25CharacterLiteralBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CharacterLiteralBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CharacterLiteralBitfields>();

                private readonly bool __ownsNativeInstance;

                public static CharacterLiteralBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new CharacterLiteralBitfields((CharacterLiteralBitfields.Internal*) native);
                }

                public static CharacterLiteralBitfields __CreateInstance(CharacterLiteralBitfields.Internal native)
                {
                    return new CharacterLiteralBitfields(native);
                }

                private static CharacterLiteralBitfields.Internal* __CopyValue(CharacterLiteralBitfields.Internal native)
                {
                    var ret = (CharacterLiteralBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private CharacterLiteralBitfields(CharacterLiteralBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CharacterLiteralBitfields(CharacterLiteralBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CharacterLiteralBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.CharacterLiteralBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class FloatingLiteralBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Semantics;

                    [FieldOffset(2)]
                    public uint IsExact;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt24FloatingLiteralBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FloatingLiteralBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FloatingLiteralBitfields>();

                private readonly bool __ownsNativeInstance;

                public static FloatingLiteralBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new FloatingLiteralBitfields((FloatingLiteralBitfields.Internal*) native);
                }

                public static FloatingLiteralBitfields __CreateInstance(FloatingLiteralBitfields.Internal native)
                {
                    return new FloatingLiteralBitfields(native);
                }

                private static FloatingLiteralBitfields.Internal* __CopyValue(FloatingLiteralBitfields.Internal native)
                {
                    var ret = (FloatingLiteralBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private FloatingLiteralBitfields(FloatingLiteralBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FloatingLiteralBitfields(FloatingLiteralBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public FloatingLiteralBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.FloatingLiteralBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class UnaryExprOrTypeTraitExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Kind;

                    [FieldOffset(2)]
                    public uint IsType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt33UnaryExprOrTypeTraitExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryExprOrTypeTraitExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryExprOrTypeTraitExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static UnaryExprOrTypeTraitExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new UnaryExprOrTypeTraitExprBitfields((UnaryExprOrTypeTraitExprBitfields.Internal*) native);
                }

                public static UnaryExprOrTypeTraitExprBitfields __CreateInstance(UnaryExprOrTypeTraitExprBitfields.Internal native)
                {
                    return new UnaryExprOrTypeTraitExprBitfields(native);
                }

                private static UnaryExprOrTypeTraitExprBitfields.Internal* __CopyValue(UnaryExprOrTypeTraitExprBitfields.Internal native)
                {
                    var ret = (UnaryExprOrTypeTraitExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private UnaryExprOrTypeTraitExprBitfields(UnaryExprOrTypeTraitExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnaryExprOrTypeTraitExprBitfields(UnaryExprOrTypeTraitExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public UnaryExprOrTypeTraitExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.UnaryExprOrTypeTraitExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class DeclRefExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint HasQualifier;

                    [FieldOffset(2)]
                    public uint HasTemplateKWAndArgsInfo;

                    [FieldOffset(2)]
                    public uint HasFoundDecl;

                    [FieldOffset(2)]
                    public uint HadMultipleCandidates;

                    [FieldOffset(2)]
                    public uint RefersToEnclosingVariableOrCapture;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt20DeclRefExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclRefExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclRefExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static DeclRefExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new DeclRefExprBitfields((DeclRefExprBitfields.Internal*) native);
                }

                public static DeclRefExprBitfields __CreateInstance(DeclRefExprBitfields.Internal native)
                {
                    return new DeclRefExprBitfields(native);
                }

                private static DeclRefExprBitfields.Internal* __CopyValue(DeclRefExprBitfields.Internal native)
                {
                    var ret = (DeclRefExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private DeclRefExprBitfields(DeclRefExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclRefExprBitfields(DeclRefExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclRefExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.DeclRefExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class CastExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Kind;

                    [FieldOffset(2)]
                    public uint BasePathSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt17CastExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CastExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CastExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static CastExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new CastExprBitfields((CastExprBitfields.Internal*) native);
                }

                public static CastExprBitfields __CreateInstance(CastExprBitfields.Internal native)
                {
                    return new CastExprBitfields(native);
                }

                private static CastExprBitfields.Internal* __CopyValue(CastExprBitfields.Internal native)
                {
                    var ret = (CastExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private CastExprBitfields(CastExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CastExprBitfields(CastExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CastExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.CastExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class CallExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint NumPreArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt17CallExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CallExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CallExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static CallExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new CallExprBitfields((CallExprBitfields.Internal*) native);
                }

                public static CallExprBitfields __CreateInstance(CallExprBitfields.Internal native)
                {
                    return new CallExprBitfields(native);
                }

                private static CallExprBitfields.Internal* __CopyValue(CallExprBitfields.Internal native)
                {
                    var ret = (CallExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private CallExprBitfields(CallExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CallExprBitfields(CallExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CallExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.CallExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class ExprWithCleanupsBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint NumObjects;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt25ExprWithCleanupsBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprWithCleanupsBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExprWithCleanupsBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ExprWithCleanupsBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ExprWithCleanupsBitfields((ExprWithCleanupsBitfields.Internal*) native);
                }

                public static ExprWithCleanupsBitfields __CreateInstance(ExprWithCleanupsBitfields.Internal native)
                {
                    return new ExprWithCleanupsBitfields(native);
                }

                private static ExprWithCleanupsBitfields.Internal* __CopyValue(ExprWithCleanupsBitfields.Internal native)
                {
                    var ret = (ExprWithCleanupsBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ExprWithCleanupsBitfields(ExprWithCleanupsBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExprWithCleanupsBitfields(ExprWithCleanupsBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExprWithCleanupsBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.ExprWithCleanupsBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class PseudoObjectExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint NumSubExprs;

                    [FieldOffset(3)]
                    public uint ResultIndex;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt25PseudoObjectExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PseudoObjectExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PseudoObjectExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static PseudoObjectExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new PseudoObjectExprBitfields((PseudoObjectExprBitfields.Internal*) native);
                }

                public static PseudoObjectExprBitfields __CreateInstance(PseudoObjectExprBitfields.Internal native)
                {
                    return new PseudoObjectExprBitfields(native);
                }

                private static PseudoObjectExprBitfields.Internal* __CopyValue(PseudoObjectExprBitfields.Internal native)
                {
                    var ret = (PseudoObjectExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private PseudoObjectExprBitfields(PseudoObjectExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PseudoObjectExprBitfields(PseudoObjectExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public PseudoObjectExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.PseudoObjectExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class ObjCIndirectCopyRestoreExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint ShouldCopy;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt36ObjCIndirectCopyRestoreExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCIndirectCopyRestoreExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCIndirectCopyRestoreExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ObjCIndirectCopyRestoreExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ObjCIndirectCopyRestoreExprBitfields((ObjCIndirectCopyRestoreExprBitfields.Internal*) native);
                }

                public static ObjCIndirectCopyRestoreExprBitfields __CreateInstance(ObjCIndirectCopyRestoreExprBitfields.Internal native)
                {
                    return new ObjCIndirectCopyRestoreExprBitfields(native);
                }

                private static ObjCIndirectCopyRestoreExprBitfields.Internal* __CopyValue(ObjCIndirectCopyRestoreExprBitfields.Internal native)
                {
                    var ret = (ObjCIndirectCopyRestoreExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ObjCIndirectCopyRestoreExprBitfields(ObjCIndirectCopyRestoreExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ObjCIndirectCopyRestoreExprBitfields(ObjCIndirectCopyRestoreExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ObjCIndirectCopyRestoreExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.ObjCIndirectCopyRestoreExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class InitListExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint HadArrayRangeDesignator;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt21InitListExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InitListExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InitListExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static InitListExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new InitListExprBitfields((InitListExprBitfields.Internal*) native);
                }

                public static InitListExprBitfields __CreateInstance(InitListExprBitfields.Internal native)
                {
                    return new InitListExprBitfields(native);
                }

                private static InitListExprBitfields.Internal* __CopyValue(InitListExprBitfields.Internal native)
                {
                    var ret = (InitListExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private InitListExprBitfields(InitListExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InitListExprBitfields(InitListExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public InitListExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.InitListExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class TypeTraitExprBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Kind;

                    [FieldOffset(3)]
                    public uint Value;

                    [FieldOffset(3)]
                    public uint NumArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt22TypeTraitExprBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeTraitExprBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeTraitExprBitfields>();

                private readonly bool __ownsNativeInstance;

                public static TypeTraitExprBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new TypeTraitExprBitfields((TypeTraitExprBitfields.Internal*) native);
                }

                public static TypeTraitExprBitfields __CreateInstance(TypeTraitExprBitfields.Internal native)
                {
                    return new TypeTraitExprBitfields(native);
                }

                private static TypeTraitExprBitfields.Internal* __CopyValue(TypeTraitExprBitfields.Internal native)
                {
                    var ret = (TypeTraitExprBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private TypeTraitExprBitfields(TypeTraitExprBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeTraitExprBitfields(TypeTraitExprBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeTraitExprBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.TypeTraitExprBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Aligner;

                    [FieldOffset(0)]
                    public clang.Stmt.StmtBitfields.Internal StmtBits;

                    [FieldOffset(0)]
                    public clang.Stmt.CompoundStmtBitfields.Internal CompoundStmtBits;

                    [FieldOffset(0)]
                    public clang.Stmt.ExprBitfields.Internal ExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.CharacterLiteralBitfields.Internal CharacterLiteralBits;

                    [FieldOffset(0)]
                    public clang.Stmt.FloatingLiteralBitfields.Internal FloatingLiteralBits;

                    [FieldOffset(0)]
                    public clang.Stmt.UnaryExprOrTypeTraitExprBitfields.Internal UnaryExprOrTypeTraitExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.DeclRefExprBitfields.Internal DeclRefExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.CastExprBitfields.Internal CastExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.CallExprBitfields.Internal CallExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.ExprWithCleanupsBitfields.Internal ExprWithCleanupsBits;

                    [FieldOffset(0)]
                    public clang.Stmt.PseudoObjectExprBitfields.Internal PseudoObjectExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.ObjCIndirectCopyRestoreExprBitfields.Internal ObjCIndirectCopyRestoreExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.InitListExprBitfields.Internal InitListExprBits;

                    [FieldOffset(0)]
                    public clang.Stmt.TypeTraitExprBitfields.Internal TypeTraitExprBits;
                }
            }

            /// <summary>
            /// <para>A placeholder type used to construct an empty shell of a type,
            /// that will be filled in later (e.g., by some de-serialization).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A placeholder type used to construct an empty shell of
            /// a</para>
            /// <para>  /// type, that will be filled in later (e.g., by some</para>
            /// <para>  /// de-serialization).</para>
            /// </remarks>
            public unsafe partial class EmptyShell : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Stmt10EmptyShellC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EmptyShell> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EmptyShell>();

                private readonly bool __ownsNativeInstance;

                public static EmptyShell __CreateInstance(global::System.IntPtr native)
                {
                    return new EmptyShell((EmptyShell.Internal*) native);
                }

                public static EmptyShell __CreateInstance(EmptyShell.Internal native)
                {
                    return new EmptyShell(native);
                }

                private static EmptyShell.Internal* __CopyValue(EmptyShell.Internal native)
                {
                    var ret = (EmptyShell.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private EmptyShell(EmptyShell.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected EmptyShell(EmptyShell.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public EmptyShell()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Stmt.EmptyShell __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Stmt> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Stmt>();

            private readonly bool __ownsNativeInstance;

            public static Stmt __CreateInstance(global::System.IntPtr native)
            {
                return new Stmt((Stmt.Internal*) native);
            }

            public static Stmt __CreateInstance(Stmt.Internal native)
            {
                return new Stmt(native);
            }

            private static Stmt.Internal* __CopyValue(Stmt.Internal native)
            {
                var ret = (Stmt.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private Stmt(Stmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Stmt(Stmt.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Construct an empty statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty statement.</para>
            /// </remarks>
            protected Stmt(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(_0, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (_0.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            public Stmt(clang.Stmt.StmtClass SC)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                Internal.ctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Stmt.StmtClass getStmtClass()
            {
                var __ret = Internal.getStmtClass_0(__Instance);
                return __ret;
            }

            public string getStmtClassName()
            {
                var __ret = Internal.getStmtClassName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>SourceLocation tokens are not useful in isolation - they are low
            /// level value objects created/interpreted by SourceManager. We assume AST
            /// clients will have a pointer to the respective SourceManager.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SourceLocation tokens are not useful in isolation - they are
            /// low level</para>
            /// <para>  /// value objects created/interpreted by SourceManager. We
            /// assume AST</para>
            /// <para>  /// clients will have a pointer to the respective
            /// SourceManager.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Dumps the specified AST fragment and all subtrees to
            /// llvm::errs().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Dumps the specified AST fragment and all subtrees
            /// to</para>
            /// <para>  /// \c llvm::errs().</para>
            /// </remarks>
            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            public void dump(clang.SourceManager SM)
            {
                var arg0 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                Internal.dump_1(__Instance, arg0);
            }

            public void dump(llvm.raw_ostream OS, clang.SourceManager SM)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                Internal.dump_2(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>dumpColor - same as dump(), but forces color highlighting.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// dumpColor - same as dump(), but forces color
            /// highlighting.</para>
            /// </remarks>
            public void dumpColor()
            {
                Internal.dumpColor_0(__Instance);
            }

            /// <summary>
            /// <para>dumpPretty/printPretty - These two methods do a &quot;pretty
            /// print&quot; of the AST back to its original source language syntax.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// dumpPretty/printPretty - These two methods do a &quot;pretty
            /// print&quot; of the AST</para>
            /// <para>  /// back to its original source language syntax.</para>
            /// </remarks>
            public void dumpPretty(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.dumpPretty_0(__Instance, arg0);
            }

            public void printPretty(llvm.raw_ostream OS, clang.PrinterHelper Helper, clang.PrintingPolicy Policy, uint Indentation)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Helper, null) ? global::System.IntPtr.Zero : Helper.__Instance;
                var arg2 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.printPretty_0(__Instance, arg0, arg1, arg2, Indentation);
            }

            /// <summary>
            /// <para>viewAST - Visualize an AST rooted at this Stmt* using GraphViz.
            /// Only works on systems with GraphViz (Mac OS X) or dot+gv installed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// viewAST - Visualize an AST rooted at this Stmt* using
            /// GraphViz.  Only</para>
            /// <para>  ///   works on systems with GraphViz (Mac OS X) or dot+gv
            /// installed.</para>
            /// </remarks>
            public void viewAST()
            {
                Internal.viewAST_0(__Instance);
            }

            /// <summary>
            /// <para>Skip past any implicit AST nodes which might surround this
            /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Skip past any implicit AST nodes which might surround
            /// this</para>
            /// <para>  /// statement, such as ExprWithCleanups or ImplicitCastExpr
            /// nodes.</para>
            /// </remarks>
            public clang.Stmt IgnoreImplicit()
            {
                var __ret = Internal.IgnoreImplicit_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Skip no-op (attributed, compound) container stmts and skip
            /// captured stmt at the top, if IgnoreCaptured is true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Skip no-op (attributed, compound) container stmts and
            /// skip captured</para>
            /// <para>  /// stmt at the top, if \a IgnoreCaptured is true.</para>
            /// </remarks>
            public clang.Stmt IgnoreContainers(bool IgnoreCaptured)
            {
                var __ret = Internal.IgnoreContainers_0(__Instance, IgnoreCaptured);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt stripLabelLikeStatements()
            {
                var __ret = Internal.stripLabelLikeStatements_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public clang.StmtIterator child_begin()
            {
                var __ret = new clang.StmtIterator.Internal();
                Internal.child_begin_0(new IntPtr(&__ret), __Instance);
                return clang.StmtIterator.__CreateInstance(__ret);
            }

            public clang.StmtIterator child_end()
            {
                var __ret = new clang.StmtIterator.Internal();
                Internal.child_end_0(new IntPtr(&__ret), __Instance);
                return clang.StmtIterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Produce a unique representation of the given statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Produce a unique representation of the given
            /// statement.</para>
            /// <para>  ///</para>
            /// <para>  /// \param ID once the profiling operation is complete, will
            /// contain</para>
            /// <para>  /// the unique representation of the given statement.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Context the AST context in which the statement
            /// resides</para>
            /// <para>  ///</para>
            /// <para>  /// \param Canonical whether the profile should be based on the
            /// canonical</para>
            /// <para>  /// representation of this statement (e.g., where non-type
            /// template</para>
            /// <para>  /// parameters are identified by index/level rather than
            /// their</para>
            /// <para>  /// declaration pointers) or the exact representation of the
            /// statement as</para>
            /// <para>  /// written in the source.</para>
            /// </remarks>
            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Context, bool Canonical)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1, Canonical);
            }

            public static void addStmtClass(clang.Stmt.StmtClass s)
            {
                var arg0 = s;
                Internal.addStmtClass_0(arg0);
            }

            public static void EnableStatistics()
            {
                Internal.EnableStatistics_0();
            }

            public static void PrintStats()
            {
                Internal.PrintStats_0();
            }
        }

        /// <summary>
        /// <para>DeclStmt - Adaptor class for mixing declarations with statements
        /// and expressions. For example, CompoundStmt mixes statements, expressions
        /// and declarations (variables, types). Another example is ForStmt, where the
        /// first statement can be an expression or a declaration.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclStmt - Adaptor class for mixing declarations with
        /// statements and</para>
        /// <para>/// expressions. For example, CompoundStmt mixes statements,
        /// expressions</para>
        /// <para>/// and declarations (variables, types). Another example is
        /// ForStmt, where</para>
        /// <para>/// the first statement can be an expression or a
        /// declaration.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class DeclStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.DeclGroupRef.Internal DG;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal StartLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal EndLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmtC2ENS_12DeclGroupRefENS_14SourceLocationES2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.DeclGroupRef.Internal dg, clang.SourceLocation.Internal startLoc, clang.SourceLocation.Internal endLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8DeclStmt12isSingleDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSingleDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt13getSingleDeclEv")]
                internal static extern global::System.IntPtr getSingleDecl_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt12getDeclGroupEv")]
                internal static extern clang.DeclGroupRef.Internal getDeclGroup_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt12setDeclGroupENS_12DeclGroupRefE")]
                internal static extern void setDeclGroup_0(global::System.IntPtr instance, clang.DeclGroupRef.Internal DGR);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8DeclStmt11getStartLocEv")]
                internal static extern clang.SourceLocation.Internal getStartLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt11setStartLocENS_14SourceLocationE")]
                internal static extern void setStartLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8DeclStmt9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt9setEndLocENS_14SourceLocationE")]
                internal static extern void setEndLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8DeclStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8DeclStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt10decl_beginEv")]
                internal static extern global::System.IntPtr decl_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8DeclStmt8decl_endEv")]
                internal static extern global::System.IntPtr decl_end_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new DeclStmt __CreateInstance(global::System.IntPtr native)
            {
                return new DeclStmt((DeclStmt.Internal*) native);
            }

            public static DeclStmt __CreateInstance(DeclStmt.Internal native)
            {
                return new DeclStmt(native);
            }

            private static DeclStmt.Internal* __CopyValue(DeclStmt.Internal native)
            {
                var ret = (DeclStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private DeclStmt(DeclStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclStmt(DeclStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public DeclStmt(clang.DeclGroupRef dg, clang.SourceLocation startLoc, clang.SourceLocation endLoc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(dg, null) ? new clang.DeclGroupRef.Internal() : *(clang.DeclGroupRef.Internal*) (dg.__Instance);
                var arg1 = ReferenceEquals(startLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (startLoc.__Instance);
                var arg2 = ReferenceEquals(endLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (endLoc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Build an empty declaration statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty declaration statement.</para>
            /// </remarks>
            public DeclStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>isSingleDecl - This method returns true if this DeclStmt refers
            /// to a single Decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSingleDecl - This method returns true if this DeclStmt
            /// refers</para>
            /// <para>  /// to a single Decl.</para>
            /// </remarks>
            public bool isSingleDecl()
            {
                var __ret = Internal.isSingleDecl_0(__Instance);
                return __ret;
            }

            public clang.Decl getSingleDecl()
            {
                var __ret = Internal.getSingleDecl_1(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DeclGroupRef getDeclGroup()
            {
                var __ret = Internal.getDeclGroup_1(__Instance);
                return clang.DeclGroupRef.__CreateInstance(__ret);
            }

            public void setDeclGroup(clang.DeclGroupRef DGR)
            {
                var arg0 = ReferenceEquals(DGR, null) ? new clang.DeclGroupRef.Internal() : *(clang.DeclGroupRef.Internal*) (DGR.__Instance);
                Internal.setDeclGroup_0(__Instance, arg0);
            }

            public clang.SourceLocation getStartLoc()
            {
                var __ret = Internal.getStartLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStartLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setStartLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setEndLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setEndLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public clang.Decl decl_begin()
            {
                var __ret = Internal.decl_begin_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Decl decl_end()
            {
                var __ret = Internal.decl_end_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>NullStmt - This is the null statement &quot;;&quot;: C99
        /// 6.8.3p3.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// NullStmt - This is the null statement &quot;;&quot;: C99
        /// 6.8.3p3.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class NullStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal SemiLoc;

                [FieldOffset(12)]
                public bool HasLeadingEmptyMacro;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmtC2ENS_14SourceLocationEb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal L, bool hasLeadingEmptyMacro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8NullStmt10getSemiLocEv")]
                internal static extern clang.SourceLocation.Internal getSemiLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmt10setSemiLocENS_14SourceLocationE")]
                internal static extern void setSemiLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8NullStmt20hasLeadingEmptyMacroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLeadingEmptyMacro_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8NullStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8NullStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8NullStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new NullStmt __CreateInstance(global::System.IntPtr native)
            {
                return new NullStmt((NullStmt.Internal*) native);
            }

            public static NullStmt __CreateInstance(NullStmt.Internal native)
            {
                return new NullStmt(native);
            }

            private static NullStmt.Internal* __CopyValue(NullStmt.Internal native)
            {
                var ret = (NullStmt.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private NullStmt(NullStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NullStmt(NullStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public NullStmt(clang.SourceLocation L, bool hasLeadingEmptyMacro)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.ctor_0(__Instance, arg0, hasLeadingEmptyMacro);
            }

            /// <summary>
            /// <para>Build an empty null statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty null statement.</para>
            /// </remarks>
            public NullStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getSemiLoc()
            {
                var __ret = Internal.getSemiLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setSemiLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setSemiLoc_0(__Instance, arg0);
            }

            public bool hasLeadingEmptyMacro()
            {
                var __ret = Internal.hasLeadingEmptyMacro_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CompoundStmt - This represents a group of statements like { stmt
        /// stmt }.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CompoundStmt - This represents a group of statements like {
        /// stmt stmt }.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class CompoundStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr Body;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal LBraceLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal RBraceLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmtC2ENS_14SourceLocationE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmtC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt8setStmtsERKNS_10ASTContextEPPNS_4StmtEj")]
                internal static extern void setStmts_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr Stmts, uint NumStmts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt10body_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool body_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt10body_beginEv")]
                internal static extern global::System.IntPtr body_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt8body_endEv")]
                internal static extern global::System.IntPtr body_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt10body_frontEv")]
                internal static extern global::System.IntPtr body_front_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt9body_backEv")]
                internal static extern global::System.IntPtr body_back_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt11setLastStmtEPNS_4StmtE")]
                internal static extern void setLastStmt_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt11getLBracLocEv")]
                internal static extern clang.SourceLocation.Internal getLBracLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CompoundStmt11getRBracLocEv")]
                internal static extern clang.SourceLocation.Internal getRBracLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CompoundStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new CompoundStmt __CreateInstance(global::System.IntPtr native)
            {
                return new CompoundStmt((CompoundStmt.Internal*) native);
            }

            public static CompoundStmt __CreateInstance(CompoundStmt.Internal native)
            {
                return new CompoundStmt(native);
            }

            private static CompoundStmt.Internal* __CopyValue(CompoundStmt.Internal native)
            {
                var ret = (CompoundStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private CompoundStmt(CompoundStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CompoundStmt(CompoundStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public CompoundStmt(clang.SourceLocation Loc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            public CompoundStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_2(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void setStmts(clang.ASTContext C, clang.Stmt Stmts, uint NumStmts)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(Stmts, null) ? global::System.IntPtr.Zero : Stmts.__Instance;
                Internal.setStmts_0(__Instance, arg0, arg1, NumStmts);
            }

            public bool body_empty()
            {
                var __ret = Internal.body_empty_0(__Instance);
                return __ret;
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public clang.Stmt body_begin()
            {
                var __ret = Internal.body_begin_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt body_end()
            {
                var __ret = Internal.body_end_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt body_front()
            {
                var __ret = Internal.body_front_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt body_back()
            {
                var __ret = Internal.body_back_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setLastStmt(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setLastStmt_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLBracLoc()
            {
                var __ret = Internal.getLBracLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRBracLoc()
            {
                var __ret = Internal.getRBracLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class SwitchCase : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr NextSwitchCase;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal KeywordLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCaseC2ENS_4Stmt9StmtClassENS_14SourceLocationES3_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.SourceLocation.Internal KWLoc, clang.SourceLocation.Internal ColonLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCaseC2ENS_4Stmt9StmtClassENS1_10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCaseC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase17getNextSwitchCaseEv")]
                internal static extern global::System.IntPtr getNextSwitchCase_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase17setNextSwitchCaseEPS0_")]
                internal static extern void setNextSwitchCase_0(global::System.IntPtr instance, global::System.IntPtr SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchCase13getKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase13setKeywordLocENS_14SourceLocationE")]
                internal static extern void setKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchCase11getColonLocEv")]
                internal static extern clang.SourceLocation.Internal getColonLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase11setColonLocENS_14SourceLocationE")]
                internal static extern void setColonLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchCase11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchCase9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchCase7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SwitchCase __CreateInstance(global::System.IntPtr native)
            {
                return new SwitchCase((SwitchCase.Internal*) native);
            }

            public static SwitchCase __CreateInstance(SwitchCase.Internal native)
            {
                return new SwitchCase(native);
            }

            private static SwitchCase.Internal* __CopyValue(SwitchCase.Internal native)
            {
                var ret = (SwitchCase.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private SwitchCase(SwitchCase.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SwitchCase(SwitchCase.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected SwitchCase(clang.Stmt.StmtClass SC, clang.SourceLocation KWLoc, clang.SourceLocation ColonLoc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(KWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (KWLoc.__Instance);
                var arg2 = ReferenceEquals(ColonLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ColonLoc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            protected SwitchCase(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell _0)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(_0, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (_0.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SwitchCase getNextSwitchCase()
            {
                var __ret = Internal.getNextSwitchCase_1(__Instance);
                clang.SwitchCase __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SwitchCase.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SwitchCase) clang.SwitchCase.NativeToManagedMap[__ret];
                else __result0 = clang.SwitchCase.__CreateInstance(__ret);
                return __result0;
            }

            public void setNextSwitchCase(clang.SwitchCase SC)
            {
                var arg0 = ReferenceEquals(SC, null) ? global::System.IntPtr.Zero : SC.__Instance;
                Internal.setNextSwitchCase_0(__Instance, arg0);
            }

            public clang.SourceLocation getKeywordLoc()
            {
                var __ret = Internal.getKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setKeywordLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setKeywordLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getColonLoc()
            {
                var __ret = Internal.getColonLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setColonLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setColonLoc_0(__Instance, arg0);
            }

            public clang.Stmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            protected clang.SwitchCase NextSwitchCase
            {
                get
                {
                    clang.SwitchCase __result0;
                    if (((Internal*) __Instance)->NextSwitchCase == IntPtr.Zero) __result0 = null;
                    else if (clang.SwitchCase.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->NextSwitchCase))
                        __result0 = (clang.SwitchCase) clang.SwitchCase.NativeToManagedMap[((Internal*) __Instance)->NextSwitchCase];
                    else __result0 = clang.SwitchCase.__CreateInstance(((Internal*) __Instance)->NextSwitchCase);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->NextSwitchCase = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            protected clang.SourceLocation KeywordLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->KeywordLoc);
                }

                set
                {
                    ((Internal*) __Instance)->KeywordLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            protected clang.SourceLocation ColonLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->ColonLoc);
                }

                set
                {
                    ((Internal*) __Instance)->ColonLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class CaseStmt : clang.SwitchCase, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr NextSwitchCase;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal KeywordLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [FieldOffset(24)]
                public fixed global::System.IntPtr SubExprs[3];

                [FieldOffset(48)]
                public clang.SourceLocation.Internal EllipsisLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CaseStmt10getCaseLocEv")]
                internal static extern clang.SourceLocation.Internal getCaseLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt10setCaseLocENS_14SourceLocationE")]
                internal static extern void setCaseLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CaseStmt14getEllipsisLocEv")]
                internal static extern clang.SourceLocation.Internal getEllipsisLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt14setEllipsisLocENS_14SourceLocationE")]
                internal static extern void setEllipsisLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CaseStmt11getColonLocEv")]
                internal static extern clang.SourceLocation.Internal getColonLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt11setColonLocENS_14SourceLocationE")]
                internal static extern void setColonLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt10setSubStmtEPNS_4StmtE")]
                internal static extern void setSubStmt_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CaseStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CaseStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CaseStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new CaseStmt __CreateInstance(global::System.IntPtr native)
            {
                return new CaseStmt((CaseStmt.Internal*) native);
            }

            public static CaseStmt __CreateInstance(CaseStmt.Internal native)
            {
                return new CaseStmt(native);
            }

            private static CaseStmt.Internal* __CopyValue(CaseStmt.Internal native)
            {
                var ret = (CaseStmt.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private CaseStmt(CaseStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CaseStmt(CaseStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.SwitchCase.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty switch case statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty switch case statement.</para>
            /// </remarks>
            public CaseStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getCaseLoc()
            {
                var __ret = Internal.getCaseLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setCaseLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setCaseLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getEllipsisLoc()
            {
                var __ret = Internal.getEllipsisLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setEllipsisLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setEllipsisLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getColonLoc()
            {
                var __ret = Internal.getColonLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setColonLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setColonLoc_0(__Instance, arg0);
            }

            public clang.Stmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubStmt(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setSubStmt_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class DefaultStmt : clang.SwitchCase, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr NextSwitchCase;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal KeywordLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [FieldOffset(24)]
                public global::System.IntPtr SubStmt;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmtC2ENS_14SourceLocationES1_PNS_4StmtE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal DL, clang.SourceLocation.Internal CL, global::System.IntPtr substmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt10setSubStmtEPNS_4StmtE")]
                internal static extern void setSubStmt_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DefaultStmt13getDefaultLocEv")]
                internal static extern clang.SourceLocation.Internal getDefaultLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt13setDefaultLocENS_14SourceLocationE")]
                internal static extern void setDefaultLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DefaultStmt11getColonLocEv")]
                internal static extern clang.SourceLocation.Internal getColonLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt11setColonLocENS_14SourceLocationE")]
                internal static extern void setColonLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DefaultStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DefaultStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DefaultStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new DefaultStmt __CreateInstance(global::System.IntPtr native)
            {
                return new DefaultStmt((DefaultStmt.Internal*) native);
            }

            public static DefaultStmt __CreateInstance(DefaultStmt.Internal native)
            {
                return new DefaultStmt(native);
            }

            private static DefaultStmt.Internal* __CopyValue(DefaultStmt.Internal native)
            {
                var ret = (DefaultStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private DefaultStmt(DefaultStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DefaultStmt(DefaultStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.SwitchCase.Internal*) native)
            {
            }

            public DefaultStmt(clang.SourceLocation DL, clang.SourceLocation CL, clang.Stmt substmt)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(DL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (DL.__Instance);
                var arg1 = ReferenceEquals(CL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (CL.__Instance);
                var arg2 = ReferenceEquals(substmt, null) ? global::System.IntPtr.Zero : substmt.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Build an empty default statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty default statement.</para>
            /// </remarks>
            public DefaultStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Stmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubStmt(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setSubStmt_0(__Instance, arg0);
            }

            public clang.SourceLocation getDefaultLoc()
            {
                var __ret = Internal.getDefaultLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setDefaultLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setDefaultLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getColonLoc()
            {
                var __ret = Internal.getColonLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setColonLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setColonLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>LabelStmt - Represents a label, which has a substatement. For
        /// example: foo: return;</para>
        /// </summary>
        /// <remarks>
        /// <para>/// LabelStmt - Represents a label, which has a substatement.
        /// For example:</para>
        /// <para>///    foo: return;</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class LabelStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr TheDecl;

                [FieldOffset(16)]
                public global::System.IntPtr SubStmt;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal IdentLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmtC2ENS_14SourceLocationEPNS_9LabelDeclEPNS_4StmtE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal IL, global::System.IntPtr D, global::System.IntPtr substmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelStmt11getIdentLocEv")]
                internal static extern clang.SourceLocation.Internal getIdentLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelStmt7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt7setDeclEPNS_9LabelDeclE")]
                internal static extern void setDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelStmt7getNameEv")]
                internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt11setIdentLocENS_14SourceLocationE")]
                internal static extern void setIdentLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt10setSubStmtEPNS_4StmtE")]
                internal static extern void setSubStmt_0(global::System.IntPtr instance, global::System.IntPtr SS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new LabelStmt __CreateInstance(global::System.IntPtr native)
            {
                return new LabelStmt((LabelStmt.Internal*) native);
            }

            public static LabelStmt __CreateInstance(LabelStmt.Internal native)
            {
                return new LabelStmt(native);
            }

            private static LabelStmt.Internal* __CopyValue(LabelStmt.Internal native)
            {
                var ret = (LabelStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private LabelStmt(LabelStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LabelStmt(LabelStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public LabelStmt(clang.SourceLocation IL, clang.LabelDecl D, clang.Stmt substmt)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(IL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IL.__Instance);
                var arg1 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg2 = ReferenceEquals(substmt, null) ? global::System.IntPtr.Zero : substmt.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            public LabelStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getIdentLoc()
            {
                var __ret = Internal.getIdentLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.LabelDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setDecl(clang.LabelDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setDecl_0(__Instance, arg0);
            }

            public string getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public clang.Stmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setIdentLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setIdentLoc_0(__Instance, arg0);
            }

            public void setSubStmt(clang.Stmt SS)
            {
                var arg0 = ReferenceEquals(SS, null) ? global::System.IntPtr.Zero : SS.__Instance;
                Internal.setSubStmt_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents an attribute applied to a statement.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents an attribute applied to a statement.</para>
        /// <para>///</para>
        /// <para>/// Represents an attribute applied to a statement. For
        /// example:</para>
        /// <para>///   [[omp::for(...)]] for (...) { ... }</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class AttributedStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr SubStmt;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal AttrLoc;

                [FieldOffset(20)]
                public uint NumAttrs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedStmt11CreateEmptyERKNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateEmpty_0(global::System.IntPtr C, uint NumAttrs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedStmt10getAttrLocEv")]
                internal static extern clang.SourceLocation.Internal getAttrLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedStmt10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new AttributedStmt __CreateInstance(global::System.IntPtr native)
            {
                return new AttributedStmt((AttributedStmt.Internal*) native);
            }

            public static AttributedStmt __CreateInstance(AttributedStmt.Internal native)
            {
                return new AttributedStmt(native);
            }

            private static AttributedStmt.Internal* __CopyValue(AttributedStmt.Internal native)
            {
                var ret = (AttributedStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private AttributedStmt(AttributedStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AttributedStmt(AttributedStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAttrLoc()
            {
                var __ret = Internal.getAttrLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.Stmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static clang.AttributedStmt CreateEmpty(clang.ASTContext C, uint NumAttrs)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateEmpty_0(arg0, NumAttrs);
                clang.AttributedStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.AttributedStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.AttributedStmt) clang.AttributedStmt.NativeToManagedMap[__ret];
                else __result0 = clang.AttributedStmt.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>IfStmt - This represents an if/then/else.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// IfStmt - This represents an if/then/else.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class IfStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public fixed global::System.IntPtr SubExprs[4];

                [FieldOffset(40)]
                public clang.SourceLocation.Internal IfLoc;

                [FieldOffset(44)]
                public clang.SourceLocation.Internal ElseLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt20getConditionVariableEv")]
                internal static extern global::System.IntPtr getConditionVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt20setConditionVariableERKNS_10ASTContextEPNS_7VarDeclE")]
                internal static extern void setConditionVariable_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt28getConditionVariableDeclStmtEv")]
                internal static extern global::System.IntPtr getConditionVariableDeclStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt7setThenEPNS_4StmtE")]
                internal static extern void setThen_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt7setElseEPNS_4StmtE")]
                internal static extern void setElse_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt7getThenEv")]
                internal static extern global::System.IntPtr getThen_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt7getElseEv")]
                internal static extern global::System.IntPtr getElse_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt8getIfLocEv")]
                internal static extern clang.SourceLocation.Internal getIfLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt8setIfLocENS_14SourceLocationE")]
                internal static extern void setIfLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt10getElseLocEv")]
                internal static extern clang.SourceLocation.Internal getElseLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt10setElseLocENS_14SourceLocationE")]
                internal static extern void setElseLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6IfStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6IfStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new IfStmt __CreateInstance(global::System.IntPtr native)
            {
                return new IfStmt((IfStmt.Internal*) native);
            }

            public static IfStmt __CreateInstance(IfStmt.Internal native)
            {
                return new IfStmt(native);
            }

            private static IfStmt.Internal* __CopyValue(IfStmt.Internal native)
            {
                var ret = (IfStmt.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private IfStmt(IfStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IfStmt(IfStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty if/then/else statement</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty if/then/else statement</para>
            /// </remarks>
            public IfStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the variable declared in this &quot;if&quot; statement,
            /// if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the variable declared in this &quot;if&quot;
            /// statement, if any.</para>
            /// <para>  ///</para>
            /// <para>  /// In the following example, &quot;x&quot; is the condition
            /// variable.</para>
            /// <para>  /// \code</para>
            /// <para>  /// if (int x = foo()) {</para>
            /// <para>  ///   printf(&quot;x is %d&quot;, x);</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public clang.VarDecl getConditionVariable()
            {
                var __ret = Internal.getConditionVariable_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setConditionVariable(clang.ASTContext C, clang.VarDecl V)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                Internal.setConditionVariable_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>If this IfStmt has a condition variable, return the faux DeclStmt
            /// associated with the creation of that condition variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this IfStmt has a condition variable, return the faux
            /// DeclStmt</para>
            /// <para>  /// associated with the creation of that condition
            /// variable.</para>
            /// </remarks>
            public clang.DeclStmt getConditionVariableDeclStmt()
            {
                var __ret = Internal.getConditionVariableDeclStmt_0(__Instance);
                clang.DeclStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclStmt) clang.DeclStmt.NativeToManagedMap[__ret];
                else __result0 = clang.DeclStmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setThen(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setThen_0(__Instance, arg0);
            }

            public void setElse(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setElse_0(__Instance, arg0);
            }

            public clang.Stmt getThen()
            {
                var __ret = Internal.getThen_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt getElse()
            {
                var __ret = Internal.getElse_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getIfLoc()
            {
                var __ret = Internal.getIfLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setIfLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setIfLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getElseLoc()
            {
                var __ret = Internal.getElseLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setElseLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setElseLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>SwitchStmt - This represents a 'switch' stmt.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SwitchStmt - This represents a 'switch' stmt.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class SwitchStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public fixed global::System.IntPtr SubExprs[3];

                [FieldOffset(32)]
                public global::System.IntPtr FirstCase;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal SwitchLoc;

                [FieldOffset(44)]
                public uint AllEnumCasesCovered;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt20getConditionVariableEv")]
                internal static extern global::System.IntPtr getConditionVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt20setConditionVariableERKNS_10ASTContextEPNS_7VarDeclE")]
                internal static extern void setConditionVariable_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt28getConditionVariableDeclStmtEv")]
                internal static extern global::System.IntPtr getConditionVariableDeclStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt7getBodyEv")]
                internal static extern global::System.IntPtr getBody_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt17getSwitchCaseListEv")]
                internal static extern global::System.IntPtr getSwitchCaseList_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt17setSwitchCaseListEPNS_10SwitchCaseE")]
                internal static extern void setSwitchCaseList_0(global::System.IntPtr instance, global::System.IntPtr SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt12getSwitchLocEv")]
                internal static extern clang.SourceLocation.Internal getSwitchLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt12setSwitchLocENS_14SourceLocationE")]
                internal static extern void setSwitchLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt7setBodyEPNS_4StmtENS_14SourceLocationE")]
                internal static extern void setBody_1(global::System.IntPtr instance, global::System.IntPtr S, clang.SourceLocation.Internal SL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt13addSwitchCaseEPNS_10SwitchCaseE")]
                internal static extern void addSwitchCase_0(global::System.IntPtr instance, global::System.IntPtr SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt22setAllEnumCasesCoveredEv")]
                internal static extern void setAllEnumCasesCovered_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt21isAllEnumCasesCoveredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAllEnumCasesCovered_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SwitchStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SwitchStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SwitchStmt __CreateInstance(global::System.IntPtr native)
            {
                return new SwitchStmt((SwitchStmt.Internal*) native);
            }

            public static SwitchStmt __CreateInstance(SwitchStmt.Internal native)
            {
                return new SwitchStmt(native);
            }

            private static SwitchStmt.Internal* __CopyValue(SwitchStmt.Internal native)
            {
                var ret = (SwitchStmt.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private SwitchStmt(SwitchStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SwitchStmt(SwitchStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build a empty switch statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build a empty switch statement.</para>
            /// </remarks>
            public SwitchStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the variable declared in this &quot;switch&quot;
            /// statement, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the variable declared in this
            /// &quot;switch&quot; statement, if any.</para>
            /// <para>  ///</para>
            /// <para>  /// In the following example, &quot;x&quot; is the condition
            /// variable.</para>
            /// <para>  /// \code</para>
            /// <para>  /// switch (int x = foo()) {</para>
            /// <para>  ///   case 0: break;</para>
            /// <para>  ///   // ...</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public clang.VarDecl getConditionVariable()
            {
                var __ret = Internal.getConditionVariable_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setConditionVariable(clang.ASTContext C, clang.VarDecl V)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                Internal.setConditionVariable_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>If this SwitchStmt has a condition variable, return the faux
            /// DeclStmt associated with the creation of that condition variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this SwitchStmt has a condition variable, return the faux
            /// DeclStmt</para>
            /// <para>  /// associated with the creation of that condition
            /// variable.</para>
            /// </remarks>
            public clang.DeclStmt getConditionVariableDeclStmt()
            {
                var __ret = Internal.getConditionVariableDeclStmt_0(__Instance);
                clang.DeclStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclStmt) clang.DeclStmt.NativeToManagedMap[__ret];
                else __result0 = clang.DeclStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt getBody()
            {
                var __ret = Internal.getBody_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setBody(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public clang.SwitchCase getSwitchCaseList()
            {
                var __ret = Internal.getSwitchCaseList_1(__Instance);
                clang.SwitchCase __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SwitchCase.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SwitchCase) clang.SwitchCase.NativeToManagedMap[__ret];
                else __result0 = clang.SwitchCase.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set the case list for this switch statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the case list for this switch statement.</para>
            /// </remarks>
            public void setSwitchCaseList(clang.SwitchCase SC)
            {
                var arg0 = ReferenceEquals(SC, null) ? global::System.IntPtr.Zero : SC.__Instance;
                Internal.setSwitchCaseList_0(__Instance, arg0);
            }

            public clang.SourceLocation getSwitchLoc()
            {
                var __ret = Internal.getSwitchLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setSwitchLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setSwitchLoc_0(__Instance, arg0);
            }

            public void setBody(clang.Stmt S, clang.SourceLocation SL)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                var arg1 = ReferenceEquals(SL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SL.__Instance);
                Internal.setBody_1(__Instance, arg0, arg1);
            }

            public void addSwitchCase(clang.SwitchCase SC)
            {
                var arg0 = ReferenceEquals(SC, null) ? global::System.IntPtr.Zero : SC.__Instance;
                Internal.addSwitchCase_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Set a flag in the SwitchStmt indicating that if the 'switch (X)'
            /// is a switch over an enum value then all cases have been explicitly
            /// covered.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Set a flag in the SwitchStmt indicating that if the 'switch
            /// (X)' is a</para>
            /// <para>  /// switch over an enum value then all cases have been
            /// explicitly covered.</para>
            /// </remarks>
            public void setAllEnumCasesCovered()
            {
                Internal.setAllEnumCasesCovered_0(__Instance);
            }

            /// <summary>
            /// <para>Returns true if the SwitchStmt is a switch of an enum value and
            /// all cases have been explicitly covered.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if the SwitchStmt is a switch of an enum value
            /// and all cases</para>
            /// <para>  /// have been explicitly covered.</para>
            /// </remarks>
            public bool isAllEnumCasesCovered()
            {
                var __ret = Internal.isAllEnumCasesCovered_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>WhileStmt - This represents a 'while' stmt.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// WhileStmt - This represents a 'while' stmt.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class WhileStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public fixed global::System.IntPtr SubExprs[3];

                [FieldOffset(32)]
                public clang.SourceLocation.Internal WhileLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9WhileStmt20getConditionVariableEv")]
                internal static extern global::System.IntPtr getConditionVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt20setConditionVariableERKNS_10ASTContextEPNS_7VarDeclE")]
                internal static extern void setConditionVariable_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9WhileStmt28getConditionVariableDeclStmtEv")]
                internal static extern global::System.IntPtr getConditionVariableDeclStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9WhileStmt11getWhileLocEv")]
                internal static extern clang.SourceLocation.Internal getWhileLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt11setWhileLocENS_14SourceLocationE")]
                internal static extern void setWhileLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9WhileStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9WhileStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9WhileStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new WhileStmt __CreateInstance(global::System.IntPtr native)
            {
                return new WhileStmt((WhileStmt.Internal*) native);
            }

            public static WhileStmt __CreateInstance(WhileStmt.Internal native)
            {
                return new WhileStmt(native);
            }

            private static WhileStmt.Internal* __CopyValue(WhileStmt.Internal native)
            {
                var ret = (WhileStmt.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private WhileStmt(WhileStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected WhileStmt(WhileStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty while statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty while statement.</para>
            /// </remarks>
            public WhileStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the variable declared in this &quot;while&quot;
            /// statement, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the variable declared in this
            /// &quot;while&quot; statement, if any.</para>
            /// <para>  ///</para>
            /// <para>  /// In the following example, &quot;x&quot; is the condition
            /// variable.</para>
            /// <para>  /// \code</para>
            /// <para>  /// while (int x = random()) {</para>
            /// <para>  ///   // ...</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public clang.VarDecl getConditionVariable()
            {
                var __ret = Internal.getConditionVariable_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setConditionVariable(clang.ASTContext C, clang.VarDecl V)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                Internal.setConditionVariable_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>If this WhileStmt has a condition variable, return the faux
            /// DeclStmt associated with the creation of that condition variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this WhileStmt has a condition variable, return the faux
            /// DeclStmt</para>
            /// <para>  /// associated with the creation of that condition
            /// variable.</para>
            /// </remarks>
            public clang.DeclStmt getConditionVariableDeclStmt()
            {
                var __ret = Internal.getConditionVariableDeclStmt_0(__Instance);
                clang.DeclStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclStmt) clang.DeclStmt.NativeToManagedMap[__ret];
                else __result0 = clang.DeclStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setBody(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public clang.SourceLocation getWhileLoc()
            {
                var __ret = Internal.getWhileLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setWhileLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setWhileLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>DoStmt - This represents a 'do/while' stmt.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DoStmt - This represents a 'do/while' stmt.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class DoStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public fixed global::System.IntPtr SubExprs[2];

                [FieldOffset(24)]
                public clang.SourceLocation.Internal DoLoc;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal WhileLoc;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6DoStmt8getDoLocEv")]
                internal static extern clang.SourceLocation.Internal getDoLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt8setDoLocENS_14SourceLocationE")]
                internal static extern void setDoLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6DoStmt11getWhileLocEv")]
                internal static extern clang.SourceLocation.Internal getWhileLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt11setWhileLocENS_14SourceLocationE")]
                internal static extern void setWhileLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6DoStmt12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6DoStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6DoStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6DoStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new DoStmt __CreateInstance(global::System.IntPtr native)
            {
                return new DoStmt((DoStmt.Internal*) native);
            }

            public static DoStmt __CreateInstance(DoStmt.Internal native)
            {
                return new DoStmt(native);
            }

            private static DoStmt.Internal* __CopyValue(DoStmt.Internal native)
            {
                var ret = (DoStmt.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private DoStmt(DoStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DoStmt(DoStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty do-while statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty do-while statement.</para>
            /// </remarks>
            public DoStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setBody(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public clang.SourceLocation getDoLoc()
            {
                var __ret = Internal.getDoLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setDoLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setDoLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getWhileLoc()
            {
                var __ret = Internal.getWhileLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setWhileLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setWhileLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ForStmt - This represents a 'for (init;cond;inc)' stmt. Note that
        /// any of the init/cond/inc parts of the ForStmt will be null if they were not
        /// specified in the source.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note
        /// that any of</para>
        /// <para>/// the init/cond/inc parts of the ForStmt will be null if they
        /// were not</para>
        /// <para>/// specified in the source.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ForStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public fixed global::System.IntPtr SubExprs[5];

                [FieldOffset(48)]
                public clang.SourceLocation.Internal ForLoc;

                [FieldOffset(52)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt7getInitEv")]
                internal static extern global::System.IntPtr getInit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt20getConditionVariableEv")]
                internal static extern global::System.IntPtr getConditionVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt20setConditionVariableERKNS_10ASTContextEPNS_7VarDeclE")]
                internal static extern void setConditionVariable_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt28getConditionVariableDeclStmtEv")]
                internal static extern global::System.IntPtr getConditionVariableDeclStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt7setInitEPNS_4StmtE")]
                internal static extern void setInit_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt9getForLocEv")]
                internal static extern clang.SourceLocation.Internal getForLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt9setForLocENS_14SourceLocationE")]
                internal static extern void setForLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7ForStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7ForStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ForStmt __CreateInstance(global::System.IntPtr native)
            {
                return new ForStmt((ForStmt.Internal*) native);
            }

            public static ForStmt __CreateInstance(ForStmt.Internal native)
            {
                return new ForStmt(native);
            }

            private static ForStmt.Internal* __CopyValue(ForStmt.Internal native)
            {
                var ret = (ForStmt.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private ForStmt(ForStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ForStmt(ForStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty for statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty for statement.</para>
            /// </remarks>
            public ForStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(64);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Stmt getInit()
            {
                var __ret = Internal.getInit_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the variable declared in this &quot;for&quot; statement,
            /// if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the variable declared in this &quot;for&quot;
            /// statement, if any.</para>
            /// <para>  ///</para>
            /// <para>  /// In the following example, &quot;y&quot; is the condition
            /// variable.</para>
            /// <para>  /// \code</para>
            /// <para>  /// for (int x = random(); int y = mangle(x); ++x) {</para>
            /// <para>  ///   // ...</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public clang.VarDecl getConditionVariable()
            {
                var __ret = Internal.getConditionVariable_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setConditionVariable(clang.ASTContext C, clang.VarDecl V)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                Internal.setConditionVariable_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>If this ForStmt has a condition variable, return the faux
            /// DeclStmt associated with the creation of that condition variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this ForStmt has a condition variable, return the faux
            /// DeclStmt</para>
            /// <para>  /// associated with the creation of that condition
            /// variable.</para>
            /// </remarks>
            public clang.DeclStmt getConditionVariableDeclStmt()
            {
                var __ret = Internal.getConditionVariableDeclStmt_0(__Instance);
                clang.DeclStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclStmt) clang.DeclStmt.NativeToManagedMap[__ret];
                else __result0 = clang.DeclStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setInit(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setInit_0(__Instance, arg0);
            }

            public void setBody(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public clang.SourceLocation getForLoc()
            {
                var __ret = Internal.getForLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setForLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setForLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>GotoStmt - This represents a direct goto.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// GotoStmt - This represents a direct goto.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class GotoStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr Label;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal GotoLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal LabelLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmtC2EPNS_9LabelDeclENS_14SourceLocationES3_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr label, clang.SourceLocation.Internal GL, clang.SourceLocation.Internal LL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8GotoStmt8getLabelEv")]
                internal static extern global::System.IntPtr getLabel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmt8setLabelEPNS_9LabelDeclE")]
                internal static extern void setLabel_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8GotoStmt10getGotoLocEv")]
                internal static extern clang.SourceLocation.Internal getGotoLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmt10setGotoLocENS_14SourceLocationE")]
                internal static extern void setGotoLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8GotoStmt11getLabelLocEv")]
                internal static extern clang.SourceLocation.Internal getLabelLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmt11setLabelLocENS_14SourceLocationE")]
                internal static extern void setLabelLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8GotoStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8GotoStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8GotoStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new GotoStmt __CreateInstance(global::System.IntPtr native)
            {
                return new GotoStmt((GotoStmt.Internal*) native);
            }

            public static GotoStmt __CreateInstance(GotoStmt.Internal native)
            {
                return new GotoStmt(native);
            }

            private static GotoStmt.Internal* __CopyValue(GotoStmt.Internal native)
            {
                var ret = (GotoStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private GotoStmt(GotoStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected GotoStmt(GotoStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public GotoStmt(clang.LabelDecl label, clang.SourceLocation GL, clang.SourceLocation LL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(label, null) ? global::System.IntPtr.Zero : label.__Instance;
                var arg1 = ReferenceEquals(GL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (GL.__Instance);
                var arg2 = ReferenceEquals(LL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LL.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Build an empty goto statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty goto statement.</para>
            /// </remarks>
            public GotoStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.LabelDecl getLabel()
            {
                var __ret = Internal.getLabel_0(__Instance);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setLabel(clang.LabelDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setLabel_0(__Instance, arg0);
            }

            public clang.SourceLocation getGotoLoc()
            {
                var __ret = Internal.getGotoLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setGotoLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setGotoLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLabelLoc()
            {
                var __ret = Internal.getLabelLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLabelLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLabelLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>IndirectGotoStmt - This represents an indirect goto.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// IndirectGotoStmt - This represents an indirect goto.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class IndirectGotoStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal GotoLoc;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal StarLoc;

                [FieldOffset(16)]
                public global::System.IntPtr Target;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmt10setGotoLocENS_14SourceLocationE")]
                internal static extern void setGotoLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16IndirectGotoStmt10getGotoLocEv")]
                internal static extern clang.SourceLocation.Internal getGotoLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmt10setStarLocENS_14SourceLocationE")]
                internal static extern void setStarLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16IndirectGotoStmt10getStarLocEv")]
                internal static extern clang.SourceLocation.Internal getStarLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmt17getConstantTargetEv")]
                internal static extern global::System.IntPtr getConstantTarget_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16IndirectGotoStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16IndirectGotoStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IndirectGotoStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new IndirectGotoStmt __CreateInstance(global::System.IntPtr native)
            {
                return new IndirectGotoStmt((IndirectGotoStmt.Internal*) native);
            }

            public static IndirectGotoStmt __CreateInstance(IndirectGotoStmt.Internal native)
            {
                return new IndirectGotoStmt(native);
            }

            private static IndirectGotoStmt.Internal* __CopyValue(IndirectGotoStmt.Internal native)
            {
                var ret = (IndirectGotoStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private IndirectGotoStmt(IndirectGotoStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IndirectGotoStmt(IndirectGotoStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty indirect goto statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty indirect goto statement.</para>
            /// </remarks>
            public IndirectGotoStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void setGotoLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setGotoLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getGotoLoc()
            {
                var __ret = Internal.getGotoLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStarLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setStarLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getStarLoc()
            {
                var __ret = Internal.getStarLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getConstantTarget - Returns the fixed target of this indirect
            /// goto, if one exists.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getConstantTarget - Returns the fixed target of this
            /// indirect</para>
            /// <para>  /// goto, if one exists.</para>
            /// </remarks>
            public clang.LabelDecl getConstantTarget()
            {
                var __ret = Internal.getConstantTarget_0(__Instance);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ContinueStmt - This represents a continue.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ContinueStmt - This represents a continue.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ContinueStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal ContinueLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmtC2ENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal CL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ContinueStmt14getContinueLocEv")]
                internal static extern clang.SourceLocation.Internal getContinueLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmt14setContinueLocENS_14SourceLocationE")]
                internal static extern void setContinueLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ContinueStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ContinueStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ContinueStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ContinueStmt __CreateInstance(global::System.IntPtr native)
            {
                return new ContinueStmt((ContinueStmt.Internal*) native);
            }

            public static ContinueStmt __CreateInstance(ContinueStmt.Internal native)
            {
                return new ContinueStmt(native);
            }

            private static ContinueStmt.Internal* __CopyValue(ContinueStmt.Internal native)
            {
                var ret = (ContinueStmt.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private ContinueStmt(ContinueStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ContinueStmt(ContinueStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public ContinueStmt(clang.SourceLocation CL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(CL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (CL.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Build an empty continue statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty continue statement.</para>
            /// </remarks>
            public ContinueStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getContinueLoc()
            {
                var __ret = Internal.getContinueLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setContinueLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setContinueLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>BreakStmt - This represents a break.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BreakStmt - This represents a break.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class BreakStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal BreakLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmtC2ENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal BL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BreakStmt11getBreakLocEv")]
                internal static extern clang.SourceLocation.Internal getBreakLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmt11setBreakLocENS_14SourceLocationE")]
                internal static extern void setBreakLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BreakStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BreakStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BreakStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new BreakStmt __CreateInstance(global::System.IntPtr native)
            {
                return new BreakStmt((BreakStmt.Internal*) native);
            }

            public static BreakStmt __CreateInstance(BreakStmt.Internal native)
            {
                return new BreakStmt(native);
            }

            private static BreakStmt.Internal* __CopyValue(BreakStmt.Internal native)
            {
                var ret = (BreakStmt.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private BreakStmt(BreakStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BreakStmt(BreakStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public BreakStmt(clang.SourceLocation BL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(BL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (BL.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Build an empty break statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty break statement.</para>
            /// </remarks>
            public BreakStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getBreakLoc()
            {
                var __ret = Internal.getBreakLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBreakLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setBreakLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ReturnStmt - This represents a return, optionally of an
        /// expression: return; return 4;</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ReturnStmt - This represents a return, optionally of an
        /// expression:</para>
        /// <para>///   return;</para>
        /// <para>///   return 4;</para>
        /// <para>///</para>
        /// <para>/// Note that GCC allows return with no argument in a function
        /// declared to</para>
        /// <para>/// return a value, and it allows returning a value in functions
        /// declared to</para>
        /// <para>/// return void.  We explicitly model this in the AST, which
        /// means you can't</para>
        /// <para>/// depend on the return type of the function and the presence of
        /// an argument.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ReturnStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public global::System.IntPtr RetExpr;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal RetLoc;

                [FieldOffset(24)]
                public global::System.IntPtr NRVOCandidate;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmtC2ENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal RL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmtC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ReturnStmt12getReturnLocEv")]
                internal static extern clang.SourceLocation.Internal getReturnLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmt12setReturnLocENS_14SourceLocationE")]
                internal static extern void setReturnLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ReturnStmt16getNRVOCandidateEv")]
                internal static extern global::System.IntPtr getNRVOCandidate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmt16setNRVOCandidateEPKNS_7VarDeclE")]
                internal static extern void setNRVOCandidate_0(global::System.IntPtr instance, global::System.IntPtr Var);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ReturnStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ReturnStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ReturnStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ReturnStmt __CreateInstance(global::System.IntPtr native)
            {
                return new ReturnStmt((ReturnStmt.Internal*) native);
            }

            public static ReturnStmt __CreateInstance(ReturnStmt.Internal native)
            {
                return new ReturnStmt(native);
            }

            private static ReturnStmt.Internal* __CopyValue(ReturnStmt.Internal native)
            {
                var ret = (ReturnStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private ReturnStmt(ReturnStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ReturnStmt(ReturnStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public ReturnStmt(clang.SourceLocation RL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(RL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RL.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Build an empty return expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty return expression.</para>
            /// </remarks>
            public ReturnStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_2(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getReturnLoc()
            {
                var __ret = Internal.getReturnLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setReturnLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setReturnLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the variable that might be used for the named return
            /// value optimization.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the variable that might be used for the named
            /// return</para>
            /// <para>  /// value optimization.</para>
            /// <para>  ///</para>
            /// <para>  /// The optimization itself can only be performed if the
            /// variable is</para>
            /// <para>  /// also marked as an NRVO object.</para>
            /// </remarks>
            public clang.VarDecl getNRVOCandidate()
            {
                var __ret = Internal.getNRVOCandidate_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setNRVOCandidate(clang.VarDecl Var)
            {
                var arg0 = ReferenceEquals(Var, null) ? global::System.IntPtr.Zero : Var.__Instance;
                Internal.setNRVOCandidate_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>AsmStmt is the base class for GCCAsmStmt and MSAsmStmt.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AsmStmt is the base class for GCCAsmStmt and
        /// MSAsmStmt.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class AsmStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal AsmLoc;

                [FieldOffset(12)]
                public bool IsSimple;

                [FieldOffset(13)]
                public bool IsVolatile;

                [FieldOffset(16)]
                public uint NumOutputs;

                [FieldOffset(20)]
                public uint NumInputs;

                [FieldOffset(24)]
                public uint NumClobbers;

                [FieldOffset(32)]
                public global::System.IntPtr Exprs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmtC2ENS_4Stmt9StmtClassENS_14SourceLocationEbbjjj")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.SourceLocation.Internal asmloc, bool issimple, bool isvolatile, uint numoutputs, uint numinputs, uint numclobbers);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmtC2ENS_4Stmt9StmtClassENS1_10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt9getAsmLocEv")]
                internal static extern clang.SourceLocation.Internal getAsmLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt9setAsmLocENS_14SourceLocationE")]
                internal static extern void setAsmLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt8isSimpleEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSimple_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt9setSimpleEb")]
                internal static extern void setSimple_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt10isVolatileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt11setVolatileEb")]
                internal static extern void setVolatile_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt13getNumOutputsEv")]
                internal static extern uint getNumOutputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt19getOutputConstraintEj")]
                internal static extern llvm.StringRef.Internal getOutputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt22isOutputPlusConstraintEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOutputPlusConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt18getNumPlusOperandsEv")]
                internal static extern uint getNumPlusOperands_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt12getNumInputsEv")]
                internal static extern uint getNumInputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt18getInputConstraintEj")]
                internal static extern llvm.StringRef.Internal getInputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt14getNumClobbersEv")]
                internal static extern uint getNumClobbers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7AsmStmt10getClobberEj")]
                internal static extern llvm.StringRef.Internal getClobber_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt12begin_inputsEv")]
                internal static extern clang.ExprIterator.Internal begin_inputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt10end_inputsEv")]
                internal static extern clang.ExprIterator.Internal end_inputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt13begin_outputsEv")]
                internal static extern clang.ExprIterator.Internal begin_outputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt11end_outputsEv")]
                internal static extern clang.ExprIterator.Internal end_outputs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7AsmStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new AsmStmt __CreateInstance(global::System.IntPtr native)
            {
                return new AsmStmt((AsmStmt.Internal*) native);
            }

            public static AsmStmt __CreateInstance(AsmStmt.Internal native)
            {
                return new AsmStmt(native);
            }

            private static AsmStmt.Internal* __CopyValue(AsmStmt.Internal native)
            {
                var ret = (AsmStmt.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private AsmStmt(AsmStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AsmStmt(AsmStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected AsmStmt(clang.Stmt.StmtClass SC, clang.SourceLocation asmloc, bool issimple, bool isvolatile, uint numoutputs, uint numinputs, uint numclobbers)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(asmloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (asmloc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, issimple, isvolatile, numoutputs, numinputs, numclobbers);
            }

            /// <summary>
            /// <para>Build an empty inline-assembly statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty inline-assembly statement.</para>
            /// </remarks>
            public AsmStmt(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAsmLoc()
            {
                var __ret = Internal.getAsmLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAsmLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setAsmLoc_0(__Instance, arg0);
            }

            public bool isSimple()
            {
                var __ret = Internal.isSimple_0(__Instance);
                return __ret;
            }

            public void setSimple(bool V)
            {
                Internal.setSimple_0(__Instance, V);
            }

            public bool isVolatile()
            {
                var __ret = Internal.isVolatile_0(__Instance);
                return __ret;
            }

            public void setVolatile(bool V)
            {
                Internal.setVolatile_0(__Instance, V);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public uint getNumOutputs()
            {
                var __ret = Internal.getNumOutputs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getOutputConstraint - Return the constraint string for the
            /// specified output operand. All output constraints are known to be non-empty
            /// (either '=' or '+').</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOutputConstraint - Return the constraint string for the
            /// specified</para>
            /// <para>  /// output operand.  All output constraints are known to be
            /// non-empty (either</para>
            /// <para>  /// '=' or '+').</para>
            /// </remarks>
            public llvm.StringRef getOutputConstraint(uint i)
            {
                var __ret = Internal.getOutputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>isOutputPlusConstraint - Return true if the specified output
            /// constraint is a &quot;+&quot; constraint (which is both an input and an
            /// output) or false if it is an &quot;=&quot; constraint (just an
            /// output).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isOutputPlusConstraint - Return true if the specified output
            /// constraint</para>
            /// <para>  /// is a &quot;+&quot; constraint (which is both an input and
            /// an output) or false if it</para>
            /// <para>  /// is an &quot;=&quot; constraint (just an output).</para>
            /// </remarks>
            public bool isOutputPlusConstraint(uint i)
            {
                var __ret = Internal.isOutputPlusConstraint_0(__Instance, i);
                return __ret;
            }

            /// <summary>
            /// <para>getNumPlusOperands - Return the number of output operands that
            /// have a &quot;+&quot; constraint.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumPlusOperands - Return the number of output operands
            /// that have a &quot;+&quot;</para>
            /// <para>  /// constraint.</para>
            /// </remarks>
            public uint getNumPlusOperands()
            {
                var __ret = Internal.getNumPlusOperands_0(__Instance);
                return __ret;
            }

            public uint getNumInputs()
            {
                var __ret = Internal.getNumInputs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getInputConstraint - Return the specified input constraint.
            /// Unlike output constraints, these can be empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getInputConstraint - Return the specified input constraint.
            /// Unlike output</para>
            /// <para>  /// constraints, these can be empty.</para>
            /// </remarks>
            public llvm.StringRef getInputConstraint(uint i)
            {
                var __ret = Internal.getInputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public uint getNumClobbers()
            {
                var __ret = Internal.getNumClobbers_0(__Instance);
                return __ret;
            }

            public llvm.StringRef getClobber(uint i)
            {
                var __ret = Internal.getClobber_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public clang.ExprIterator begin_inputs()
            {
                var __ret = Internal.begin_inputs_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public clang.ExprIterator end_inputs()
            {
                var __ret = Internal.end_inputs_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public clang.ExprIterator begin_outputs()
            {
                var __ret = Internal.begin_outputs_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public clang.ExprIterator end_outputs()
            {
                var __ret = Internal.end_outputs_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            protected clang.SourceLocation AsmLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->AsmLoc);
                }

                set
                {
                    ((Internal*) __Instance)->AsmLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            protected bool IsSimple
            {
                get
                {
                    return ((Internal*) __Instance)->IsSimple;
                }

                set
                {
                    ((Internal*) __Instance)->IsSimple = value;
                }
            }

            protected bool IsVolatile
            {
                get
                {
                    return ((Internal*) __Instance)->IsVolatile;
                }

                set
                {
                    ((Internal*) __Instance)->IsVolatile = value;
                }
            }

            protected uint NumOutputs
            {
                get
                {
                    return ((Internal*) __Instance)->NumOutputs;
                }

                set
                {
                    ((Internal*) __Instance)->NumOutputs = value;
                }
            }

            protected uint NumInputs
            {
                get
                {
                    return ((Internal*) __Instance)->NumInputs;
                }

                set
                {
                    ((Internal*) __Instance)->NumInputs = value;
                }
            }

            protected uint NumClobbers
            {
                get
                {
                    return ((Internal*) __Instance)->NumClobbers;
                }

                set
                {
                    ((Internal*) __Instance)->NumClobbers = value;
                }
            }

            protected clang.Stmt Exprs
            {
                get
                {
                    clang.Stmt __result0;
                    if (((Internal*) __Instance)->Exprs == IntPtr.Zero) __result0 = null;
                    else if (clang.Stmt.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Exprs))
                        __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[((Internal*) __Instance)->Exprs];
                    else __result0 = clang.Stmt.__CreateInstance(((Internal*) __Instance)->Exprs);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->Exprs = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>This represents a GCC inline-assembly statement extension.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This represents a GCC inline-assembly statement
        /// extension.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class GCCAsmStmt : clang.AsmStmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal AsmLoc;

                [FieldOffset(12)]
                public bool IsSimple;

                [FieldOffset(13)]
                public bool IsVolatile;

                [FieldOffset(16)]
                public uint NumOutputs;

                [FieldOffset(20)]
                public uint NumInputs;

                [FieldOffset(24)]
                public uint NumClobbers;

                [FieldOffset(32)]
                public global::System.IntPtr Exprs;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(48)]
                public global::System.IntPtr AsmStr;

                [FieldOffset(56)]
                public global::System.IntPtr Constraints;

                [FieldOffset(64)]
                public global::System.IntPtr Clobbers;

                [FieldOffset(72)]
                public global::System.IntPtr Names;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10GCCAsmStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10GCCAsmStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10GCCAsmStmt12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt19getOutputIdentifierEj")]
                internal static extern global::System.IntPtr getOutputIdentifier_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt13getOutputNameEj")]
                internal static extern llvm.StringRef.Internal getOutputName_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt19getOutputConstraintEj")]
                internal static extern llvm.StringRef.Internal getOutputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt18getInputIdentifierEj")]
                internal static extern global::System.IntPtr getInputIdentifier_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt12getInputNameEj")]
                internal static extern llvm.StringRef.Internal getInputName_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt18getInputConstraintEj")]
                internal static extern llvm.StringRef.Internal getInputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt15getNamedOperandEN4llvm9StringRefE")]
                internal static extern int getNamedOperand_0(global::System.IntPtr instance, llvm.StringRef.Internal SymbolicName);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt10getClobberEj")]
                internal static extern llvm.StringRef.Internal getClobber_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10GCCAsmStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10GCCAsmStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            /// <summary>
            /// <para>AsmStringPiece - this is part of a decomposed asm string
            /// specification (for use with the AnalyzeAsmString function below). An asm
            /// string is considered to be a concatenation of these parts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// AsmStringPiece - this is part of a decomposed asm string
            /// specification</para>
            /// <para>  /// (for use with the AnalyzeAsmString function below).  An asm
            /// string is</para>
            /// <para>  /// considered to be a concatenation of these parts.</para>
            /// </remarks>
            public unsafe partial class AsmStringPiece : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.GCCAsmStmt.AsmStringPiece.Kind MyKind;

                    [FieldOffset(32)]
                    public uint OperandNo;

                    [FieldOffset(36)]
                    public clang.CharSourceRange.Internal Range;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10GCCAsmStmt14AsmStringPieceC2ERKS1_")]
                    internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10GCCAsmStmt14AsmStringPieceD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10GCCAsmStmt14AsmStringPiece8isStringEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isString_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10GCCAsmStmt14AsmStringPiece9isOperandEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isOperand_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10GCCAsmStmt14AsmStringPiece12getOperandNoEv")]
                    internal static extern uint getOperandNo_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10GCCAsmStmt14AsmStringPiece8getRangeEv")]
                    internal static extern clang.CharSourceRange.Internal getRange_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10GCCAsmStmt14AsmStringPiece11getModifierEv")]
                    internal static extern sbyte getModifier_0(global::System.IntPtr instance);
                }

                public enum Kind : uint
                {
                    String = 0,
                    Operand = 1
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AsmStringPiece> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AsmStringPiece>();

                private readonly bool __ownsNativeInstance;

                public static AsmStringPiece __CreateInstance(global::System.IntPtr native)
                {
                    return new AsmStringPiece((AsmStringPiece.Internal*) native);
                }

                public static AsmStringPiece __CreateInstance(AsmStringPiece.Internal native)
                {
                    return new AsmStringPiece(native);
                }

                private static AsmStringPiece.Internal* __CopyValue(AsmStringPiece.Internal native)
                {
                    var ret = (AsmStringPiece.Internal*) Marshal.AllocHGlobal(48);
                    *ret = native;
                    return ret;
                }

                private AsmStringPiece(AsmStringPiece.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AsmStringPiece(AsmStringPiece.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.GCCAsmStmt.AsmStringPiece __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool isString()
                {
                    var __ret = Internal.isString_0(__Instance);
                    return __ret;
                }

                public bool isOperand()
                {
                    var __ret = Internal.isOperand_0(__Instance);
                    return __ret;
                }

                public uint getOperandNo()
                {
                    var __ret = Internal.getOperandNo_0(__Instance);
                    return __ret;
                }

                public clang.CharSourceRange getRange()
                {
                    var __ret = Internal.getRange_0(__Instance);
                    return clang.CharSourceRange.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>getModifier - Get the modifier for this operand, if present. This
                /// returns '\0' if there was no modifier.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// getModifier - Get the modifier for this operand, if present.
                /// This</para>
                /// <para>    /// returns '\0' if there was no modifier.</para>
                /// </remarks>
                public sbyte getModifier()
                {
                    var __ret = Internal.getModifier_0(__Instance);
                    return __ret;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new GCCAsmStmt __CreateInstance(global::System.IntPtr native)
            {
                return new GCCAsmStmt((GCCAsmStmt.Internal*) native);
            }

            public static GCCAsmStmt __CreateInstance(GCCAsmStmt.Internal native)
            {
                return new GCCAsmStmt(native);
            }

            private static GCCAsmStmt.Internal* __CopyValue(GCCAsmStmt.Internal native)
            {
                var ret = (GCCAsmStmt.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private GCCAsmStmt(GCCAsmStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected GCCAsmStmt(GCCAsmStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.AsmStmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty inline-assembly statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty inline-assembly statement.</para>
            /// </remarks>
            public GCCAsmStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(80);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.IdentifierInfo getOutputIdentifier(uint i)
            {
                var __ret = Internal.getOutputIdentifier_0(__Instance, i);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public llvm.StringRef getOutputName(uint i)
            {
                var __ret = Internal.getOutputName_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public llvm.StringRef getOutputConstraint(uint i)
            {
                var __ret = Internal.getOutputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public clang.IdentifierInfo getInputIdentifier(uint i)
            {
                var __ret = Internal.getInputIdentifier_0(__Instance, i);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public llvm.StringRef getInputName(uint i)
            {
                var __ret = Internal.getInputName_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public llvm.StringRef getInputConstraint(uint i)
            {
                var __ret = Internal.getInputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getNamedOperand - Given a symbolic operand reference like %[foo],
            /// translate this into a numeric value needed to reference the same operand.
            /// This returns -1 if the operand name is invalid.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNamedOperand - Given a symbolic operand reference like
            /// %[foo],</para>
            /// <para>  /// translate this into a numeric value needed to reference the
            /// same operand.</para>
            /// <para>  /// This returns -1 if the operand name is invalid.</para>
            /// </remarks>
            public int getNamedOperand(llvm.StringRef SymbolicName)
            {
                var arg0 = ReferenceEquals(SymbolicName, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (SymbolicName.__Instance);
                var __ret = Internal.getNamedOperand_0(__Instance, arg0);
                return __ret;
            }

            public llvm.StringRef getClobber(uint i)
            {
                var __ret = Internal.getClobber_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This represents a Microsoft inline-assembly statement
        /// extension.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This represents a Microsoft inline-assembly statement
        /// extension.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class MSAsmStmt : clang.AsmStmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 96)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal AsmLoc;

                [FieldOffset(12)]
                public bool IsSimple;

                [FieldOffset(13)]
                public bool IsVolatile;

                [FieldOffset(16)]
                public uint NumOutputs;

                [FieldOffset(20)]
                public uint NumInputs;

                [FieldOffset(24)]
                public uint NumClobbers;

                [FieldOffset(32)]
                public global::System.IntPtr Exprs;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal LBraceLoc;

                [FieldOffset(44)]
                public clang.SourceLocation.Internal EndLoc;

                [FieldOffset(48)]
                public llvm.StringRef.Internal AsmStr;

                [FieldOffset(64)]
                public uint NumAsmToks;

                [FieldOffset(72)]
                public global::System.IntPtr AsmToks;

                [FieldOffset(80)]
                public global::System.IntPtr Constraints;

                [FieldOffset(88)]
                public global::System.IntPtr Clobbers;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt12getLBraceLocEv")]
                internal static extern clang.SourceLocation.Internal getLBraceLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmt12setLBraceLocENS_14SourceLocationE")]
                internal static extern void setLBraceLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmt9setEndLocENS_14SourceLocationE")]
                internal static extern void setEndLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt9hasBracesEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasBraces_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmt13getNumAsmToksEv")]
                internal static extern uint getNumAsmToks_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt12getAsmStringEv")]
                internal static extern llvm.StringRef.Internal getAsmString_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt19getOutputConstraintEj")]
                internal static extern llvm.StringRef.Internal getOutputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt18getInputConstraintEj")]
                internal static extern llvm.StringRef.Internal getInputConstraint_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt10getClobberEj")]
                internal static extern llvm.StringRef.Internal getClobber_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9MSAsmStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9MSAsmStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new MSAsmStmt __CreateInstance(global::System.IntPtr native)
            {
                return new MSAsmStmt((MSAsmStmt.Internal*) native);
            }

            public static MSAsmStmt __CreateInstance(MSAsmStmt.Internal native)
            {
                return new MSAsmStmt(native);
            }

            private static MSAsmStmt.Internal* __CopyValue(MSAsmStmt.Internal native)
            {
                var ret = (MSAsmStmt.Internal*) Marshal.AllocHGlobal(96);
                *ret = native;
                return ret;
            }

            private MSAsmStmt(MSAsmStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected MSAsmStmt(MSAsmStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.AsmStmt.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty MS-style inline-assembly statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty MS-style inline-assembly
            /// statement.</para>
            /// </remarks>
            public MSAsmStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(96);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLBraceLoc()
            {
                var __ret = Internal.getLBraceLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLBraceLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLBraceLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setEndLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setEndLoc_0(__Instance, arg0);
            }

            public bool hasBraces()
            {
                var __ret = Internal.hasBraces_0(__Instance);
                return __ret;
            }

            public uint getNumAsmToks()
            {
                var __ret = Internal.getNumAsmToks_0(__Instance);
                return __ret;
            }

            public llvm.StringRef getAsmString()
            {
                var __ret = Internal.getAsmString_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public llvm.StringRef getOutputConstraint(uint i)
            {
                var __ret = Internal.getOutputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public llvm.StringRef getInputConstraint(uint i)
            {
                var __ret = Internal.getInputConstraint_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public llvm.StringRef getClobber(uint i)
            {
                var __ret = Internal.getClobber_0(__Instance, i);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class SEHExceptStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(16)]
                public fixed global::System.IntPtr Children[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SEHExceptStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SEHExceptStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SEHExceptStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SEHExceptStmt12getExceptLocEv")]
                internal static extern clang.SourceLocation.Internal getExceptLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SEHExceptStmt9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SEHExceptStmt8getBlockEv")]
                internal static extern global::System.IntPtr getBlock_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SEHExceptStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SEHExceptStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SEHExceptStmt __CreateInstance(global::System.IntPtr native)
            {
                return new SEHExceptStmt((SEHExceptStmt.Internal*) native);
            }

            public static SEHExceptStmt __CreateInstance(SEHExceptStmt.Internal native)
            {
                return new SEHExceptStmt(native);
            }

            private static SEHExceptStmt.Internal* __CopyValue(SEHExceptStmt.Internal native)
            {
                var ret = (SEHExceptStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private SEHExceptStmt(SEHExceptStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SEHExceptStmt(SEHExceptStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getExceptLoc()
            {
                var __ret = Internal.getExceptLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.CompoundStmt getBlock()
            {
                var __ret = Internal.getBlock_0(__Instance);
                clang.CompoundStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CompoundStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CompoundStmt) clang.CompoundStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CompoundStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class SEHFinallyStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(16)]
                public global::System.IntPtr Block;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SEHFinallyStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SEHFinallyStmt6CreateERKNS_10ASTContextENS_14SourceLocationEPNS_4StmtE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, clang.SourceLocation.Internal FinallyLoc, global::System.IntPtr Block);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SEHFinallyStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SEHFinallyStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SEHFinallyStmt13getFinallyLocEv")]
                internal static extern clang.SourceLocation.Internal getFinallyLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SEHFinallyStmt9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SEHFinallyStmt8getBlockEv")]
                internal static extern global::System.IntPtr getBlock_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SEHFinallyStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SEHFinallyStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SEHFinallyStmt __CreateInstance(global::System.IntPtr native)
            {
                return new SEHFinallyStmt((SEHFinallyStmt.Internal*) native);
            }

            public static SEHFinallyStmt __CreateInstance(SEHFinallyStmt.Internal native)
            {
                return new SEHFinallyStmt(native);
            }

            private static SEHFinallyStmt.Internal* __CopyValue(SEHFinallyStmt.Internal native)
            {
                var ret = (SEHFinallyStmt.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private SEHFinallyStmt(SEHFinallyStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SEHFinallyStmt(SEHFinallyStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getFinallyLoc()
            {
                var __ret = Internal.getFinallyLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.CompoundStmt getBlock()
            {
                var __ret = Internal.getBlock_0(__Instance);
                clang.CompoundStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CompoundStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CompoundStmt) clang.CompoundStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CompoundStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static clang.SEHFinallyStmt Create(clang.ASTContext C, clang.SourceLocation FinallyLoc, clang.Stmt Block)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(FinallyLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (FinallyLoc.__Instance);
                var arg2 = ReferenceEquals(Block, null) ? global::System.IntPtr.Zero : Block.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2);
                clang.SEHFinallyStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SEHFinallyStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SEHFinallyStmt) clang.SEHFinallyStmt.NativeToManagedMap[__ret];
                else __result0 = clang.SEHFinallyStmt.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class SEHTryStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public bool IsCXXTry;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal TryLoc;

                [FieldOffset(16)]
                public fixed global::System.IntPtr Children[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SEHTryStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SEHTryStmt6CreateERKNS_10ASTContextEbNS_14SourceLocationEPNS_4StmtES6_")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, bool isCXXTry, clang.SourceLocation.Internal TryLoc, global::System.IntPtr TryBlock, global::System.IntPtr Handler);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt9getTryLocEv")]
                internal static extern clang.SourceLocation.Internal getTryLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt11getIsCXXTryEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getIsCXXTry_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt11getTryBlockEv")]
                internal static extern global::System.IntPtr getTryBlock_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt10getHandlerEv")]
                internal static extern global::System.IntPtr getHandler_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt16getExceptHandlerEv")]
                internal static extern global::System.IntPtr getExceptHandler_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10SEHTryStmt17getFinallyHandlerEv")]
                internal static extern global::System.IntPtr getFinallyHandler_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SEHTryStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10SEHTryStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SEHTryStmt __CreateInstance(global::System.IntPtr native)
            {
                return new SEHTryStmt((SEHTryStmt.Internal*) native);
            }

            public static SEHTryStmt __CreateInstance(SEHTryStmt.Internal native)
            {
                return new SEHTryStmt(native);
            }

            private static SEHTryStmt.Internal* __CopyValue(SEHTryStmt.Internal native)
            {
                var ret = (SEHTryStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private SEHTryStmt(SEHTryStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SEHTryStmt(SEHTryStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTryLoc()
            {
                var __ret = Internal.getTryLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public bool getIsCXXTry()
            {
                var __ret = Internal.getIsCXXTry_0(__Instance);
                return __ret;
            }

            public clang.CompoundStmt getTryBlock()
            {
                var __ret = Internal.getTryBlock_0(__Instance);
                clang.CompoundStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CompoundStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CompoundStmt) clang.CompoundStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CompoundStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt getHandler()
            {
                var __ret = Internal.getHandler_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns 0 if not defined</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns 0 if not defined</para>
            /// </remarks>
            public clang.SEHExceptStmt getExceptHandler()
            {
                var __ret = Internal.getExceptHandler_0(__Instance);
                clang.SEHExceptStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SEHExceptStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SEHExceptStmt) clang.SEHExceptStmt.NativeToManagedMap[__ret];
                else __result0 = clang.SEHExceptStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SEHFinallyStmt getFinallyHandler()
            {
                var __ret = Internal.getFinallyHandler_0(__Instance);
                clang.SEHFinallyStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SEHFinallyStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SEHFinallyStmt) clang.SEHFinallyStmt.NativeToManagedMap[__ret];
                else __result0 = clang.SEHFinallyStmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static clang.SEHTryStmt Create(clang.ASTContext C, bool isCXXTry, clang.SourceLocation TryLoc, clang.Stmt TryBlock, clang.Stmt Handler)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg2 = ReferenceEquals(TryLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TryLoc.__Instance);
                var arg3 = ReferenceEquals(TryBlock, null) ? global::System.IntPtr.Zero : TryBlock.__Instance;
                var arg4 = ReferenceEquals(Handler, null) ? global::System.IntPtr.Zero : Handler.__Instance;
                var __ret = Internal.Create_0(arg0, isCXXTry, arg2, arg3, arg4);
                clang.SEHTryStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SEHTryStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SEHTryStmt) clang.SEHTryStmt.NativeToManagedMap[__ret];
                else __result0 = clang.SEHTryStmt.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a __leave statement.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Represents a __leave statement.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class SEHLeaveStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal LeaveLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmtC2ENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal LL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmtC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12SEHLeaveStmt11getLeaveLocEv")]
                internal static extern clang.SourceLocation.Internal getLeaveLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmt11setLeaveLocENS_14SourceLocationE")]
                internal static extern void setLeaveLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12SEHLeaveStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12SEHLeaveStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12SEHLeaveStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new SEHLeaveStmt __CreateInstance(global::System.IntPtr native)
            {
                return new SEHLeaveStmt((SEHLeaveStmt.Internal*) native);
            }

            public static SEHLeaveStmt __CreateInstance(SEHLeaveStmt.Internal native)
            {
                return new SEHLeaveStmt(native);
            }

            private static SEHLeaveStmt.Internal* __CopyValue(SEHLeaveStmt.Internal native)
            {
                var ret = (SEHLeaveStmt.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private SEHLeaveStmt(SEHLeaveStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SEHLeaveStmt(SEHLeaveStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            public SEHLeaveStmt(clang.SourceLocation LL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(LL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LL.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Build an empty __leave statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty __leave statement.</para>
            /// </remarks>
            public SEHLeaveStmt(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLeaveLoc()
            {
                var __ret = Internal.getLeaveLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLeaveLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLeaveLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This captures a statement into a function. For example, the
        /// following pragma annotated compound statement can be represented as a
        /// CapturedStmt, and this compound statement is the body of an anonymous
        /// outlined function.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief This captures a statement into a function. For
        /// example, the following</para>
        /// <para>/// pragma annotated compound statement can be represented as a
        /// CapturedStmt,</para>
        /// <para>/// and this compound statement is the body of an anonymous
        /// outlined function.</para>
        /// <para>/// @code</para>
        /// <para>/// #pragma omp parallel</para>
        /// <para>/// {</para>
        /// <para>///   compute();</para>
        /// <para>/// }</para>
        /// <para>/// @endcode</para>
        /// </remarks>
        public unsafe partial class CapturedStmt : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public uint NumCaptures;

                [FieldOffset(16)]
                internal llvm.PointerIntPair.Internal CapDeclAndKind;

                [FieldOffset(24)]
                public global::System.IntPtr TheRecordDecl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt18CreateDeserializedERKNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr Context, uint NumCaptures);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt15getCapturedStmtEv")]
                internal static extern global::System.IntPtr getCapturedStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt15getCapturedDeclEv")]
                internal static extern global::System.IntPtr getCapturedDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt15setCapturedDeclEPNS_12CapturedDeclE")]
                internal static extern void setCapturedDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt21getCapturedRegionKindEv")]
                internal static extern clang.CapturedRegionKind getCapturedRegionKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt21setCapturedRegionKindENS_18CapturedRegionKindE")]
                internal static extern void setCapturedRegionKind_0(global::System.IntPtr instance, clang.CapturedRegionKind Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt21getCapturedRecordDeclEv")]
                internal static extern global::System.IntPtr getCapturedRecordDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt21setCapturedRecordDeclEPNS_10RecordDeclE")]
                internal static extern void setCapturedRecordDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt16capturesVariableEPKNS_7VarDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool capturesVariable_0(global::System.IntPtr instance, global::System.IntPtr Var);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt13capture_beginEv")]
                internal static extern global::System.IntPtr capture_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt11capture_endEv")]
                internal static extern global::System.IntPtr capture_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt12capture_sizeEv")]
                internal static extern uint capture_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedStmt14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedStmt8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            /// <summary>
            /// <para>The different capture forms: by 'this', by reference, capture for
            /// variable-length array type etc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The different capture forms: by 'this', by reference,
            /// capture for</para>
            /// <para>  /// variable-length array type etc.</para>
            /// </remarks>
            public enum VariableCaptureKind : uint
            {
                VCK_This = 0,
                VCK_ByRef = 1,
                VCK_VLAType = 2
            }

            /// <summary>
            /// <para>An iterator that walks over the captures.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief An iterator that walks over the captures.</para>
            /// </remarks>
            public class capture_iterator { }

            public class const_capture_iterator { }

            /// <summary>
            /// <para>Describes the capture of either a variable, or 'this', or
            /// variable-length array type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Describes the capture of either a variable, or 'this',
            /// or</para>
            /// <para>  /// variable-length array type.</para>
            /// </remarks>
            public unsafe partial class Capture : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.PointerIntPair.Internal VarAndKind;

                    [FieldOffset(8)]
                    public clang.SourceLocation.Internal Loc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12CapturedStmt7CaptureC2ENS_14SourceLocationENS0_19VariableCaptureKindEPNS_7VarDeclE")]
                    internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.CapturedStmt.VariableCaptureKind Kind, global::System.IntPtr Var);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12CapturedStmt7CaptureC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture14getCaptureKindEv")]
                    internal static extern clang.CapturedStmt.VariableCaptureKind getCaptureKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture11getLocationEv")]
                    internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture12capturesThisEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool capturesThis_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture16capturesVariableEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool capturesVariable_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture25capturesVariableArrayTypeEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool capturesVariableArrayType_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12CapturedStmt7Capture14getCapturedVarEv")]
                    internal static extern global::System.IntPtr getCapturedVar_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Capture> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Capture>();

                private readonly bool __ownsNativeInstance;

                public static Capture __CreateInstance(global::System.IntPtr native)
                {
                    return new Capture((Capture.Internal*) native);
                }

                public static Capture __CreateInstance(Capture.Internal native)
                {
                    return new Capture(native);
                }

                private static Capture.Internal* __CopyValue(Capture.Internal native)
                {
                    var ret = (Capture.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private Capture(Capture.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Capture(Capture.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                /// <summary>
                /// <para>Create a new capture.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Create a new capture.</para>
                /// <para>    ///</para>
                /// <para>    /// \param Loc The source location associated with this
                /// capture.</para>
                /// <para>    ///</para>
                /// <para>    /// \param Kind The kind of capture (this, ByRef,
                /// ...).</para>
                /// <para>    ///</para>
                /// <para>    /// \param Var The variable being captured, or null if
                /// capturing this.</para>
                /// <para>    ///</para>
                /// </remarks>
                public Capture(clang.SourceLocation Loc, clang.CapturedStmt.VariableCaptureKind Kind, clang.VarDecl Var)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                    var arg1 = Kind;
                    var arg2 = ReferenceEquals(Var, null) ? global::System.IntPtr.Zero : Var.__Instance;
                    Internal.ctor_0(__Instance, arg0, arg1, arg2);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.CapturedStmt.Capture __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Determine the kind of capture.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine the kind of capture.</para>
                /// </remarks>
                public clang.CapturedStmt.VariableCaptureKind getCaptureKind()
                {
                    var __ret = Internal.getCaptureKind_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Retrieve the source location at which the variable or 'this' was
                /// first used.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Retrieve the source location at which the variable or
                /// 'this' was</para>
                /// <para>    /// first used.</para>
                /// </remarks>
                public clang.SourceLocation getLocation()
                {
                    var __ret = Internal.getLocation_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Determine whether this capture handles the C++ 'this'
                /// pointer.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine whether this capture handles the C++ 'this'
                /// pointer.</para>
                /// </remarks>
                public bool capturesThis()
                {
                    var __ret = Internal.capturesThis_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Determine whether this capture handles a variable.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine whether this capture handles a
                /// variable.</para>
                /// </remarks>
                public bool capturesVariable()
                {
                    var __ret = Internal.capturesVariable_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Determine whether this capture handles a variable-length array
                /// type.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine whether this capture handles a
                /// variable-length array</para>
                /// <para>    /// type.</para>
                /// </remarks>
                public bool capturesVariableArrayType()
                {
                    var __ret = Internal.capturesVariableArrayType_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Retrieve the declaration of the variable being captured.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Retrieve the declaration of the variable being
                /// captured.</para>
                /// <para>    ///</para>
                /// <para>    /// This operation is only valid if this capture captures a
                /// variable.</para>
                /// </remarks>
                public clang.VarDecl getCapturedVar()
                {
                    var __ret = Internal.getCapturedVar_0(__Instance);
                    clang.VarDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                    else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                    return __result0;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new CapturedStmt __CreateInstance(global::System.IntPtr native)
            {
                return new CapturedStmt((CapturedStmt.Internal*) native);
            }

            public static CapturedStmt __CreateInstance(CapturedStmt.Internal native)
            {
                return new CapturedStmt(native);
            }

            private static CapturedStmt.Internal* __CopyValue(CapturedStmt.Internal native)
            {
                var ret = (CapturedStmt.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private CapturedStmt(CapturedStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CapturedStmt(CapturedStmt.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the statement being captured.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the statement being captured.</para>
            /// </remarks>
            public clang.Stmt getCapturedStmt()
            {
                var __ret = Internal.getCapturedStmt_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the outlined function declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the outlined function declaration.</para>
            /// </remarks>
            public clang.CapturedDecl getCapturedDecl()
            {
                var __ret = Internal.getCapturedDecl_0(__Instance);
                clang.CapturedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedDecl) clang.CapturedDecl.NativeToManagedMap[__ret];
                else clang.CapturedDecl.NativeToManagedMap[__ret] = __result0 = (clang.CapturedDecl) clang.CapturedDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set the outlined function declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the outlined function declaration.</para>
            /// </remarks>
            public void setCapturedDecl(clang.CapturedDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setCapturedDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the captured region kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the captured region kind.</para>
            /// </remarks>
            public clang.CapturedRegionKind getCapturedRegionKind()
            {
                var __ret = Internal.getCapturedRegionKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set the captured region kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the captured region kind.</para>
            /// </remarks>
            public void setCapturedRegionKind(clang.CapturedRegionKind Kind)
            {
                var arg0 = Kind;
                Internal.setCapturedRegionKind_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the record declaration for captured variables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the record declaration for captured
            /// variables.</para>
            /// </remarks>
            public clang.RecordDecl getCapturedRecordDecl()
            {
                var __ret = Internal.getCapturedRecordDecl_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set the record declaration for captured variables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the record declaration for captured
            /// variables.</para>
            /// </remarks>
            public void setCapturedRecordDecl(clang.RecordDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setCapturedRecordDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>True if this variable has been captured.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if this variable has been captured.</para>
            /// </remarks>
            public bool capturesVariable(clang.VarDecl Var)
            {
                var arg0 = ReferenceEquals(Var, null) ? global::System.IntPtr.Zero : Var.__Instance;
                var __ret = Internal.capturesVariable_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve an iterator pointing to the first capture.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an iterator pointing to the first
            /// capture.</para>
            /// </remarks>
            public clang.CapturedStmt.Capture capture_begin()
            {
                var __ret = Internal.capture_begin_0(__Instance);
                clang.CapturedStmt.Capture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedStmt.Capture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedStmt.Capture) clang.CapturedStmt.Capture.NativeToManagedMap[__ret];
                else __result0 = clang.CapturedStmt.Capture.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve an iterator pointing past the end of the sequence of
            /// captures.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an iterator pointing past the end of the
            /// sequence of</para>
            /// <para>  /// captures.</para>
            /// </remarks>
            public clang.CapturedStmt.Capture capture_end()
            {
                var __ret = Internal.capture_end_0(__Instance);
                clang.CapturedStmt.Capture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedStmt.Capture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedStmt.Capture) clang.CapturedStmt.Capture.NativeToManagedMap[__ret];
                else __result0 = clang.CapturedStmt.Capture.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the number of captures, including 'this'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the number of captures, including
            /// 'this'.</para>
            /// </remarks>
            public uint capture_size()
            {
                var __ret = Internal.capture_size_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static clang.CapturedStmt CreateDeserialized(clang.ASTContext Context, uint NumCaptures)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, NumCaptures);
                clang.CapturedStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedStmt) clang.CapturedStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CapturedStmt.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }
    }

    namespace llvm
    {
    }
}
