//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class APInt
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        /// <summary>
        /// <para>Class for arbitrary precision integers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Class for arbitrary precision integers.</para>
        /// <para>///</para>
        /// <para>/// APInt is a functional replacement for common case unsigned
        /// integer type like</para>
        /// <para>/// &quot;unsigned&quot;, &quot;unsigned long&quot; or
        /// &quot;uint64_t&quot;, but also allows non-byte-width</para>
        /// <para>/// integer sizes and large integer value types such as 3-bits,
        /// 15-bits, or more</para>
        /// <para>/// than 64-bits of precision. APInt provides a variety of
        /// arithmetic operators</para>
        /// <para>/// and methods to manipulate integer values of any bit-width. It
        /// supports both</para>
        /// <para>/// the typical integer arithmetic and comparison operations as
        /// well as bitwise</para>
        /// <para>/// manipulation.</para>
        /// <para>///</para>
        /// <para>/// The class has several invariants worth noting:</para>
        /// <para>///   * All bit, byte, and word positions are zero-based.</para>
        /// <para>///   * Once the bit width is set, it doesn't change except by
        /// the Truncate,</para>
        /// <para>///     SignExtend, or ZeroExtend operations.</para>
        /// <para>///   * All binary operators must be on APInt instances of the
        /// same bit width.</para>
        /// <para>///     Attempting to use these operators on instances with
        /// different bit</para>
        /// <para>///     widths will yield an assertion.</para>
        /// <para>///   * The value is stored canonically as an unsigned value. For
        /// operations</para>
        /// <para>///     where it makes a difference, there are both signed and
        /// unsigned variants</para>
        /// <para>///     of the operation. For example, sdiv and udiv. However,
        /// because the bit</para>
        /// <para>///     widths must be the same, operations such as Mul and Add
        /// produce the same</para>
        /// <para>///     results regardless of whether the values are interpreted
        /// as signed or</para>
        /// <para>///     not.</para>
        /// <para>///   * In general, the class tries to follow the style of
        /// computation that LLVM</para>
        /// <para>///     uses in its IR. This simplifies its use for LLVM.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class APInt : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint BitWidth;

                [FieldOffset(8)]
                internal llvm.APInt._.Internal _0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntC2Ejyb")]
                internal static extern void ctor_1(global::System.IntPtr instance, uint numBits, ulong val, bool isSigned);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntC2EjNS_9StringRefEh")]
                internal static extern void ctor_4(global::System.IntPtr instance, uint numBits, llvm.StringRef.Internal str, byte radix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntC2ERKS0_")]
                internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr that);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntC2Ev")]
                internal static extern void ctor_7(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12needsCleanupEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool needsCleanup_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7ProfileERNS_16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10isNegativeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNegative_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt13isNonNegativeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNonNegative_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt18isStrictlyPositiveEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStrictlyPositive_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt14isAllOnesValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAllOnesValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10isMaxValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMaxValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt16isMaxSignedValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMaxSignedValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10isMinValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMinValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt16isMinSignedValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMinSignedValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt6isIntNEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntN_0(global::System.IntPtr instance, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12isSignedIntNEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignedIntN_0(global::System.IntPtr instance, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10isPowerOf2Ev")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPowerOf2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt9isSignBitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignBit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12getBoolValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getBoolValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt15getLimitedValueEy")]
                internal static extern ulong getLimitedValue_0(global::System.IntPtr instance, ulong Limit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11getMaxValueEj")]
                internal static extern void getMaxValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt17getSignedMaxValueEj")]
                internal static extern void getSignedMaxValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11getMinValueEj")]
                internal static extern void getMinValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt17getSignedMinValueEj")]
                internal static extern void getSignedMinValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10getSignBitEj")]
                internal static extern void getSignBit_0(global::System.IntPtr @return, uint BitWidth);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt15getAllOnesValueEj")]
                internal static extern void getAllOnesValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12getNullValueEj")]
                internal static extern void getNullValue_0(global::System.IntPtr @return, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt9getHiBitsEj")]
                internal static extern void getHiBits_0(global::System.IntPtr @return, global::System.IntPtr instance, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt9getLoBitsEj")]
                internal static extern void getLoBits_0(global::System.IntPtr @return, global::System.IntPtr instance, uint numBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12getOneBitSetEjj")]
                internal static extern void getOneBitSet_0(global::System.IntPtr @return, uint numBits, uint BitNo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10getBitsSetEjjj")]
                internal static extern void getBitsSet_0(global::System.IntPtr @return, uint numBits, uint loBit, uint hiBit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt14getHighBitsSetEjj")]
                internal static extern void getHighBitsSet_0(global::System.IntPtr @return, uint numBits, uint hiBitsSet);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt13getLowBitsSetEjj")]
                internal static extern void getLowBitsSet_0(global::System.IntPtr @return, uint numBits, uint loBitsSet);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8getSplatEjRKS0_")]
                internal static extern void getSplat_0(global::System.IntPtr @return, uint NewLen, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11isSameValueERKS0_S2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSameValue_0(global::System.IntPtr I1, global::System.IntPtr I2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10getRawDataEv")]
                internal static extern ulong* getRawData_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APIntmmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntcoEv")]
                internal static extern void OperatorTilde_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntngEv")]
                internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntntEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaim_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntanERKS0_")]
                internal static extern void OperatorAmp_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3AndERKS0_")]
                internal static extern void And_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntorERKS0_")]
                internal static extern void OperatorPipe_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt2OrERKS0_")]
                internal static extern void Or_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInteoERKS0_")]
                internal static extern void OperatorCaret_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3XorERKS0_")]
                internal static extern void Xor_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntmlERKS0_")]
                internal static extern void OperatorStar_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntplERKS0_")]
                internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntplEy")]
                internal static extern void OperatorPlus_1(global::System.IntPtr @return, global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntmiERKS0_")]
                internal static extern void OperatorMinus_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntmiEy")]
                internal static extern void OperatorMinus_2(global::System.IntPtr @return, global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4ashrEj")]
                internal static extern void ashr_0(global::System.IntPtr @return, global::System.IntPtr instance, uint shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4lshrEj")]
                internal static extern void lshr_0(global::System.IntPtr @return, global::System.IntPtr instance, uint shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3shlEj")]
                internal static extern void shl_0(global::System.IntPtr @return, global::System.IntPtr instance, uint shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4rotlEj")]
                internal static extern void rotl_0(global::System.IntPtr @return, global::System.IntPtr instance, uint rotateAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4rotrEj")]
                internal static extern void rotr_0(global::System.IntPtr @return, global::System.IntPtr instance, uint rotateAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4ashrERKS0_")]
                internal static extern void ashr_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4lshrERKS0_")]
                internal static extern void lshr_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3shlERKS0_")]
                internal static extern void shl_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr shiftAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4rotlERKS0_")]
                internal static extern void rotl_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr rotateAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4rotrERKS0_")]
                internal static extern void rotr_1(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr rotateAmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4udivERKS0_")]
                internal static extern void udiv_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4sdivERKS0_")]
                internal static extern void sdiv_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4uremERKS0_")]
                internal static extern void urem_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4sremERKS0_")]
                internal static extern void srem_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt7udivremERKS0_S2_RS0_S3_")]
                internal static extern void udivrem_0(global::System.IntPtr LHS, global::System.IntPtr RHS, global::System.IntPtr Quotient, global::System.IntPtr Remainder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt7sdivremERKS0_S2_RS0_S3_")]
                internal static extern void sdivrem_0(global::System.IntPtr LHS, global::System.IntPtr RHS, global::System.IntPtr Quotient, global::System.IntPtr Remainder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7sadd_ovERKS0_Rb")]
                internal static extern void sadd_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7uadd_ovERKS0_Rb")]
                internal static extern void uadd_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7ssub_ovERKS0_Rb")]
                internal static extern void ssub_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7usub_ovERKS0_Rb")]
                internal static extern void usub_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7sdiv_ovERKS0_Rb")]
                internal static extern void sdiv_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7smul_ovERKS0_Rb")]
                internal static extern void smul_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7umul_ovERKS0_Rb")]
                internal static extern void umul_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7sshl_ovERKS0_Rb")]
                internal static extern void sshl_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Amt, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt7ushl_ovERKS0_Rb")]
                internal static extern void ushl_ov_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Amt, bool* Overflow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInteqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInteqEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_1(global::System.IntPtr instance, ulong Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt2eqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool eq_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntneEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_1(global::System.IntPtr instance, ulong Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt2neERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ne_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ultERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ult_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ultEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ult_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sltERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool slt_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sltEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool slt_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3uleERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ule_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3uleEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ule_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sleERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sle_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sleEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sle_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ugtERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ugt_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ugtEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ugt_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sgtERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sgt_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sgtEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sgt_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ugeERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool uge_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3ugeEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool uge_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sgeERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sge_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3sgeEy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool sge_1(global::System.IntPtr instance, ulong RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10intersectsERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool intersects_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt5truncEj")]
                internal static extern void trunc_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4sextEj")]
                internal static extern void sext_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4zextEj")]
                internal static extern void zext_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt11sextOrTruncEj")]
                internal static extern void sextOrTrunc_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt11zextOrTruncEj")]
                internal static extern void zextOrTrunc_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10sextOrSelfEj")]
                internal static extern void sextOrSelf_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt10zextOrSelfEj")]
                internal static extern void zextOrSelf_0(global::System.IntPtr @return, global::System.IntPtr instance, uint width);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10setAllBitsEv")]
                internal static extern void setAllBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt6setBitEj")]
                internal static extern void setBit_0(global::System.IntPtr instance, uint bitPosition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12clearAllBitsEv")]
                internal static extern void clearAllBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8clearBitEj")]
                internal static extern void clearBit_0(global::System.IntPtr instance, uint bitPosition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11flipAllBitsEv")]
                internal static extern void flipAllBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt7flipBitEj")]
                internal static extern void flipBit_0(global::System.IntPtr instance, uint bitPosition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt11getBitWidthEv")]
                internal static extern uint getBitWidth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt11getNumWordsEv")]
                internal static extern uint getNumWords_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11getNumWordsEj")]
                internal static extern uint getNumWords_1(uint BitWidth);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt13getActiveBitsEv")]
                internal static extern uint getActiveBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt14getActiveWordsEv")]
                internal static extern uint getActiveWords_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt16getMinSignedBitsEv")]
                internal static extern uint getMinSignedBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12getZExtValueEv")]
                internal static extern ulong getZExtValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12getSExtValueEv")]
                internal static extern long getSExtValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt13getBitsNeededENS_9StringRefEh")]
                internal static extern uint getBitsNeeded_0(llvm.StringRef.Internal str, byte radix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt17countLeadingZerosEv")]
                internal static extern uint countLeadingZeros_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt16countLeadingOnesEv")]
                internal static extern uint countLeadingOnes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt14getNumSignBitsEv")]
                internal static extern uint getNumSignBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt18countTrailingZerosEv")]
                internal static extern uint countTrailingZeros_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt17countTrailingOnesEv")]
                internal static extern uint countTrailingOnes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt15countPopulationEv")]
                internal static extern uint countPopulation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt5printERNS_11raw_ostreamEb")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, bool isSigned);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt8byteSwapEv")]
                internal static extern void byteSwap_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt13roundToDoubleEb")]
                internal static extern double roundToDouble_0(global::System.IntPtr instance, bool isSigned);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt13roundToDoubleEv")]
                internal static extern double roundToDouble_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt19signedRoundToDoubleEv")]
                internal static extern double signedRoundToDouble_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12bitsToDoubleEv")]
                internal static extern double bitsToDouble_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt11bitsToFloatEv")]
                internal static extern float bitsToFloat_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12doubleToBitsEd")]
                internal static extern void doubleToBits_0(global::System.IntPtr @return, double V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11floatToBitsEf")]
                internal static extern void floatToBits_0(global::System.IntPtr @return, float V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt8logBase2Ev")]
                internal static extern uint logBase2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt12ceilLogBase2Ev")]
                internal static extern uint ceilLogBase2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt15nearestLogBase2Ev")]
                internal static extern uint nearestLogBase2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt13exactLogBase2Ev")]
                internal static extern int exactLogBase2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4sqrtEv")]
                internal static extern void sqrt_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt3absEv")]
                internal static extern void abs_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt21multiplicativeInverseERKS0_")]
                internal static extern void multiplicativeInverse_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr modulo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt5magicEv")]
                internal static extern void magic_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt6magicuEj")]
                internal static extern void magicu_0(global::System.IntPtr @return, global::System.IntPtr instance, uint LeadingZeros);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcSetEPyyj")]
                internal static extern void tcSet_0(ulong* _0, ulong _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8tcAssignEPyPKyj")]
                internal static extern void tcAssign_0(ulong* _0, ulong* _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8tcIsZeroEPKyj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool tcIsZero_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12tcExtractBitEPKyj")]
                internal static extern int tcExtractBit_0(ulong* _0, uint bit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt9tcExtractEPyjPKyjj")]
                internal static extern void tcExtract_0(ulong* _0, uint dstCount, ulong* _1, uint srcBits, uint srcLSB);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8tcSetBitEPyj")]
                internal static extern void tcSetBit_0(ulong* _0, uint bit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10tcClearBitEPyj")]
                internal static extern void tcClearBit_0(ulong* _0, uint bit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcLSBEPKyj")]
                internal static extern uint tcLSB_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcMSBEPKyj")]
                internal static extern uint tcMSB_0(ulong* parts, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8tcNegateEPyj")]
                internal static extern void tcNegate_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcAddEPyPKyyj")]
                internal static extern ulong tcAdd_0(ulong* _0, ulong* _1, ulong carry, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10tcSubtractEPyPKyyj")]
                internal static extern ulong tcSubtract_0(ulong* _0, ulong* _1, ulong carry, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt14tcMultiplyPartEPyPKyyyjjb")]
                internal static extern int tcMultiplyPart_0(ulong* dst, ulong* src, ulong multiplier, ulong carry, uint srcParts, uint dstParts, bool add);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt10tcMultiplyEPyPKyS3_j")]
                internal static extern int tcMultiply_0(ulong* _0, ulong* _1, ulong* _2, uint _3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt14tcFullMultiplyEPyPKyS3_jj")]
                internal static extern uint tcFullMultiply_0(ulong* _0, ulong* _1, ulong* _2, uint _3, uint _4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt8tcDivideEPyPKyS1_S1_j")]
                internal static extern int tcDivide_0(ulong* lhs, ulong* rhs, ulong* remainder, ulong* scratch, uint parts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11tcShiftLeftEPyjj")]
                internal static extern void tcShiftLeft_0(ulong* _0, uint parts, uint count);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12tcShiftRightEPyjj")]
                internal static extern void tcShiftRight_0(ulong* _0, uint parts, uint count);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcAndEPyPKyj")]
                internal static extern void tcAnd_0(ulong* _0, ulong* _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt4tcOrEPyPKyj")]
                internal static extern void tcOr_0(ulong* _0, ulong* _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt5tcXorEPyPKyj")]
                internal static extern void tcXor_0(ulong* _0, ulong* _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt12tcComplementEPyj")]
                internal static extern void tcComplement_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt9tcCompareEPKyS2_j")]
                internal static extern int tcCompare_0(ulong* _0, ulong* _1, uint _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11tcIncrementEPyj")]
                internal static extern ulong tcIncrement_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt11tcDecrementEPyj")]
                internal static extern ulong tcDecrement_0(ulong* _0, uint _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5APInt25tcSetLeastSignificantBitsEPyjj")]
                internal static extern void tcSetLeastSignificantBits_0(ulong* _0, uint _1, uint bits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APInt4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmeqEyRKNS_5APIntE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_2(ulong V1, global::System.IntPtr V2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmneEyRKNS_5APIntE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_2(ulong V1, global::System.IntPtr V2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5APIntixEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorSubscript_0(global::System.IntPtr instance, uint bitPosition);
            }

            /// <summary>
            /// <para>This union is used to store the integer value. When the integer
            /// bit-width &lt;= 64, it uses VAL, otherwise it uses pVal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This union is used to store the integer value. When
            /// the</para>
            /// <para>  /// integer bit-width &lt;= 64, it uses VAL, otherwise it uses
            /// pVal.</para>
            /// </remarks>
            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong VAL;

                    [FieldOffset(0)]
                    public ulong* pVal;
                }
            }

            /// <summary>
            /// <para>Calculate the magic number for signed division by a
            /// constant.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Calculate the magic number for signed division by a
            /// constant.</para>
            /// </remarks>
            public unsafe partial class ms : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public llvm.APInt.Internal m;

                    [FieldOffset(16)]
                    public uint s;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2msC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2msC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2msD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ms> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ms>();

                private readonly bool __ownsNativeInstance;

                public static ms __CreateInstance(global::System.IntPtr native)
                {
                    return new ms((ms.Internal*) native);
                }

                public static ms __CreateInstance(ms.Internal native)
                {
                    return new ms(native);
                }

                private static ms.Internal* __CopyValue(ms.Internal native)
                {
                    var ret = (ms.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private ms(ms.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ms(ms.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ms()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    llvm.APInt.ms __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public llvm.APInt m
                {
                    get
                    {
                        return llvm.APInt.__CreateInstance(((Internal*) __Instance)->m);
                    }

                    set
                    {
                        ((Internal*) __Instance)->m = ReferenceEquals(value, null) ? new llvm.APInt.Internal() : *(llvm.APInt.Internal*) (value.__Instance);
                    }
                }

                public uint s
                {
                    get
                    {
                        return ((Internal*) __Instance)->s;
                    }

                    set
                    {
                        ((Internal*) __Instance)->s = value;
                    }
                }
            }

            /// <summary>
            /// <para>Calculate the magic number for unsigned division by a
            /// constant.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Calculate the magic number for unsigned division by a
            /// constant.</para>
            /// </remarks>
            public unsafe partial class mu : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public llvm.APInt.Internal m;

                    [FieldOffset(16)]
                    public bool a;

                    [FieldOffset(20)]
                    public uint s;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2muC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2muC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm5APInt2muD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, mu> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, mu>();

                private readonly bool __ownsNativeInstance;

                public static mu __CreateInstance(global::System.IntPtr native)
                {
                    return new mu((mu.Internal*) native);
                }

                public static mu __CreateInstance(mu.Internal native)
                {
                    return new mu(native);
                }

                private static mu.Internal* __CopyValue(mu.Internal native)
                {
                    var ret = (mu.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private mu(mu.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected mu(mu.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public mu()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    llvm.APInt.mu __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public llvm.APInt m
                {
                    get
                    {
                        return llvm.APInt.__CreateInstance(((Internal*) __Instance)->m);
                    }

                    set
                    {
                        ((Internal*) __Instance)->m = ReferenceEquals(value, null) ? new llvm.APInt.Internal() : *(llvm.APInt.Internal*) (value.__Instance);
                    }
                }

                public bool a
                {
                    get
                    {
                        return ((Internal*) __Instance)->a;
                    }

                    set
                    {
                        ((Internal*) __Instance)->a = value;
                    }
                }

                public uint s
                {
                    get
                    {
                        return ((Internal*) __Instance)->s;
                    }

                    set
                    {
                        ((Internal*) __Instance)->s = value;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APInt> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APInt>();

            private readonly bool __ownsNativeInstance;

            public static APInt __CreateInstance(global::System.IntPtr native)
            {
                return new APInt((APInt.Internal*) native);
            }

            public static APInt __CreateInstance(APInt.Internal native)
            {
                return new APInt(native);
            }

            private static APInt.Internal* __CopyValue(APInt.Internal native)
            {
                var ret = (APInt.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private APInt(APInt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected APInt(APInt.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Create a new APInt of numBits width, initialized as val.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new APInt of numBits width, initialized as
            /// val.</para>
            /// <para>  ///</para>
            /// <para>  /// If isSigned is true then val is treated as if it were a
            /// signed value</para>
            /// <para>  /// (i.e. as an int64_t) and the appropriate sign extension to
            /// the bit width</para>
            /// <para>  /// will be done. Otherwise, no sign extension occurs (high
            /// order bits beyond</para>
            /// <para>  /// the range of val are zero filled).</para>
            /// <para>  ///</para>
            /// <para>  /// \param numBits the bit width of the constructed
            /// APInt</para>
            /// <para>  /// \param val the initial value of the APInt</para>
            /// <para>  /// \param isSigned how to treat signedness of val</para>
            /// </remarks>
            public APInt(uint numBits, ulong val, bool isSigned)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg1 = val;
                Internal.ctor_1(__Instance, numBits, arg1, isSigned);
            }

            /// <summary>
            /// <para>Construct an APInt from a string representation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an APInt from a string
            /// representation.</para>
            /// <para>  ///</para>
            /// <para>  /// This constructor interprets the string \p str in the given
            /// radix. The</para>
            /// <para>  /// interpretation stops when the first character that is not
            /// suitable for the</para>
            /// <para>  /// radix is encountered, or the end of the string. Acceptable
            /// radix values</para>
            /// <para>  /// are 2, 8, 10, 16, and 36. It is an error for the value
            /// implied by the</para>
            /// <para>  /// string to require more bits than numBits.</para>
            /// <para>  ///</para>
            /// <para>  /// \param numBits the bit width of the constructed
            /// APInt</para>
            /// <para>  /// \param str the string to be interpreted</para>
            /// <para>  /// \param radix the radix to use for the conversion</para>
            /// </remarks>
            public APInt(uint numBits, llvm.StringRef str, byte radix)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg1 = ReferenceEquals(str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (str.__Instance);
                var arg2 = radix;
                Internal.ctor_4(__Instance, numBits, arg1, arg2);
            }

            /// <summary>
            /// <para>Default constructor that creates an uninitialized APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Default constructor that creates an uninitialized
            /// APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// This is useful for object deserialization (pair this with
            /// the static</para>
            /// <para>  ///  method Read).</para>
            /// </remarks>
            public APInt()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_7(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.APInt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Returns whether this instance allocated memory.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this instance allocated memory.</para>
            /// </remarks>
            public bool needsCleanup()
            {
                var __ret = Internal.needsCleanup_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Used to insert APInt objects, or objects that contain APInt
            /// objects, into FoldingSets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Used to insert APInt objects, or objects that contain APInt
            /// objects, into</para>
            /// <para>  ///  FoldingSets.</para>
            /// </remarks>
            public void Profile(llvm.FoldingSetNodeID id)
            {
                var arg0 = ReferenceEquals(id, null) ? global::System.IntPtr.Zero : id.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determine sign of this APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine sign of this APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// This tests the high bit of this APInt to determine if it is
            /// set.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if this APInt is negative, false
            /// otherwise</para>
            /// </remarks>
            public bool isNegative()
            {
                var __ret = Internal.isNegative_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this APInt Value is non-negative (&gt;= 0)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this APInt Value is non-negative (&gt;=
            /// 0)</para>
            /// <para>  ///</para>
            /// <para>  /// This tests the high bit of the APInt to determine if it is
            /// unset.</para>
            /// </remarks>
            public bool isNonNegative()
            {
                var __ret = Internal.isNonNegative_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this APInt Value is positive.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this APInt Value is positive.</para>
            /// <para>  ///</para>
            /// <para>  /// This tests if the value of this APInt is positive (&gt; 0).
            /// Note</para>
            /// <para>  /// that 0 is not a positive value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if this APInt is positive.</para>
            /// </remarks>
            public bool isStrictlyPositive()
            {
                var __ret = Internal.isStrictlyPositive_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if all bits are set</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if all bits are set</para>
            /// <para>  ///</para>
            /// <para>  /// This checks to see if the value has all bits of the APInt
            /// are set or not.</para>
            /// </remarks>
            public bool isAllOnesValue()
            {
                var __ret = Internal.isAllOnesValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this is the largest unsigned value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this is the largest unsigned
            /// value.</para>
            /// <para>  ///</para>
            /// <para>  /// This checks to see if the value of this APInt is the
            /// maximum unsigned</para>
            /// <para>  /// value for the APInt's bit width.</para>
            /// </remarks>
            public bool isMaxValue()
            {
                var __ret = Internal.isMaxValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this is the largest signed value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this is the largest signed value.</para>
            /// <para>  ///</para>
            /// <para>  /// This checks to see if the value of this APInt is the
            /// maximum signed</para>
            /// <para>  /// value for the APInt's bit width.</para>
            /// </remarks>
            public bool isMaxSignedValue()
            {
                var __ret = Internal.isMaxSignedValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this is the smallest unsigned value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this is the smallest unsigned
            /// value.</para>
            /// <para>  ///</para>
            /// <para>  /// This checks to see if the value of this APInt is the
            /// minimum unsigned</para>
            /// <para>  /// value for the APInt's bit width.</para>
            /// </remarks>
            public bool isMinValue()
            {
                var __ret = Internal.isMinValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this is the smallest signed value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this is the smallest signed value.</para>
            /// <para>  ///</para>
            /// <para>  /// This checks to see if the value of this APInt is the
            /// minimum signed</para>
            /// <para>  /// value for the APInt's bit width.</para>
            /// </remarks>
            public bool isMinSignedValue()
            {
                var __ret = Internal.isMinSignedValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this APInt has an N-bits unsigned integer value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if this APInt has an N-bits unsigned integer
            /// value.</para>
            /// </remarks>
            public bool isIntN(uint N)
            {
                var __ret = Internal.isIntN_0(__Instance, N);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this APInt has an N-bits signed integer value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if this APInt has an N-bits signed integer
            /// value.</para>
            /// </remarks>
            public bool isSignedIntN(uint N)
            {
                var __ret = Internal.isSignedIntN_0(__Instance, N);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this APInt's value is a power of two greater than
            /// zero.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if this APInt's value is a power of two greater
            /// than zero.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if the argument APInt value is a power of two
            /// &gt; 0.</para>
            /// </remarks>
            public bool isPowerOf2()
            {
                var __ret = Internal.isPowerOf2_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Check if the APInt's value is returned by getSignBit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if the APInt's value is returned by
            /// getSignBit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if this is the value returned by
            /// getSignBit.</para>
            /// </remarks>
            public bool isSignBit()
            {
                var __ret = Internal.isSignBit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Convert APInt to a boolean value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Convert APInt to a boolean value.</para>
            /// <para>  ///</para>
            /// <para>  /// This converts the APInt to a boolean value as a test
            /// against zero.</para>
            /// </remarks>
            public bool getBoolValue()
            {
                var __ret = Internal.getBoolValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this value is smaller than the specified limit, return it,
            /// otherwise return the limit value. This causes the value to saturate to the
            /// limit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this value is smaller than the specified limit, return it,
            /// otherwise</para>
            /// <para>  /// return the limit value.  This causes the value to saturate
            /// to the limit.</para>
            /// </remarks>
            public ulong getLimitedValue(ulong Limit)
            {
                var arg0 = Limit;
                var __ret = Internal.getLimitedValue_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Compute an APInt containing numBits highbits from this
            /// APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute an APInt containing numBits highbits from this
            /// APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// Get an APInt with the same BitWidth as this APInt, just
            /// zero mask</para>
            /// <para>  /// the low bits and right shift to the least significant
            /// bit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the high &quot;numBits&quot; bits of this
            /// APInt.</para>
            /// </remarks>
            public llvm.APInt getHiBits(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getHiBits_0(new IntPtr(&__ret), __Instance, numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Compute an APInt containing numBits lowbits from this
            /// APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute an APInt containing numBits lowbits from this
            /// APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// Get an APInt with the same BitWidth as this APInt, just
            /// zero mask</para>
            /// <para>  /// the high bits.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the low &quot;numBits&quot; bits of this
            /// APInt.</para>
            /// </remarks>
            public llvm.APInt getLoBits(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getLoBits_0(new IntPtr(&__ret), __Instance, numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>This function returns a pointer to the internal storage of the
            /// APInt. This is useful for writing out the APInt in binary form without any
            /// conversions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This function returns a pointer to the internal storage of
            /// the APInt.</para>
            /// <para>  /// This is useful for writing out the APInt in binary form
            /// without any</para>
            /// <para>  /// conversions.</para>
            /// </remarks>
            public ulong* getRawData()
            {
                var __ret = Internal.getRawData_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Prefix increment operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Prefix increment operator.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns *this incremented by one</para>
            /// </remarks>
            public static llvm.APInt operator ++(llvm.APInt __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_1(arg0);
                llvm.APInt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.APInt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.APInt) llvm.APInt.NativeToManagedMap[__ret];
                else __result0 = llvm.APInt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Prefix decrement operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Prefix decrement operator.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns *this decremented by one.</para>
            /// </remarks>
            public static llvm.APInt operator --(llvm.APInt __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_1(arg0);
                llvm.APInt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.APInt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.APInt) llvm.APInt.NativeToManagedMap[__ret];
                else __result0 = llvm.APInt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Unary bitwise complement operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unary bitwise complement operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise complement operation on this
            /// APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns an APInt that is the bitwise complement of
            /// *this</para>
            /// </remarks>
            public static llvm.APInt operator ~(llvm.APInt __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorTilde_0(new IntPtr(&__ret), arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Unary negation operator</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unary negation operator</para>
            /// <para>  ///</para>
            /// <para>  /// Negates *this using two's complement logic.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the negation of
            /// *this.</para>
            /// </remarks>
            public static llvm.APInt operator -(llvm.APInt __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorMinus_0(new IntPtr(&__ret), arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Logical negation operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Logical negation operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs logical negation operation on this APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this is zero, false otherwise.</para>
            /// </remarks>
            public static bool operator !(llvm.APInt __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorExclaim_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Bitwise AND operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Bitwise AND operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise AND operation on *this and RHS.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the bitwise AND of
            /// *this and RHS.</para>
            /// </remarks>
            public static llvm.APInt operator &(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorAmp_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public llvm.APInt And(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.And_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Bitwise OR operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Bitwise OR operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise OR operation on *this and RHS.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the bitwise OR of
            /// *this and RHS.</para>
            /// </remarks>
            public static llvm.APInt operator |(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorPipe_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Bitwise OR function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Bitwise OR function.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise or on *this and RHS. This is implemented
            /// bny simply</para>
            /// <para>  /// calling operator|.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the bitwise OR of
            /// *this and RHS.</para>
            /// </remarks>
            public llvm.APInt Or(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.Or_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Bitwise XOR operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Bitwise XOR operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise XOR operation on *this and RHS.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the bitwise XOR of
            /// *this and RHS.</para>
            /// </remarks>
            public static llvm.APInt operator ^(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorCaret_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Bitwise XOR function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Bitwise XOR function.</para>
            /// <para>  ///</para>
            /// <para>  /// Performs a bitwise XOR operation on *this and RHS. This is
            /// implemented</para>
            /// <para>  /// through the usage of operator^.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value representing the bitwise XOR of
            /// *this and RHS.</para>
            /// </remarks>
            public llvm.APInt Xor(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.Xor_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Multiplication operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Multiplication operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Multiplies this APInt by RHS and returns the result.</para>
            /// </remarks>
            public static llvm.APInt operator *(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorStar_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Addition operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Addition operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Adds RHS to this APInt and returns the result.</para>
            /// </remarks>
            public static llvm.APInt operator +(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public static llvm.APInt operator +(llvm.APInt __op, ulong RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = RHS;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorPlus_1(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Subtraction operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Subtraction operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Subtracts RHS from this APInt and returns the
            /// result.</para>
            /// </remarks>
            public static llvm.APInt operator -(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorMinus_1(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public static llvm.APInt operator -(llvm.APInt __op, ulong RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = RHS;
                var __ret = new llvm.APInt.Internal();
                Internal.OperatorMinus_2(new IntPtr(&__ret), arg0, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Arithmetic right-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Arithmetic right-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Arithmetic right-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt ashr(uint shiftAmt)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.ashr_0(new IntPtr(&__ret), __Instance, shiftAmt);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Logical right-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Logical right-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Logical right-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt lshr(uint shiftAmt)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.lshr_0(new IntPtr(&__ret), __Instance, shiftAmt);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Left-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Left-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Left-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt shl(uint shiftAmt)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.shl_0(new IntPtr(&__ret), __Instance, shiftAmt);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Rotate left by rotateAmt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Rotate left by rotateAmt.</para>
            /// </remarks>
            public llvm.APInt rotl(uint rotateAmt)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.rotl_0(new IntPtr(&__ret), __Instance, rotateAmt);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Rotate right by rotateAmt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Rotate right by rotateAmt.</para>
            /// </remarks>
            public llvm.APInt rotr(uint rotateAmt)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.rotr_0(new IntPtr(&__ret), __Instance, rotateAmt);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Arithmetic right-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Arithmetic right-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Arithmetic right-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt ashr(llvm.APInt shiftAmt)
            {
                var arg0 = ReferenceEquals(shiftAmt, null) ? global::System.IntPtr.Zero : shiftAmt.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.ashr_1(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Logical right-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Logical right-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Logical right-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt lshr(llvm.APInt shiftAmt)
            {
                var arg0 = ReferenceEquals(shiftAmt, null) ? global::System.IntPtr.Zero : shiftAmt.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.lshr_1(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Left-shift function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Left-shift function.</para>
            /// <para>  ///</para>
            /// <para>  /// Left-shift this APInt by shiftAmt.</para>
            /// </remarks>
            public llvm.APInt shl(llvm.APInt shiftAmt)
            {
                var arg0 = ReferenceEquals(shiftAmt, null) ? global::System.IntPtr.Zero : shiftAmt.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.shl_1(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Rotate left by rotateAmt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Rotate left by rotateAmt.</para>
            /// </remarks>
            public llvm.APInt rotl(llvm.APInt rotateAmt)
            {
                var arg0 = ReferenceEquals(rotateAmt, null) ? global::System.IntPtr.Zero : rotateAmt.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.rotl_1(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Rotate right by rotateAmt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Rotate right by rotateAmt.</para>
            /// </remarks>
            public llvm.APInt rotr(llvm.APInt rotateAmt)
            {
                var arg0 = ReferenceEquals(rotateAmt, null) ? global::System.IntPtr.Zero : rotateAmt.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.rotr_1(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Unsigned division operation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned division operation.</para>
            /// <para>  ///</para>
            /// <para>  /// Perform an unsigned divide operation on this APInt by RHS.
            /// Both this and</para>
            /// <para>  /// RHS are treated as unsigned quantities for purposes of this
            /// division.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns a new APInt value containing the division
            /// result</para>
            /// </remarks>
            public llvm.APInt udiv(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.udiv_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Signed division function for APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed division function for APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// Signed divide this APInt by APInt RHS.</para>
            /// </remarks>
            public llvm.APInt sdiv(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.sdiv_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Unsigned remainder operation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned remainder operation.</para>
            /// <para>  ///</para>
            /// <para>  /// Perform an unsigned remainder operation on this APInt with
            /// RHS being the</para>
            /// <para>  /// divisor. Both this and RHS are treated as unsigned
            /// quantities for purposes</para>
            /// <para>  /// of this operation. Note that this is a true remainder
            /// operation and not a</para>
            /// <para>  /// modulo operation because the sign follows the sign of the
            /// dividend which</para>
            /// <para>  /// is *this.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns a new APInt value containing the remainder
            /// result</para>
            /// </remarks>
            public llvm.APInt urem(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.urem_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Function for signed remainder operation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Function for signed remainder operation.</para>
            /// <para>  ///</para>
            /// <para>  /// Signed remainder operation on APInt.</para>
            /// </remarks>
            public llvm.APInt srem(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.srem_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public llvm.APInt sadd_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.sadd_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt uadd_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.uadd_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt ssub_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.ssub_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt usub_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.usub_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt sdiv_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.sdiv_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt smul_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.smul_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt umul_ov(llvm.APInt RHS, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.umul_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt sshl_ov(llvm.APInt Amt, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(Amt, null) ? global::System.IntPtr.Zero : Amt.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.sshl_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            public llvm.APInt ushl_ov(llvm.APInt Amt, ref bool Overflow)
            {
                var arg0 = ReferenceEquals(Amt, null) ? global::System.IntPtr.Zero : Amt.__Instance;
                fixed (bool* arg1 = &Overflow)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.ushl_ov_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>Equality operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Equality operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with RHS for the validity of the
            /// equality</para>
            /// <para>  /// relationship.</para>
            /// </remarks>
            public static bool operator ==(llvm.APInt __op, llvm.APInt RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as APInt;
            }

            /// <summary>
            /// <para>Equality operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Equality operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with a uint64_t for the validity of the
            /// equality</para>
            /// <para>  /// relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this == Val</para>
            /// </remarks>
            public static bool operator ==(llvm.APInt __op, ulong Val)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool ValNull = ReferenceEquals(Val, null);
                if (__opNull || ValNull)
                    return __opNull && ValNull;
                var arg0 = __op.__Instance;
                var arg1 = Val;
                var __ret = Internal.OperatorEqualEqual_1(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Equality comparison.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Equality comparison.</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with RHS for the validity of the
            /// equality</para>
            /// <para>  /// relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this == Val</para>
            /// </remarks>
            public bool eq(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.eq_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Inequality operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Inequality operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with RHS for the validity of the
            /// inequality</para>
            /// <para>  /// relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this != Val</para>
            /// </remarks>
            public static bool operator !=(llvm.APInt __op, llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Inequality operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Inequality operator.</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with a uint64_t for the validity of the
            /// inequality</para>
            /// <para>  /// relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this != Val</para>
            /// </remarks>
            public static bool operator !=(llvm.APInt __op, ulong Val)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = Val;
                var __ret = Internal.OperatorExclaimEqual_1(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Inequality comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Inequality comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Compares this APInt with RHS for the validity of the
            /// inequality</para>
            /// <para>  /// relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this != Val</para>
            /// </remarks>
            public bool ne(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.ne_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned less than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned less than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as unsigned quantities and
            /// compares them for</para>
            /// <para>  /// the validity of the less-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt; RHS when both are considered
            /// unsigned.</para>
            /// </remarks>
            public bool ult(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.ult_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned less than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned less than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as an unsigned quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the less-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt; RHS when considered
            /// unsigned.</para>
            /// </remarks>
            public bool ult(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.ult_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed less than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed less than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as signed quantities and
            /// compares them for</para>
            /// <para>  /// validity of the less-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt; RHS when both are considered
            /// signed.</para>
            /// </remarks>
            public bool slt(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.slt_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed less than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed less than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as a signed quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the less-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt; RHS when considered
            /// signed.</para>
            /// </remarks>
            public bool slt(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.slt_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned less or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned less or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as unsigned quantities and
            /// compares them for</para>
            /// <para>  /// validity of the less-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt;= RHS when both are considered
            /// unsigned.</para>
            /// </remarks>
            public bool ule(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.ule_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned less or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned less or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as an unsigned quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the less-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt;= RHS when considered
            /// unsigned.</para>
            /// </remarks>
            public bool ule(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.ule_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed less or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed less or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as signed quantities and
            /// compares them for</para>
            /// <para>  /// validity of the less-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt;= RHS when both are considered
            /// signed.</para>
            /// </remarks>
            public bool sle(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.sle_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed less or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed less or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as a signed quantity and compares it
            /// with RHS for the</para>
            /// <para>  /// validity of the less-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &lt;= RHS when considered
            /// signed.</para>
            /// </remarks>
            public bool sle(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.sle_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned greather than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned greather than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as unsigned quantities and
            /// compares them for</para>
            /// <para>  /// the validity of the greater-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt; RHS when both are considered
            /// unsigned.</para>
            /// </remarks>
            public bool ugt(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.ugt_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned greater than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned greater than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as an unsigned quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the greater-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt; RHS when considered
            /// unsigned.</para>
            /// </remarks>
            public bool ugt(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.ugt_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed greather than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed greather than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as signed quantities and
            /// compares them for the</para>
            /// <para>  /// validity of the greater-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt; RHS when both are considered
            /// signed.</para>
            /// </remarks>
            public bool sgt(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.sgt_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed greater than comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed greater than comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as a signed quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the greater-than relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt; RHS when considered
            /// signed.</para>
            /// </remarks>
            public bool sgt(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.sgt_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned greater or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned greater or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as unsigned quantities and
            /// compares them for</para>
            /// <para>  /// validity of the greater-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt;= RHS when both are considered
            /// unsigned.</para>
            /// </remarks>
            public bool uge(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.uge_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Unsigned greater or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unsigned greater or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as an unsigned quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the greater-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt;= RHS when considered
            /// unsigned.</para>
            /// </remarks>
            public bool uge(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.uge_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed greather or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed greather or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this and RHS as signed quantities and
            /// compares them for</para>
            /// <para>  /// validity of the greater-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt;= RHS when both are considered
            /// signed.</para>
            /// </remarks>
            public bool sge(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.sge_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Signed greater or equal comparison</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Signed greater or equal comparison</para>
            /// <para>  ///</para>
            /// <para>  /// Regards both *this as a signed quantity and compares it
            /// with RHS for</para>
            /// <para>  /// the validity of the greater-or-equal relationship.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if *this &gt;= RHS when considered
            /// signed.</para>
            /// </remarks>
            public bool sge(ulong RHS)
            {
                var arg0 = RHS;
                var __ret = Internal.sge_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>This operation tests if there are any pairs of corresponding bits
            /// between this APInt and RHS that are both set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This operation tests if there are any pairs of corresponding
            /// bits</para>
            /// <para>  /// between this APInt and RHS that are both set.</para>
            /// </remarks>
            public bool intersects(llvm.APInt RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.intersects_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Truncate to new width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Truncate to new width.</para>
            /// <para>  ///</para>
            /// <para>  /// Truncate the APInt to a specified width. It is an error to
            /// specify a width</para>
            /// <para>  /// that is greater than or equal to the current width.</para>
            /// </remarks>
            public llvm.APInt trunc(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.trunc_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Sign extend to a new width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sign extend to a new width.</para>
            /// <para>  ///</para>
            /// <para>  /// This operation sign extends the APInt to a new width. If
            /// the high order</para>
            /// <para>  /// bit is set, the fill on the left will be done with 1 bits,
            /// otherwise zero.</para>
            /// <para>  /// It is an error to specify a width that is less than or
            /// equal to the</para>
            /// <para>  /// current width.</para>
            /// </remarks>
            public llvm.APInt sext(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.sext_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Zero extend to a new width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Zero extend to a new width.</para>
            /// <para>  ///</para>
            /// <para>  /// This operation zero extends the APInt to a new width. The
            /// high order bits</para>
            /// <para>  /// are filled with 0 bits.  It is an error to specify a width
            /// that is less</para>
            /// <para>  /// than or equal to the current width.</para>
            /// </remarks>
            public llvm.APInt zext(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.zext_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Sign extend or truncate to width</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sign extend or truncate to width</para>
            /// <para>  ///</para>
            /// <para>  /// Make this APInt have the bit width given by \p width. The
            /// value is sign</para>
            /// <para>  /// extended, truncated, or left alone to make it that
            /// width.</para>
            /// </remarks>
            public llvm.APInt sextOrTrunc(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.sextOrTrunc_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Zero extend or truncate to width</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Zero extend or truncate to width</para>
            /// <para>  ///</para>
            /// <para>  /// Make this APInt have the bit width given by \p width. The
            /// value is zero</para>
            /// <para>  /// extended, truncated, or left alone to make it that
            /// width.</para>
            /// </remarks>
            public llvm.APInt zextOrTrunc(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.zextOrTrunc_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Sign extend or truncate to width</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sign extend or truncate to width</para>
            /// <para>  ///</para>
            /// <para>  /// Make this APInt have the bit width given by \p width. The
            /// value is sign</para>
            /// <para>  /// extended, or left alone to make it that width.</para>
            /// </remarks>
            public llvm.APInt sextOrSelf(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.sextOrSelf_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Zero extend or truncate to width</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Zero extend or truncate to width</para>
            /// <para>  ///</para>
            /// <para>  /// Make this APInt have the bit width given by \p width. The
            /// value is zero</para>
            /// <para>  /// extended, or left alone to make it that width.</para>
            /// </remarks>
            public llvm.APInt zextOrSelf(uint width)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.zextOrSelf_0(new IntPtr(&__ret), __Instance, width);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set every bit to 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set every bit to 1.</para>
            /// </remarks>
            public void setAllBits()
            {
                Internal.setAllBits_0(__Instance);
            }

            /// <summary>
            /// <para>Set a given bit to 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set a given bit to 1.</para>
            /// <para>  ///</para>
            /// <para>  /// Set the given bit to 1 whose position is given as
            /// &quot;bitPosition&quot;.</para>
            /// </remarks>
            public void setBit(uint bitPosition)
            {
                Internal.setBit_0(__Instance, bitPosition);
            }

            /// <summary>
            /// <para>Set every bit to 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set every bit to 0.</para>
            /// </remarks>
            public void clearAllBits()
            {
                Internal.clearAllBits_0(__Instance);
            }

            /// <summary>
            /// <para>Set a given bit to 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set a given bit to 0.</para>
            /// <para>  ///</para>
            /// <para>  /// Set the given bit to 0 whose position is given as
            /// &quot;bitPosition&quot;.</para>
            /// </remarks>
            public void clearBit(uint bitPosition)
            {
                Internal.clearBit_0(__Instance, bitPosition);
            }

            /// <summary>
            /// <para>Toggle every bit to its opposite value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Toggle every bit to its opposite value.</para>
            /// </remarks>
            public void flipAllBits()
            {
                Internal.flipAllBits_0(__Instance);
            }

            /// <summary>
            /// <para>Toggles a given bit to its opposite value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Toggles a given bit to its opposite value.</para>
            /// <para>  ///</para>
            /// <para>  /// Toggle a given bit to its opposite value whose position is
            /// given</para>
            /// <para>  /// as &quot;bitPosition&quot;.</para>
            /// </remarks>
            public void flipBit(uint bitPosition)
            {
                Internal.flipBit_0(__Instance, bitPosition);
            }

            /// <summary>
            /// <para>Return the number of bits in the APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the number of bits in the APInt.</para>
            /// </remarks>
            public uint getBitWidth()
            {
                var __ret = Internal.getBitWidth_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the number of words.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the number of words.</para>
            /// <para>  ///</para>
            /// <para>  /// Here one word's bitwidth equals to that of uint64_t.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the number of words to hold the integer value of
            /// this APInt.</para>
            /// </remarks>
            public uint getNumWords()
            {
                var __ret = Internal.getNumWords_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Compute the number of active bits in the value</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute the number of active bits in the value</para>
            /// <para>  ///</para>
            /// <para>  /// This function returns the number of active bits which is
            /// defined as the</para>
            /// <para>  /// bit width minus the number of leading zeros. This is used
            /// in several</para>
            /// <para>  /// computations to see how &quot;wide&quot; the value
            /// is.</para>
            /// </remarks>
            public uint getActiveBits()
            {
                var __ret = Internal.getActiveBits_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Compute the number of active words in the value of this
            /// APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute the number of active words in the value of
            /// this APInt.</para>
            /// <para>  ///</para>
            /// <para>  /// This is used in conjunction with getActiveData to extract
            /// the raw value of</para>
            /// <para>  /// the APInt.</para>
            /// </remarks>
            public uint getActiveWords()
            {
                var __ret = Internal.getActiveWords_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the minimum bit size for this signed APInt</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the minimum bit size for this signed APInt</para>
            /// <para>  ///</para>
            /// <para>  /// Computes the minimum bit width for this APInt while
            /// considering it to be a</para>
            /// <para>  /// signed (and probably negative) value. If the value is not
            /// negative, this</para>
            /// <para>  /// function returns the same value as getActiveBits()+1.
            /// Otherwise, it</para>
            /// <para>  /// returns the smallest bit width that will retain the
            /// negative value. For</para>
            /// <para>  /// example, -1 can be written as 0b1 or 0xFFFFFFFFFF. 0b1 is
            /// shorter and so</para>
            /// <para>  /// for -1, this function will always return 1.</para>
            /// </remarks>
            public uint getMinSignedBits()
            {
                var __ret = Internal.getMinSignedBits_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get zero extended value</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get zero extended value</para>
            /// <para>  ///</para>
            /// <para>  /// This method attempts to return the value of this APInt as a
            /// zero extended</para>
            /// <para>  /// uint64_t. The bitwidth must be &lt;= 64 or the value must
            /// fit within a</para>
            /// <para>  /// uint64_t. Otherwise an assertion will result.</para>
            /// </remarks>
            public ulong getZExtValue()
            {
                var __ret = Internal.getZExtValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get sign extended value</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get sign extended value</para>
            /// <para>  ///</para>
            /// <para>  /// This method attempts to return the value of this APInt as a
            /// sign extended</para>
            /// <para>  /// int64_t. The bit width must be &lt;= 64 or the value must
            /// fit within an</para>
            /// <para>  /// int64_t. Otherwise an assertion will result.</para>
            /// </remarks>
            public long getSExtValue()
            {
                var __ret = Internal.getSExtValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>The APInt version of the countLeadingZeros functions in
            /// MathExtras.h.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The APInt version of the countLeadingZeros functions
            /// in</para>
            /// <para>  ///   MathExtras.h.</para>
            /// <para>  ///</para>
            /// <para>  /// It counts the number of zeros from the most significant bit
            /// to the first</para>
            /// <para>  /// one bit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns BitWidth if the value is zero, otherwise returns
            /// the number of</para>
            /// <para>  ///   zeros from the most significant bit to the first one
            /// bits.</para>
            /// </remarks>
            public uint countLeadingZeros()
            {
                var __ret = Internal.countLeadingZeros_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Count the number of leading one bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Count the number of leading one bits.</para>
            /// <para>  ///</para>
            /// <para>  /// This function is an APInt version of the
            /// countLeadingOnes</para>
            /// <para>  /// functions in MathExtras.h. It counts the number of ones
            /// from the most</para>
            /// <para>  /// significant bit to the first zero bit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns 0 if the high order bit is not set, otherwise
            /// returns the number</para>
            /// <para>  /// of 1 bits from the most significant to the least</para>
            /// </remarks>
            public uint countLeadingOnes()
            {
                var __ret = Internal.countLeadingOnes_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Computes the number of leading bits of this APInt that are equal
            /// to its sign bit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Computes the number of leading bits of this APInt that are
            /// equal to its</para>
            /// <para>  /// sign bit.</para>
            /// </remarks>
            public uint getNumSignBits()
            {
                var __ret = Internal.getNumSignBits_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Count the number of trailing zero bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Count the number of trailing zero bits.</para>
            /// <para>  ///</para>
            /// <para>  /// This function is an APInt version of the
            /// countTrailingZeros</para>
            /// <para>  /// functions in MathExtras.h. It counts the number of zeros
            /// from the least</para>
            /// <para>  /// significant bit to the first set bit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns BitWidth if the value is zero, otherwise returns
            /// the number of</para>
            /// <para>  /// zeros from the least significant bit to the first one
            /// bit.</para>
            /// </remarks>
            public uint countTrailingZeros()
            {
                var __ret = Internal.countTrailingZeros_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Count the number of trailing one bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Count the number of trailing one bits.</para>
            /// <para>  ///</para>
            /// <para>  /// This function is an APInt version of the
            /// countTrailingOnes</para>
            /// <para>  /// functions in MathExtras.h. It counts the number of ones
            /// from the least</para>
            /// <para>  /// significant bit to the first zero bit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns BitWidth if the value is all ones, otherwise
            /// returns the number</para>
            /// <para>  /// of ones from the least significant bit to the first zero
            /// bit.</para>
            /// </remarks>
            public uint countTrailingOnes()
            {
                var __ret = Internal.countTrailingOnes_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Count the number of bits set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Count the number of bits set.</para>
            /// <para>  ///</para>
            /// <para>  /// This function is an APInt version of the countPopulation
            /// functions</para>
            /// <para>  /// in MathExtras.h. It counts the number of 1 bits in the
            /// APInt value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns 0 if the value is zero, otherwise returns the
            /// number of set bits.</para>
            /// </remarks>
            public uint countPopulation()
            {
                var __ret = Internal.countPopulation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>@} @{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @}</para>
            /// <para>  /// \name Conversion Functions</para>
            /// <para>  /// @{</para>
            /// </remarks>
            public void print(llvm.raw_ostream OS, bool isSigned)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.print_0(__Instance, arg0, isSigned);
            }

            /// <summary>
            /// <para>Returns a byte-swapped representation of this APInt Value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns a byte-swapped representation of this APInt
            /// Value.</para>
            /// </remarks>
            public llvm.APInt byteSwap()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.byteSwap_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Converts this APInt to a double value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts this APInt to a double value.</para>
            /// </remarks>
            public double roundToDouble(bool isSigned)
            {
                var __ret = Internal.roundToDouble_0(__Instance, isSigned);
                return __ret;
            }

            /// <summary>
            /// <para>Converts this unsigned APInt to a double value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts this unsigned APInt to a double value.</para>
            /// </remarks>
            public double roundToDouble()
            {
                var __ret = Internal.roundToDouble_1(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Converts this signed APInt to a double value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts this signed APInt to a double value.</para>
            /// </remarks>
            public double signedRoundToDouble()
            {
                var __ret = Internal.signedRoundToDouble_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Converts APInt bits to a double</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts APInt bits to a double</para>
            /// <para>  ///</para>
            /// <para>  /// The conversion does not do a translation from integer to
            /// double, it just</para>
            /// <para>  /// re-interprets the bits as a double. Note that it is valid
            /// to do this on</para>
            /// <para>  /// any bit width. Exactly 64 bits will be translated.</para>
            /// </remarks>
            public double bitsToDouble()
            {
                var __ret = Internal.bitsToDouble_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Converts APInt bits to a double</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts APInt bits to a double</para>
            /// <para>  ///</para>
            /// <para>  /// The conversion does not do a translation from integer to
            /// float, it just</para>
            /// <para>  /// re-interprets the bits as a float. Note that it is valid to
            /// do this on</para>
            /// <para>  /// any bit width. Exactly 32 bits will be translated.</para>
            /// </remarks>
            public float bitsToFloat()
            {
                var __ret = Internal.bitsToFloat_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the floor log base 2 of this APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns the floor log base 2 of this APInt.</para>
            /// </remarks>
            public uint logBase2()
            {
                var __ret = Internal.logBase2_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the ceil log base 2 of this APInt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns the ceil log base 2 of this APInt.</para>
            /// </remarks>
            public uint ceilLogBase2()
            {
                var __ret = Internal.ceilLogBase2_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the nearest log base 2 of this APInt. Ties round
            /// up.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns the nearest log base 2 of this APInt. Ties round
            /// up.</para>
            /// <para>  ///</para>
            /// <para>  /// NOTE: When we have a BitWidth of 1, we define:</para>
            /// <para>  /// </para>
            /// <para>  ///   log2(0) = UINT32_MAX</para>
            /// <para>  ///   log2(1) = 0</para>
            /// <para>  ///</para>
            /// <para>  /// to get around any mathematical concerns resulting
            /// from</para>
            /// <para>  /// referencing 2 in a space where 2 does no exist.</para>
            /// </remarks>
            public uint nearestLogBase2()
            {
                var __ret = Internal.nearestLogBase2_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the log base 2 of this APInt if its an exact power of
            /// two, -1 otherwise</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns the log base 2 of this APInt if its an exact power
            /// of two, -1</para>
            /// <para>  /// otherwise</para>
            /// </remarks>
            public int exactLogBase2()
            {
                var __ret = Internal.exactLogBase2_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Compute the square root</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute the square root</para>
            /// </remarks>
            public llvm.APInt sqrt()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.sqrt_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the absolute value;</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the absolute value;</para>
            /// <para>  ///</para>
            /// <para>  /// If *this is &lt; 0 then return -(*this), otherwise
            /// *this;</para>
            /// </remarks>
            public llvm.APInt abs()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.abs_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the multiplicative inverse for a given modulo.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \returns the multiplicative inverse for a given
            /// modulo.</para>
            /// </remarks>
            public llvm.APInt multiplicativeInverse(llvm.APInt modulo)
            {
                var arg0 = ReferenceEquals(modulo, null) ? global::System.IntPtr.Zero : modulo.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.multiplicativeInverse_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public llvm.APInt.ms magic()
            {
                var __ret = new llvm.APInt.ms.Internal();
                Internal.magic_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.ms.__CreateInstance(__ret);
            }

            public llvm.APInt.mu magicu(uint LeadingZeros)
            {
                var __ret = new llvm.APInt.mu.Internal();
                Internal.magicu_0(new IntPtr(&__ret), __Instance, LeadingZeros);
                return llvm.APInt.mu.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>debug method</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief debug method</para>
            /// </remarks>
            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            /// <summary>
            /// <para>Gets maximum unsigned value of APInt for specific bit
            /// width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gets maximum unsigned value of APInt for specific bit
            /// width.</para>
            /// </remarks>
            public static llvm.APInt getMaxValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getMaxValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Gets maximum signed value of APInt for a specific bit
            /// width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gets maximum signed value of APInt for a specific bit
            /// width.</para>
            /// </remarks>
            public static llvm.APInt getSignedMaxValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getSignedMaxValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Gets minimum unsigned value of APInt for a specific bit
            /// width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gets minimum unsigned value of APInt for a specific
            /// bit width.</para>
            /// </remarks>
            public static llvm.APInt getMinValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getMinValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Gets minimum signed value of APInt for a specific bit
            /// width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gets minimum signed value of APInt for a specific bit
            /// width.</para>
            /// </remarks>
            public static llvm.APInt getSignedMinValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getSignedMinValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the SignBit for a specific bit width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the SignBit for a specific bit width.</para>
            /// <para>  ///</para>
            /// <para>  /// This is just a wrapper function of getSignedMinValue(), and
            /// it helps code</para>
            /// <para>  /// readability when we want to get a SignBit.</para>
            /// </remarks>
            public static llvm.APInt getSignBit(uint BitWidth)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getSignBit_0(new IntPtr(&__ret), BitWidth);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the all-ones value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the all-ones value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the all-ones value for an APInt of the specified
            /// bit-width.</para>
            /// </remarks>
            public static llvm.APInt getAllOnesValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getAllOnesValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the '0' value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the '0' value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the '0' value for an APInt of the specified
            /// bit-width.</para>
            /// </remarks>
            public static llvm.APInt getNullValue(uint numBits)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getNullValue_0(new IntPtr(&__ret), numBits);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return an APInt with exactly one bit set in the result.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return an APInt with exactly one bit set in the
            /// result.</para>
            /// </remarks>
            public static llvm.APInt getOneBitSet(uint numBits, uint BitNo)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getOneBitSet_0(new IntPtr(&__ret), numBits, BitNo);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get a value with a block of bits set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get a value with a block of bits set.</para>
            /// <para>  ///</para>
            /// <para>  /// Constructs an APInt value that has a contiguous range of
            /// bits set. The</para>
            /// <para>  /// bits from loBit (inclusive) to hiBit (exclusive) will be
            /// set. All other</para>
            /// <para>  /// bits will be zero. For example, with parameters(32, 0, 16)
            /// you would get</para>
            /// <para>  /// 0x0000FFFF. If hiBit is less than loBit then the set bits
            /// &quot;wrap&quot;. For</para>
            /// <para>  /// example, with parameters (32, 28, 4), you would get
            /// 0xF000000F.</para>
            /// <para>  ///</para>
            /// <para>  /// \param numBits the intended bit width of the result</para>
            /// <para>  /// \param loBit the index of the lowest bit set.</para>
            /// <para>  /// \param hiBit the index of the highest bit set.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns An APInt value with the requested bits set.</para>
            /// </remarks>
            public static llvm.APInt getBitsSet(uint numBits, uint loBit, uint hiBit)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getBitsSet_0(new IntPtr(&__ret), numBits, loBit, hiBit);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get a value with high bits set</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get a value with high bits set</para>
            /// <para>  ///</para>
            /// <para>  /// Constructs an APInt value that has the top hiBitsSet bits
            /// set.</para>
            /// <para>  ///</para>
            /// <para>  /// \param numBits the bitwidth of the result</para>
            /// <para>  /// \param hiBitsSet the number of high-order bits set in the
            /// result.</para>
            /// </remarks>
            public static llvm.APInt getHighBitsSet(uint numBits, uint hiBitsSet)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getHighBitsSet_0(new IntPtr(&__ret), numBits, hiBitsSet);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get a value with low bits set</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get a value with low bits set</para>
            /// <para>  ///</para>
            /// <para>  /// Constructs an APInt value that has the bottom loBitsSet
            /// bits set.</para>
            /// <para>  ///</para>
            /// <para>  /// \param numBits the bitwidth of the result</para>
            /// <para>  /// \param loBitsSet the number of low-order bits set in the
            /// result.</para>
            /// </remarks>
            public static llvm.APInt getLowBitsSet(uint numBits, uint loBitsSet)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getLowBitsSet_0(new IntPtr(&__ret), numBits, loBitsSet);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a value containing V broadcasted over NewLen bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a value containing V broadcasted over NewLen
            /// bits.</para>
            /// </remarks>
            public static llvm.APInt getSplat(uint NewLen, llvm.APInt V)
            {
                var arg1 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                var __ret = new llvm.APInt.Internal();
                Internal.getSplat_0(new IntPtr(&__ret), NewLen, arg1);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine if two APInts have the same value, after zero-extending
            /// one of them (if needed!) to ensure that the bit-widths match.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if two APInts have the same value, after
            /// zero-extending</para>
            /// <para>  /// one of them (if needed!) to ensure that the bit-widths
            /// match.</para>
            /// </remarks>
            public static bool isSameValue(llvm.APInt I1, llvm.APInt I2)
            {
                var arg0 = ReferenceEquals(I1, null) ? global::System.IntPtr.Zero : I1.__Instance;
                var arg1 = ReferenceEquals(I2, null) ? global::System.IntPtr.Zero : I2.__Instance;
                var __ret = Internal.isSameValue_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Dual division/remainder interface.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Dual division/remainder interface.</para>
            /// <para>  ///</para>
            /// <para>  /// Sometimes it is convenient to divide two APInt values and
            /// obtain both the</para>
            /// <para>  /// quotient and remainder. This function does both operations
            /// in the same</para>
            /// <para>  /// computation making it a little more efficient. The pair of
            /// input arguments</para>
            /// <para>  /// may overlap with the pair of output arguments. It is safe
            /// to call</para>
            /// <para>  /// udivrem(X, Y, X, Y), for example.</para>
            /// </remarks>
            public static void udivrem(llvm.APInt LHS, llvm.APInt RHS, llvm.APInt Quotient, llvm.APInt Remainder)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var arg2 = ReferenceEquals(Quotient, null) ? global::System.IntPtr.Zero : Quotient.__Instance;
                var arg3 = ReferenceEquals(Remainder, null) ? global::System.IntPtr.Zero : Remainder.__Instance;
                Internal.udivrem_0(arg0, arg1, arg2, arg3);
            }

            public static void sdivrem(llvm.APInt LHS, llvm.APInt RHS, llvm.APInt Quotient, llvm.APInt Remainder)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var arg2 = ReferenceEquals(Quotient, null) ? global::System.IntPtr.Zero : Quotient.__Instance;
                var arg3 = ReferenceEquals(Remainder, null) ? global::System.IntPtr.Zero : Remainder.__Instance;
                Internal.sdivrem_0(arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Get the number of words.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the number of words.</para>
            /// <para>  ///</para>
            /// <para>  /// *NOTE* Here one word's bitwidth equals to that of
            /// uint64_t.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the number of words to hold the integer value with
            /// a given bit</para>
            /// <para>  /// width.</para>
            /// </remarks>
            public static uint getNumWords(uint BitWidth)
            {
                var __ret = Internal.getNumWords_1(BitWidth);
                return __ret;
            }

            /// <summary>
            /// <para>Get bits required for string value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get bits required for string value.</para>
            /// <para>  ///</para>
            /// <para>  /// This method determines how many bits are required to hold
            /// the APInt</para>
            /// <para>  /// equivalent of the string given by \p str.</para>
            /// </remarks>
            public static uint getBitsNeeded(llvm.StringRef str, byte radix)
            {
                var arg0 = ReferenceEquals(str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (str.__Instance);
                var arg1 = radix;
                var __ret = Internal.getBitsNeeded_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Converts a double to APInt bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts a double to APInt bits.</para>
            /// <para>  ///</para>
            /// <para>  /// The conversion does not do a translation from double to
            /// integer, it just</para>
            /// <para>  /// re-interprets the bits of the double.</para>
            /// </remarks>
            public static llvm.APInt doubleToBits(double V)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.doubleToBits_0(new IntPtr(&__ret), V);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Converts a float to APInt bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Converts a float to APInt bits.</para>
            /// <para>  ///</para>
            /// <para>  /// The conversion does not do a translation from float to
            /// integer, it just</para>
            /// <para>  /// re-interprets the bits of the float.</para>
            /// </remarks>
            public static llvm.APInt floatToBits(float V)
            {
                var __ret = new llvm.APInt.Internal();
                Internal.floatToBits_0(new IntPtr(&__ret), V);
                return llvm.APInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Sets the least significant part of a bignum to the input value,
            /// and zeroes out higher parts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Sets the least significant part of a bignum to the input
            /// value, and zeroes</para>
            /// <para>  /// out higher parts.</para>
            /// </remarks>
            public static void tcSet(ref ulong _0, ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var arg1 = _1;
                    Internal.tcSet_0(arg0, arg1, _2);
                }
            }

            /// <summary>
            /// <para>Assign one bignum to another.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Assign one bignum to another.</para>
            /// </remarks>
            public static void tcAssign(ref ulong _0, ref ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        Internal.tcAssign_0(arg0, arg1, _2);
                    }
                }
            }

            /// <summary>
            /// <para>Returns true if a bignum is zero, false otherwise.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if a bignum is zero, false otherwise.</para>
            /// </remarks>
            public static bool tcIsZero(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var __ret = Internal.tcIsZero_0(arg0, _1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Extract the given bit of a bignum; returns 0 or 1.
            /// Zero-based.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Extract the given bit of a bignum; returns 0 or 1.
            /// Zero-based.</para>
            /// </remarks>
            public static int tcExtractBit(ref ulong _0, uint bit)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var __ret = Internal.tcExtractBit_0(arg0, bit);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Copy the bit vector of width srcBITS from SRC, starting at bit
            /// srcLSB, to DST, of dstCOUNT parts, such that the bit srcLSB becomes the
            /// least significant bit of DST. All high bits above srcBITS in DST are
            /// zero-filled.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Copy the bit vector of width srcBITS from SRC, starting at
            /// bit srcLSB, to</para>
            /// <para>  /// DST, of dstCOUNT parts, such that the bit srcLSB becomes
            /// the least</para>
            /// <para>  /// significant bit of DST.  All high bits above srcBITS in DST
            /// are</para>
            /// <para>  /// zero-filled.</para>
            /// </remarks>
            public static void tcExtract(ref ulong _0, uint dstCount, ref ulong _1, uint srcBits, uint srcLSB)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg2 = &_1)
                    {
                        Internal.tcExtract_0(arg0, dstCount, arg2, srcBits, srcLSB);
                    }
                }
            }

            /// <summary>
            /// <para>Set the given bit of a bignum. Zero-based.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Set the given bit of a bignum.  Zero-based.</para>
            /// </remarks>
            public static void tcSetBit(ref ulong _0, uint bit)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcSetBit_0(arg0, bit);
                }
            }

            /// <summary>
            /// <para>Clear the given bit of a bignum. Zero-based.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Clear the given bit of a bignum.  Zero-based.</para>
            /// </remarks>
            public static void tcClearBit(ref ulong _0, uint bit)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcClearBit_0(arg0, bit);
                }
            }

            /// <summary>
            /// <para>Returns the bit number of the least or most significant set bit
            /// of a number. If the input number has no bits set -1U is returned.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns the bit number of the least or most significant set
            /// bit of a</para>
            /// <para>  /// number.  If the input number has no bits set -1U is
            /// returned.</para>
            /// </remarks>
            public static uint tcLSB(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var __ret = Internal.tcLSB_0(arg0, _1);
                    return __ret;
                }
            }

            public static uint tcMSB(ref ulong parts, uint n)
            {
                fixed (ulong* arg0 = &parts)
                {
                    var __ret = Internal.tcMSB_0(arg0, n);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Negate a bignum in-place.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Negate a bignum in-place.</para>
            /// </remarks>
            public static void tcNegate(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcNegate_0(arg0, _1);
                }
            }

            /// <summary>
            /// <para>DST += RHS + CARRY where CARRY is zero or one. Returns the carry
            /// flag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DST += RHS + CARRY where CARRY is zero or one.  Returns the
            /// carry flag.</para>
            /// </remarks>
            public static ulong tcAdd(ref ulong _0, ref ulong _1, ulong carry, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        var arg2 = carry;
                        var __ret = Internal.tcAdd_0(arg0, arg1, arg2, _2);
                        return __ret;
                    }
                }
            }

            /// <summary>
            /// <para>DST -= RHS + CARRY where CARRY is zero or one. Returns the carry
            /// flag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DST -= RHS + CARRY where CARRY is zero or one. Returns the
            /// carry flag.</para>
            /// </remarks>
            public static ulong tcSubtract(ref ulong _0, ref ulong _1, ulong carry, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        var arg2 = carry;
                        var __ret = Internal.tcSubtract_0(arg0, arg1, arg2, _2);
                        return __ret;
                    }
                }
            }

            /// <summary>
            /// <para>DST += SRC * MULTIPLIER + PART if add is true DST = SRC *
            /// MULTIPLIER + PART if add is false</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DST += SRC * MULTIPLIER + PART   if add is true</para>
            /// <para>  /// DST  = SRC * MULTIPLIER + PART   if add is false</para>
            /// <para>  ///</para>
            /// <para>  /// Requires 0 &lt;= DSTPARTS &lt;= SRCPARTS + 1.  If DST
            /// overlaps SRC they must</para>
            /// <para>  /// start at the same point, i.e. DST == SRC.</para>
            /// <para>  ///</para>
            /// <para>  /// If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is
            /// returned.</para>
            /// <para>  /// Otherwise DST is filled with the least significant DSTPARTS
            /// parts of the</para>
            /// <para>  /// result, and if all of the omitted higher parts were zero
            /// return zero,</para>
            /// <para>  /// otherwise overflow occurred and return one.</para>
            /// </remarks>
            public static int tcMultiplyPart(ref ulong dst, ref ulong src, ulong multiplier, ulong carry, uint srcParts, uint dstParts, bool add)
            {
                fixed (ulong* arg0 = &dst)
                {
                    fixed (ulong* arg1 = &src)
                    {
                        var arg2 = multiplier;
                        var arg3 = carry;
                        var __ret = Internal.tcMultiplyPart_0(arg0, arg1, arg2, arg3, srcParts, dstParts, add);
                        return __ret;
                    }
                }
            }

            /// <summary>
            /// <para>DST = LHS * RHS, where DST has the same width as the operands and
            /// is filled with the least significant parts of the result. Returns one if
            /// overflow occurred, otherwise zero. DST must be disjoint from both
            /// operands.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DST = LHS * RHS, where DST has the same width as the operands
            /// and is</para>
            /// <para>  /// filled with the least significant parts of the result.
            /// Returns one if</para>
            /// <para>  /// overflow occurred, otherwise zero.  DST must be disjoint
            /// from both</para>
            /// <para>  /// operands.</para>
            /// </remarks>
            public static int tcMultiply(ref ulong _0, ref ulong _1, ref ulong _2, uint _3)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        fixed (ulong* arg2 = &_2)
                        {
                            var __ret = Internal.tcMultiply_0(arg0, arg1, arg2, _3);
                            return __ret;
                        }
                    }
                }
            }

            /// <summary>
            /// <para>DST = LHS * RHS, where DST has width the sum of the widths of the
            /// operands. No overflow occurs. DST must be disjoint from both operands.
            /// Returns the number of parts required to hold the result.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DST = LHS * RHS, where DST has width the sum of the widths of
            /// the</para>
            /// <para>  /// operands.  No overflow occurs.  DST must be disjoint from
            /// both</para>
            /// <para>  /// operands. Returns the number of parts required to hold the
            /// result.</para>
            /// </remarks>
            public static uint tcFullMultiply(ref ulong _0, ref ulong _1, ref ulong _2, uint _3, uint _4)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        fixed (ulong* arg2 = &_2)
                        {
                            var __ret = Internal.tcFullMultiply_0(arg0, arg1, arg2, _3, _4);
                            return __ret;
                        }
                    }
                }
            }

            /// <summary>
            /// <para>If RHS is zero LHS and REMAINDER are left unchanged, return one.
            /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set
            /// REMAINDER to the remainder, return zero. i.e.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If RHS is zero LHS and REMAINDER are left unchanged, return
            /// one.</para>
            /// <para>  /// Otherwise set LHS to LHS / RHS with the fractional part
            /// discarded, set</para>
            /// <para>  /// REMAINDER to the remainder, return zero.  i.e.</para>
            /// <para>  ///</para>
            /// <para>  ///  OLD_LHS = RHS * LHS + REMAINDER</para>
            /// <para>  ///</para>
            /// <para>  /// SCRATCH is a bignum of the same size as the operands and
            /// result for use by</para>
            /// <para>  /// the routine; its contents need not be initialized and are
            /// destroyed.  LHS,</para>
            /// <para>  /// REMAINDER and SCRATCH must be distinct.</para>
            /// </remarks>
            public static int tcDivide(ref ulong lhs, ref ulong rhs, ref ulong remainder, ref ulong scratch, uint parts)
            {
                fixed (ulong* arg0 = &lhs)
                {
                    fixed (ulong* arg1 = &rhs)
                    {
                        fixed (ulong* arg2 = &remainder)
                        {
                            fixed (ulong* arg3 = &scratch)
                            {
                                var __ret = Internal.tcDivide_0(arg0, arg1, arg2, arg3, parts);
                                return __ret;
                            }
                        }
                    }
                }
            }

            /// <summary>
            /// <para>Shift a bignum left COUNT bits. Shifted in bits are zero. There
            /// are no restrictions on COUNT.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Shift a bignum left COUNT bits.  Shifted in bits are zero.
            /// There are no</para>
            /// <para>  /// restrictions on COUNT.</para>
            /// </remarks>
            public static void tcShiftLeft(ref ulong _0, uint parts, uint count)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcShiftLeft_0(arg0, parts, count);
                }
            }

            /// <summary>
            /// <para>Shift a bignum right COUNT bits. Shifted in bits are zero. There
            /// are no restrictions on COUNT.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Shift a bignum right COUNT bits.  Shifted in bits are zero.
            /// There are no</para>
            /// <para>  /// restrictions on COUNT.</para>
            /// </remarks>
            public static void tcShiftRight(ref ulong _0, uint parts, uint count)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcShiftRight_0(arg0, parts, count);
                }
            }

            /// <summary>
            /// <para>The obvious AND, OR and XOR and complement operations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The obvious AND, OR and XOR and complement operations.</para>
            /// </remarks>
            public static void tcAnd(ref ulong _0, ref ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        Internal.tcAnd_0(arg0, arg1, _2);
                    }
                }
            }

            public static void tcOr(ref ulong _0, ref ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        Internal.tcOr_0(arg0, arg1, _2);
                    }
                }
            }

            public static void tcXor(ref ulong _0, ref ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        Internal.tcXor_0(arg0, arg1, _2);
                    }
                }
            }

            public static void tcComplement(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcComplement_0(arg0, _1);
                }
            }

            /// <summary>
            /// <para>Comparison (unsigned) of two bignums.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Comparison (unsigned) of two bignums.</para>
            /// </remarks>
            public static int tcCompare(ref ulong _0, ref ulong _1, uint _2)
            {
                fixed (ulong* arg0 = &_0)
                {
                    fixed (ulong* arg1 = &_1)
                    {
                        var __ret = Internal.tcCompare_0(arg0, arg1, _2);
                        return __ret;
                    }
                }
            }

            /// <summary>
            /// <para>Increment a bignum in-place. Return the carry flag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Increment a bignum in-place.  Return the carry flag.</para>
            /// </remarks>
            public static ulong tcIncrement(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var __ret = Internal.tcIncrement_0(arg0, _1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Decrement a bignum in-place. Return the borrow flag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Decrement a bignum in-place.  Return the borrow flag.</para>
            /// </remarks>
            public static ulong tcDecrement(ref ulong _0, uint _1)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var __ret = Internal.tcDecrement_0(arg0, _1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Set the least significant BITS and clear the rest.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Set the least significant BITS and clear the rest.</para>
            /// </remarks>
            public static void tcSetLeastSignificantBits(ref ulong _0, uint _1, uint bits)
            {
                fixed (ulong* arg0 = &_0)
                {
                    Internal.tcSetLeastSignificantBits_0(arg0, _1, bits);
                }
            }

            public static bool operator ==(ulong V1, llvm.APInt V2)
            {
                bool V1Null = ReferenceEquals(V1, null);
                bool V2Null = ReferenceEquals(V2, null);
                if (V1Null || V2Null)
                    return V1Null && V2Null;
                var arg0 = V1;
                var arg1 = V2.__Instance;
                var __ret = Internal.OperatorEqualEqual_2(arg0, arg1);
                return __ret;
            }

            public static bool operator !=(ulong V1, llvm.APInt V2)
            {
                var arg0 = V1;
                var arg1 = ReferenceEquals(V2, null) ? global::System.IntPtr.Zero : V2.__Instance;
                var __ret = Internal.OperatorExclaimEqual_2(arg0, arg1);
                return __ret;
            }

            public bool this[uint bitPosition]
            {
                get
                {
                    var __ret = Internal.OperatorSubscript_0(__Instance, bitPosition);
                    return __ret;
                }
            }
        }

        public unsafe partial class APInt
        {
            public partial struct Internal
            {
            }
        }

        namespace APIntOps
        {
            public unsafe partial class APInt
            {
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4sminERKNS_5APIntES3_")]
                    internal static extern void smin_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4smaxERKNS_5APIntES3_")]
                    internal static extern void smax_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4uminERKNS_5APIntES3_")]
                    internal static extern void umin_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4umaxERKNS_5APIntES3_")]
                    internal static extern void umax_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps6isIntNEjRKNS_5APIntE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isIntN_0(uint N, global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps12isSignedIntNEjRKNS_5APIntE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isSignedIntN_0(uint N, global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps6isMaskEjRKNS_5APIntE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isMask_0(uint numBits, global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps13isShiftedMaskEjRKNS_5APIntE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isShiftedMask_0(uint numBits, global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps8byteSwapERKNS_5APIntE")]
                    internal static extern void byteSwap_0(global::System.IntPtr @return, global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps8logBase2ERKNS_5APIntE")]
                    internal static extern uint logBase2_0(global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps21GreatestCommonDivisorERKNS_5APIntES3_")]
                    internal static extern void GreatestCommonDivisor_0(global::System.IntPtr @return, global::System.IntPtr Val1, global::System.IntPtr Val2);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps18RoundAPIntToDoubleERKNS_5APIntE")]
                    internal static extern double RoundAPIntToDouble_0(global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps24RoundSignedAPIntToDoubleERKNS_5APIntE")]
                    internal static extern double RoundSignedAPIntToDouble_0(global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps17RoundAPIntToFloatERKNS_5APIntE")]
                    internal static extern float RoundAPIntToFloat_0(global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps23RoundSignedAPIntToFloatERKNS_5APIntE")]
                    internal static extern float RoundSignedAPIntToFloat_0(global::System.IntPtr APIVal);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps18RoundDoubleToAPIntEdj")]
                    internal static extern void RoundDoubleToAPInt_0(global::System.IntPtr @return, double Double, uint width);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps17RoundFloatToAPIntEfj")]
                    internal static extern void RoundFloatToAPInt_0(global::System.IntPtr @return, float Float, uint width);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4ashrERKNS_5APIntEj")]
                    internal static extern void ashr_0(global::System.IntPtr @return, global::System.IntPtr LHS, uint shiftAmt);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4lshrERKNS_5APIntEj")]
                    internal static extern void lshr_0(global::System.IntPtr @return, global::System.IntPtr LHS, uint shiftAmt);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3shlERKNS_5APIntEj")]
                    internal static extern void shl_0(global::System.IntPtr @return, global::System.IntPtr LHS, uint shiftAmt);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4sdivERKNS_5APIntES3_")]
                    internal static extern void sdiv_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4udivERKNS_5APIntES3_")]
                    internal static extern void udiv_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4sremERKNS_5APIntES3_")]
                    internal static extern void srem_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps4uremERKNS_5APIntES3_")]
                    internal static extern void urem_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3mulERKNS_5APIntES3_")]
                    internal static extern void mul_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3addERKNS_5APIntES3_")]
                    internal static extern void add_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3subERKNS_5APIntES3_")]
                    internal static extern void sub_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3AndERKNS_5APIntES3_")]
                    internal static extern void And_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps2OrERKNS_5APIntES3_")]
                    internal static extern void Or_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3XorERKNS_5APIntES3_")]
                    internal static extern void Xor_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm8APIntOps3NotERKNS_5APIntE")]
                    internal static extern void Not_0(global::System.IntPtr @return, global::System.IntPtr APIVal);
                }

                /// <summary>
                /// <para>Determine the smaller of two APInts considered to be
                /// signed.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine the smaller of two APInts considered to be
                /// signed.</para>
                /// </remarks>
                public static llvm.APInt smin(llvm.APInt A, llvm.APInt B)
                {
                    var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                    var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.smin_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Determine the larger of two APInts considered to be
                /// signed.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine the larger of two APInts considered to be
                /// signed.</para>
                /// </remarks>
                public static llvm.APInt smax(llvm.APInt A, llvm.APInt B)
                {
                    var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                    var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.smax_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Determine the smaller of two APInts considered to be
                /// signed.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine the smaller of two APInts considered to be
                /// signed.</para>
                /// </remarks>
                public static llvm.APInt umin(llvm.APInt A, llvm.APInt B)
                {
                    var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                    var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.umin_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Determine the larger of two APInts considered to be
                /// unsigned.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine the larger of two APInts considered to be
                /// unsigned.</para>
                /// </remarks>
                public static llvm.APInt umax(llvm.APInt A, llvm.APInt B)
                {
                    var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                    var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.umax_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Check if the specified APInt has a N-bits unsigned integer
                /// value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Check if the specified APInt has a N-bits unsigned
                /// integer value.</para>
                /// </remarks>
                public static bool isIntN(uint N, llvm.APInt APIVal)
                {
                    var arg1 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.isIntN_0(N, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>Check if the specified APInt has a N-bits signed integer
                /// value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Check if the specified APInt has a N-bits signed
                /// integer value.</para>
                /// </remarks>
                public static bool isSignedIntN(uint N, llvm.APInt APIVal)
                {
                    var arg1 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.isSignedIntN_0(N, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns true if the argument APInt value is a sequence of ones
                /// starting at the least significant bit with the remainder zero.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \returns true if the argument APInt value is a sequence of
                /// ones starting at</para>
                /// <para>/// the least significant bit with the remainder zero.</para>
                /// </remarks>
                public static bool isMask(uint numBits, llvm.APInt APIVal)
                {
                    var arg1 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.isMask_0(numBits, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>Return true if the argument APInt value contains a sequence of
                /// ones with the remainder zero.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if the argument APInt value contains a
                /// sequence of ones</para>
                /// <para>/// with the remainder zero.</para>
                /// </remarks>
                public static bool isShiftedMask(uint numBits, llvm.APInt APIVal)
                {
                    var arg1 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.isShiftedMask_0(numBits, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns a byte-swapped representation of the specified APInt
                /// Value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns a byte-swapped representation of the specified
                /// APInt Value.</para>
                /// </remarks>
                public static llvm.APInt byteSwap(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.byteSwap_0(new IntPtr(&__ret), arg0);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Returns the floor log base 2 of the specified APInt value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns the floor log base 2 of the specified APInt
                /// value.</para>
                /// </remarks>
                public static uint logBase2(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.logBase2_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Compute GCD of two APInt values.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Compute GCD of two APInt values.</para>
                /// <para>///</para>
                /// <para>/// This function returns the greatest common divisor of the two
                /// APInt values</para>
                /// <para>/// using Euclid's algorithm.</para>
                /// <para>///</para>
                /// <para>/// \returns the greatest common divisor of Val1 and Val2</para>
                /// </remarks>
                public static llvm.APInt GreatestCommonDivisor(llvm.APInt Val1, llvm.APInt Val2)
                {
                    var arg0 = ReferenceEquals(Val1, null) ? global::System.IntPtr.Zero : Val1.__Instance;
                    var arg1 = ReferenceEquals(Val2, null) ? global::System.IntPtr.Zero : Val2.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.GreatestCommonDivisor_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Converts the given APInt to a double value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts the given APInt to a double value.</para>
                /// <para>///</para>
                /// <para>/// Treats the APInt as an unsigned value for conversion
                /// purposes.</para>
                /// </remarks>
                public static double RoundAPIntToDouble(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.RoundAPIntToDouble_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Converts the given APInt to a double value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts the given APInt to a double value.</para>
                /// <para>///</para>
                /// <para>/// Treats the APInt as a signed value for conversion
                /// purposes.</para>
                /// </remarks>
                public static double RoundSignedAPIntToDouble(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.RoundSignedAPIntToDouble_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Converts the given APInt to a float vlalue.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts the given APInt to a float vlalue.</para>
                /// </remarks>
                public static float RoundAPIntToFloat(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.RoundAPIntToFloat_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Converts the given APInt to a float value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts the given APInt to a float value.</para>
                /// <para>///</para>
                /// <para>/// Treast the APInt as a signed value for conversion
                /// purposes.</para>
                /// </remarks>
                public static float RoundSignedAPIntToFloat(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = Internal.RoundSignedAPIntToFloat_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Converts the given double value into a APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts the given double value into a APInt.</para>
                /// <para>///</para>
                /// <para>/// This function convert a double value to an APInt
                /// value.</para>
                /// </remarks>
                public static llvm.APInt RoundDoubleToAPInt(double Double, uint width)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.RoundDoubleToAPInt_0(new IntPtr(&__ret), Double, width);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Converts a float value into a APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converts a float value into a APInt.</para>
                /// <para>///</para>
                /// <para>/// Converts a float value into an APInt value.</para>
                /// </remarks>
                public static llvm.APInt RoundFloatToAPInt(float Float, uint width)
                {
                    var __ret = new llvm.APInt.Internal();
                    Internal.RoundFloatToAPInt_0(new IntPtr(&__ret), Float, width);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Arithmetic right-shift function.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Arithmetic right-shift function.</para>
                /// <para>///</para>
                /// <para>/// Arithmetic right-shift the APInt by shiftAmt.</para>
                /// </remarks>
                public static llvm.APInt ashr(llvm.APInt LHS, uint shiftAmt)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.ashr_0(new IntPtr(&__ret), arg0, shiftAmt);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Logical right-shift function.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Logical right-shift function.</para>
                /// <para>///</para>
                /// <para>/// Logical right-shift the APInt by shiftAmt.</para>
                /// </remarks>
                public static llvm.APInt lshr(llvm.APInt LHS, uint shiftAmt)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.lshr_0(new IntPtr(&__ret), arg0, shiftAmt);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Left-shift function.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Left-shift function.</para>
                /// <para>///</para>
                /// <para>/// Left-shift the APInt by shiftAmt.</para>
                /// </remarks>
                public static llvm.APInt shl(llvm.APInt LHS, uint shiftAmt)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.shl_0(new IntPtr(&__ret), arg0, shiftAmt);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Signed division function for APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Signed division function for APInt.</para>
                /// <para>///</para>
                /// <para>/// Signed divide APInt LHS by APInt RHS.</para>
                /// </remarks>
                public static llvm.APInt sdiv(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.sdiv_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Unsigned division function for APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Unsigned division function for APInt.</para>
                /// <para>///</para>
                /// <para>/// Unsigned divide APInt LHS by APInt RHS.</para>
                /// </remarks>
                public static llvm.APInt udiv(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.udiv_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Function for signed remainder operation.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Function for signed remainder operation.</para>
                /// <para>///</para>
                /// <para>/// Signed remainder operation on APInt.</para>
                /// </remarks>
                public static llvm.APInt srem(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.srem_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Function for unsigned remainder operation.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Function for unsigned remainder operation.</para>
                /// <para>///</para>
                /// <para>/// Unsigned remainder operation on APInt.</para>
                /// </remarks>
                public static llvm.APInt urem(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.urem_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Function for multiplication operation.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Function for multiplication operation.</para>
                /// <para>///</para>
                /// <para>/// Performs multiplication on APInt values.</para>
                /// </remarks>
                public static llvm.APInt mul(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.mul_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Function for addition operation.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Function for addition operation.</para>
                /// <para>///</para>
                /// <para>/// Performs addition on APInt values.</para>
                /// </remarks>
                public static llvm.APInt add(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.add_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Function for subtraction operation.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Function for subtraction operation.</para>
                /// <para>///</para>
                /// <para>/// Performs subtraction on APInt values.</para>
                /// </remarks>
                public static llvm.APInt sub(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.sub_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Bitwise AND function for APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Bitwise AND function for APInt.</para>
                /// <para>///</para>
                /// <para>/// Performs bitwise AND operation on APInt LHS and</para>
                /// <para>/// APInt RHS.</para>
                /// </remarks>
                public static llvm.APInt And(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.And_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Bitwise OR function for APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Bitwise OR function for APInt.</para>
                /// <para>///</para>
                /// <para>/// Performs bitwise OR operation on APInt LHS and APInt
                /// RHS.</para>
                /// </remarks>
                public static llvm.APInt Or(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.Or_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Bitwise XOR function for APInt.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Bitwise XOR function for APInt.</para>
                /// <para>///</para>
                /// <para>/// Performs bitwise XOR operation on APInt.</para>
                /// </remarks>
                public static llvm.APInt Xor(llvm.APInt LHS, llvm.APInt RHS)
                {
                    var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.Xor_0(new IntPtr(&__ret), arg0, arg1);
                    return llvm.APInt.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Bitwise complement function.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Bitwise complement function.</para>
                /// <para>///</para>
                /// <para>/// Performs a bitwise complement operation on APInt.</para>
                /// </remarks>
                public static llvm.APInt Not(llvm.APInt APIVal)
                {
                    var arg0 = ReferenceEquals(APIVal, null) ? global::System.IntPtr.Zero : APIVal.__Instance;
                    var __ret = new llvm.APInt.Internal();
                    Internal.Not_0(new IntPtr(&__ret), arg0);
                    return llvm.APInt.__CreateInstance(__ret);
                }
            }
        }
    }
}
