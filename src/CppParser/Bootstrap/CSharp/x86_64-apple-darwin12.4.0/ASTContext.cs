//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class ASTContext
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        public unsafe partial class TypeInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public ulong Width;

                [FieldOffset(8)]
                public uint Align;

                [FieldOffset(12)]
                public bool AlignIsRequired;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeInfoC2Eyjb")]
                internal static extern void ctor_1(global::System.IntPtr instance, ulong Width, uint Align, bool AlignIsRequired);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeInfoC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeInfo>();

            private readonly bool __ownsNativeInstance;

            public static TypeInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeInfo((TypeInfo.Internal*) native);
            }

            public static TypeInfo __CreateInstance(TypeInfo.Internal native)
            {
                return new TypeInfo(native);
            }

            private static TypeInfo.Internal* __CopyValue(TypeInfo.Internal native)
            {
                var ret = (TypeInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private TypeInfo(TypeInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeInfo(TypeInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public TypeInfo(ulong Width, uint Align, bool AlignIsRequired)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Width;
                Internal.ctor_1(__Instance, arg0, Align, AlignIsRequired);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public ulong Width
            {
                get
                {
                    return ((Internal*) __Instance)->Width;
                }

                set
                {
                    ((Internal*) __Instance)->Width = value;
                }
            }

            public uint Align
            {
                get
                {
                    return ((Internal*) __Instance)->Align;
                }

                set
                {
                    ((Internal*) __Instance)->Align = value;
                }
            }

            public bool AlignIsRequired
            {
                get
                {
                    return ((Internal*) __Instance)->AlignIsRequired;
                }

                set
                {
                    ((Internal*) __Instance)->AlignIsRequired = value;
                }
            }
        }

        /// <summary>
        /// <para>Holds long-lived AST nodes (such as types and decls) that can be
        /// referred to throughout the semantic analysis of a file.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Holds long-lived AST nodes (such as types and decls)
        /// that can be</para>
        /// <para>/// referred to throughout the semantic analysis of a
        /// file.</para>
        /// </remarks>
        public unsafe partial class ASTContext : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16696)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.SmallVector.Internal Types;

                [FieldOffset(48)]
                internal llvm.FoldingSet.Internal ExtQualNodes;

                [FieldOffset(72)]
                internal llvm.FoldingSet.Internal ComplexTypes;

                [FieldOffset(96)]
                internal llvm.FoldingSet.Internal PointerTypes;

                [FieldOffset(120)]
                internal llvm.FoldingSet.Internal AdjustedTypes;

                [FieldOffset(144)]
                internal llvm.FoldingSet.Internal BlockPointerTypes;

                [FieldOffset(168)]
                internal llvm.FoldingSet.Internal LValueReferenceTypes;

                [FieldOffset(192)]
                internal llvm.FoldingSet.Internal RValueReferenceTypes;

                [FieldOffset(216)]
                internal llvm.FoldingSet.Internal MemberPointerTypes;

                [FieldOffset(240)]
                internal llvm.FoldingSet.Internal ConstantArrayTypes;

                [FieldOffset(264)]
                internal llvm.FoldingSet.Internal IncompleteArrayTypes;

                [FieldOffset(312)]
                internal llvm.FoldingSet.Internal DependentSizedArrayTypes;

                [FieldOffset(336)]
                internal llvm.FoldingSet.Internal DependentSizedExtVectorTypes;

                [FieldOffset(360)]
                internal llvm.FoldingSet.Internal VectorTypes;

                [FieldOffset(384)]
                internal llvm.FoldingSet.Internal FunctionNoProtoTypes;

                [FieldOffset(408)]
                internal llvm.ContextualFoldingSet.Internal FunctionProtoTypes;

                [FieldOffset(440)]
                internal llvm.FoldingSet.Internal DependentTypeOfExprTypes;

                [FieldOffset(464)]
                internal llvm.FoldingSet.Internal DependentDecltypeTypes;

                [FieldOffset(488)]
                internal llvm.FoldingSet.Internal TemplateTypeParmTypes;

                [FieldOffset(512)]
                internal llvm.FoldingSet.Internal SubstTemplateTypeParmTypes;

                [FieldOffset(536)]
                internal llvm.FoldingSet.Internal SubstTemplateTypeParmPackTypes;

                [FieldOffset(560)]
                internal llvm.ContextualFoldingSet.Internal TemplateSpecializationTypes;

                [FieldOffset(592)]
                internal llvm.FoldingSet.Internal ParenTypes;

                [FieldOffset(616)]
                internal llvm.FoldingSet.Internal ElaboratedTypes;

                [FieldOffset(640)]
                internal llvm.FoldingSet.Internal DependentNameTypes;

                [FieldOffset(664)]
                internal llvm.ContextualFoldingSet.Internal DependentTemplateSpecializationTypes;

                [FieldOffset(696)]
                internal llvm.FoldingSet.Internal PackExpansionTypes;

                [FieldOffset(720)]
                internal llvm.FoldingSet.Internal ObjCObjectTypes;

                [FieldOffset(744)]
                internal llvm.FoldingSet.Internal ObjCObjectPointerTypes;

                [FieldOffset(768)]
                internal llvm.FoldingSet.Internal AutoTypes;

                [FieldOffset(792)]
                internal llvm.FoldingSet.Internal AtomicTypes;

                [FieldOffset(816)]
                internal llvm.FoldingSet.Internal AttributedTypes;

                [FieldOffset(840)]
                internal llvm.FoldingSet.Internal QualifiedTemplateNames;

                [FieldOffset(864)]
                internal llvm.FoldingSet.Internal DependentTemplateNames;

                [FieldOffset(888)]
                internal llvm.FoldingSet.Internal SubstTemplateTemplateParms;

                [FieldOffset(912)]
                internal llvm.ContextualFoldingSet.Internal SubstTemplateTemplateParmPacks;

                [FieldOffset(944)]
                internal llvm.FoldingSet.Internal NestedNameSpecifiers;

                [FieldOffset(968)]
                public global::System.IntPtr GlobalNestedNameSpecifier;

                [FieldOffset(976)]
                internal llvm.DenseMap.Internal ASTRecordLayouts;

                [FieldOffset(1000)]
                internal llvm.DenseMap.Internal ObjCLayouts;

                [FieldOffset(1024)]
                internal llvm.DenseMap.Internal MemoizedTypeInfo;

                [FieldOffset(1048)]
                internal llvm.DenseMap.Internal KeyFunctions;

                [FieldOffset(1072)]
                internal llvm.DenseMap.Internal ObjCImpls;

                [FieldOffset(1096)]
                internal llvm.DenseMap.Internal ObjCMethodRedecls;

                [FieldOffset(1120)]
                internal llvm.DenseMap.Internal BlockVarCopyInits;

                [FieldOffset(1144)]
                internal llvm.DenseMap.Internal ClassScopeSpecializationPattern;

                [FieldOffset(1168)]
                internal llvm.DenseMap.Internal MaterializedTemporaryValues;

                [FieldOffset(1192)]
                internal llvm.FoldingSet.Internal CanonTemplateTemplateParms;

                [FieldOffset(1216)]
                public global::System.IntPtr Int128Decl;

                [FieldOffset(1224)]
                public global::System.IntPtr UInt128Decl;

                [FieldOffset(1232)]
                public global::System.IntPtr Float128StubDecl;

                [FieldOffset(1240)]
                public global::System.IntPtr BuiltinVaListDecl;

                [FieldOffset(1248)]
                public global::System.IntPtr ObjCIdDecl;

                [FieldOffset(1256)]
                public global::System.IntPtr ObjCSelDecl;

                [FieldOffset(1264)]
                public global::System.IntPtr ObjCClassDecl;

                [FieldOffset(1272)]
                public global::System.IntPtr ObjCProtocolClassDecl;

                [FieldOffset(1280)]
                public global::System.IntPtr BOOLDecl;

                [FieldOffset(1288)]
                public clang.QualType.Internal ObjCIdRedefinitionType;

                [FieldOffset(1296)]
                public clang.QualType.Internal ObjCClassRedefinitionType;

                [FieldOffset(1304)]
                public clang.QualType.Internal ObjCSelRedefinitionType;

                [FieldOffset(1312)]
                public clang.QualType.Internal ObjCConstantStringType;

                [FieldOffset(1320)]
                public global::System.IntPtr CFConstantStringTypeDecl;

                [FieldOffset(1328)]
                public clang.QualType.Internal ObjCSuperType;

                [FieldOffset(1336)]
                public clang.QualType.Internal ObjCNSStringType;

                [FieldOffset(1344)]
                public global::System.IntPtr ObjCInstanceTypeDecl;

                [FieldOffset(1352)]
                public global::System.IntPtr FILEDecl;

                [FieldOffset(1360)]
                public global::System.IntPtr jmp_bufDecl;

                [FieldOffset(1368)]
                public global::System.IntPtr sigjmp_bufDecl;

                [FieldOffset(1376)]
                public global::System.IntPtr ucontext_tDecl;

                [FieldOffset(1384)]
                public global::System.IntPtr BlockDescriptorType;

                [FieldOffset(1392)]
                public global::System.IntPtr BlockDescriptorExtendedType;

                [FieldOffset(1400)]
                public global::System.IntPtr cudaConfigureCallDecl;

                [FieldOffset(1408)]
                internal llvm.DenseMap.Internal DeclAttrs;

                [FieldOffset(1432)]
                internal llvm.DenseMap.Internal MergedDecls;

                [FieldOffset(1456)]
                internal llvm.DenseMap.Internal TemplateOrInstantiation;

                [FieldOffset(1480)]
                internal llvm.DenseMap.Internal InstantiatedFromUsingDecl;

                [FieldOffset(1504)]
                internal llvm.DenseMap.Internal InstantiatedFromUsingShadowDecl;

                [FieldOffset(1528)]
                internal llvm.DenseMap.Internal InstantiatedFromUnnamedFieldDecl;

                [FieldOffset(1552)]
                internal llvm.DenseMap.Internal OverriddenMethods;

                [FieldOffset(1576)]
                internal llvm.DenseMap.Internal MangleNumberingContexts;

                [FieldOffset(1600)]
                internal llvm.DenseMap.Internal MangleNumbers;

                [FieldOffset(1624)]
                internal llvm.DenseMap.Internal StaticLocalNumbers;

                [FieldOffset(1648)]
                internal llvm.DenseMap.Internal ParamIndices;

                [FieldOffset(1672)]
                public global::System.IntPtr FirstLocalImport;

                [FieldOffset(1680)]
                public global::System.IntPtr LastLocalImport;

                [FieldOffset(1688)]
                public global::System.IntPtr TUDecl;

                [FieldOffset(1696)]
                public global::System.IntPtr SourceMgr;

                [FieldOffset(1704)]
                public global::System.IntPtr LangOpts;

                [FieldOffset(1720)]
                internal llvm.BumpPtrAllocatorImpl.Internal BumpAlloc;

                [FieldOffset(1856)]
                public clang.PartialDiagnostic.StorageAllocator.Internal DiagAllocator;

                [FieldOffset(15056)]
                public fixed uint AddrSpaceMap[7];

                [FieldOffset(15064)]
                public bool AddrSpaceMapMangling;

                [FieldOffset(15072)]
                public global::System.IntPtr Target;

                [FieldOffset(15080)]
                public clang.PrintingPolicy.Internal PrintingPolicy;

                [FieldOffset(15352)]
                public global::System.IntPtr Idents;

                [FieldOffset(15360)]
                public global::System.IntPtr Selectors;

                [FieldOffset(15368)]
                public global::System.IntPtr BuiltinInfo;

                [FieldOffset(15376)]
                public clang.DeclarationNameTable.Internal DeclarationNames;

                [FieldOffset(15408)]
                internal llvm.IntrusiveRefCntPtr.Internal ExternalSource;

                [FieldOffset(15416)]
                public global::System.IntPtr Listener;

                [FieldOffset(15424)]
                public clang.RawCommentList.Internal Comments;

                [FieldOffset(15456)]
                public bool CommentsLoaded;

                [FieldOffset(15464)]
                internal llvm.DenseMap.Internal RedeclComments;

                [FieldOffset(15488)]
                internal llvm.DenseMap.Internal ParsedComments;

                [FieldOffset(15512)]
                public clang.comments.CommandTraits.Internal CommentCommandTraits;

                [FieldOffset(15584)]
                public clang.CanQual.Internal VoidTy;

                [FieldOffset(15592)]
                public clang.CanQual.Internal BoolTy;

                [FieldOffset(15600)]
                public clang.CanQual.Internal CharTy;

                [FieldOffset(15608)]
                public clang.CanQual.Internal WCharTy;

                [FieldOffset(15616)]
                public clang.CanQual.Internal WideCharTy;

                [FieldOffset(15624)]
                public clang.CanQual.Internal WIntTy;

                [FieldOffset(15632)]
                public clang.CanQual.Internal Char16Ty;

                [FieldOffset(15640)]
                public clang.CanQual.Internal Char32Ty;

                [FieldOffset(15648)]
                public clang.CanQual.Internal SignedCharTy;

                [FieldOffset(15656)]
                public clang.CanQual.Internal ShortTy;

                [FieldOffset(15664)]
                public clang.CanQual.Internal IntTy;

                [FieldOffset(15672)]
                public clang.CanQual.Internal LongTy;

                [FieldOffset(15680)]
                public clang.CanQual.Internal LongLongTy;

                [FieldOffset(15688)]
                public clang.CanQual.Internal Int128Ty;

                [FieldOffset(15696)]
                public clang.CanQual.Internal UnsignedCharTy;

                [FieldOffset(15704)]
                public clang.CanQual.Internal UnsignedShortTy;

                [FieldOffset(15712)]
                public clang.CanQual.Internal UnsignedIntTy;

                [FieldOffset(15720)]
                public clang.CanQual.Internal UnsignedLongTy;

                [FieldOffset(15728)]
                public clang.CanQual.Internal UnsignedLongLongTy;

                [FieldOffset(15736)]
                public clang.CanQual.Internal UnsignedInt128Ty;

                [FieldOffset(15744)]
                public clang.CanQual.Internal FloatTy;

                [FieldOffset(15752)]
                public clang.CanQual.Internal DoubleTy;

                [FieldOffset(15760)]
                public clang.CanQual.Internal LongDoubleTy;

                [FieldOffset(15768)]
                public clang.CanQual.Internal HalfTy;

                [FieldOffset(15776)]
                public clang.CanQual.Internal FloatComplexTy;

                [FieldOffset(15784)]
                public clang.CanQual.Internal DoubleComplexTy;

                [FieldOffset(15792)]
                public clang.CanQual.Internal LongDoubleComplexTy;

                [FieldOffset(15800)]
                public clang.CanQual.Internal VoidPtrTy;

                [FieldOffset(15808)]
                public clang.CanQual.Internal NullPtrTy;

                [FieldOffset(15816)]
                public clang.CanQual.Internal DependentTy;

                [FieldOffset(15824)]
                public clang.CanQual.Internal OverloadTy;

                [FieldOffset(15832)]
                public clang.CanQual.Internal BoundMemberTy;

                [FieldOffset(15840)]
                public clang.CanQual.Internal UnknownAnyTy;

                [FieldOffset(15848)]
                public clang.CanQual.Internal BuiltinFnTy;

                [FieldOffset(15856)]
                public clang.CanQual.Internal PseudoObjectTy;

                [FieldOffset(15864)]
                public clang.CanQual.Internal ARCUnbridgedCastTy;

                [FieldOffset(15872)]
                public clang.CanQual.Internal ObjCBuiltinIdTy;

                [FieldOffset(15880)]
                public clang.CanQual.Internal ObjCBuiltinClassTy;

                [FieldOffset(15888)]
                public clang.CanQual.Internal ObjCBuiltinSelTy;

                [FieldOffset(15896)]
                public clang.CanQual.Internal ObjCBuiltinBoolTy;

                [FieldOffset(15904)]
                public clang.CanQual.Internal OCLImage1dTy;

                [FieldOffset(15912)]
                public clang.CanQual.Internal OCLImage1dArrayTy;

                [FieldOffset(15920)]
                public clang.CanQual.Internal OCLImage1dBufferTy;

                [FieldOffset(15928)]
                public clang.CanQual.Internal OCLImage2dTy;

                [FieldOffset(15936)]
                public clang.CanQual.Internal OCLImage2dArrayTy;

                [FieldOffset(15944)]
                public clang.CanQual.Internal OCLImage3dTy;

                [FieldOffset(15952)]
                public clang.CanQual.Internal OCLSamplerTy;

                [FieldOffset(15960)]
                public clang.CanQual.Internal OCLEventTy;

                [FieldOffset(15968)]
                public clang.QualType.Internal AutoDeductTy;

                [FieldOffset(15976)]
                public clang.QualType.Internal AutoRRefDeductTy;

                [FieldOffset(15984)]
                public clang.QualType.Internal VaListTagTy;

                [FieldOffset(15992)]
                internal llvm.SmallDenseMap.Internal Deallocations;

                [FieldOffset(16640)]
                internal llvm.PointerIntPair.Internal LastSDM;

                [FieldOffset(16664)]
                internal llvm.StringMap.Internal SectionInfos;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContextD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getPrintingPolicyEv")]
                internal static extern global::System.IntPtr getPrintingPolicy_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17setPrintingPolicyERKNS_14PrintingPolicyE")]
                internal static extern void setPrintingPolicy_0(global::System.IntPtr instance, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext16getSourceManagerEv")]
                internal static extern global::System.IntPtr getSourceManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext8AllocateEmj")]
                internal static extern global::System.IntPtr Allocate_0(global::System.IntPtr instance, ulong Size, uint Align);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext10DeallocateEPv")]
                internal static extern void Deallocate_0(global::System.IntPtr instance, global::System.IntPtr Ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getASTAllocatedMemoryEv")]
                internal static extern ulong getASTAllocatedMemory_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext27getSideTableAllocatedMemoryEv")]
                internal static extern ulong getSideTableAllocatedMemory_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext16getDiagAllocatorEv")]
                internal static extern global::System.IntPtr getDiagAllocator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getIntTypeForBitwidthEjj")]
                internal static extern clang.QualType.Internal getIntTypeForBitwidth_0(global::System.IntPtr instance, uint DestWidth, uint Signed);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getRealTypeForBitwidthEj")]
                internal static extern clang.QualType.Internal getRealTypeForBitwidth_0(global::System.IntPtr instance, uint DestWidth);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getLangOptsEv")]
                internal static extern global::System.IntPtr getLangOpts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getSanitizerBlacklistEv")]
                internal static extern global::System.IntPtr getSanitizerBlacklist_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getDiagnosticsEv")]
                internal static extern global::System.IntPtr getDiagnostics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext10getFullLocENS_14SourceLocationE")]
                internal static extern clang.FullSourceLoc.Internal getFullLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext27getRawCommentForDeclNoCacheEPKNS_4DeclE")]
                internal static extern global::System.IntPtr getRawCommentForDeclNoCache_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17getRawCommentListEv")]
                internal static extern global::System.IntPtr getRawCommentList_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext10addCommentERKNS_10RawCommentE")]
                internal static extern void addComment_0(global::System.IntPtr instance, global::System.IntPtr RC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext25getRawCommentForAnyRedeclEPKNS_4DeclEPS3_")]
                internal static extern global::System.IntPtr getRawCommentForAnyRedecl_0(global::System.IntPtr instance, global::System.IntPtr D, global::System.IntPtr OriginalDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext23getCommentCommandTraitsEv")]
                internal static extern global::System.IntPtr getCommentCommandTraits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext14eraseDeclAttrsEPKNS_4DeclE")]
                internal static extern void eraseDeclAttrs_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext34getClassScopeSpecializationPatternEPKNS_12FunctionDeclE")]
                internal static extern global::System.IntPtr getClassScopeSpecializationPattern_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext34setClassScopeSpecializationPatternEPNS_12FunctionDeclES2_")]
                internal static extern void setClassScopeSpecializationPattern_0(global::System.IntPtr instance, global::System.IntPtr FD, global::System.IntPtr Pattern);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext35setInstantiatedFromStaticDataMemberEPNS_7VarDeclES2_NS_26TemplateSpecializationKindENS_14SourceLocationE")]
                internal static extern void setInstantiatedFromStaticDataMember_0(global::System.IntPtr instance, global::System.IntPtr Inst, global::System.IntPtr Tmpl, clang.TemplateSpecializationKind TSK, clang.SourceLocation.Internal PointOfInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext35getInstantiatedFromUnnamedFieldDeclEPNS_9FieldDeclE")]
                internal static extern global::System.IntPtr getInstantiatedFromUnnamedFieldDecl_0(global::System.IntPtr instance, global::System.IntPtr Field);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext35setInstantiatedFromUnnamedFieldDeclEPNS_9FieldDeclES2_")]
                internal static extern void setInstantiatedFromUnnamedFieldDecl_0(global::System.IntPtr instance, global::System.IntPtr Inst, global::System.IntPtr Tmpl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext20addedLocalImportDeclEPNS_10ImportDeclE")]
                internal static extern void addedLocalImportDecl_0(global::System.IntPtr instance, global::System.IntPtr Import);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext18getNextLocalImportEPNS_10ImportDeclE")]
                internal static extern global::System.IntPtr getNextLocalImport_0(global::System.IntPtr Import);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext20getPrimaryMergedDeclEPNS_4DeclE")]
                internal static extern global::System.IntPtr getPrimaryMergedDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext20setPrimaryMergedDeclEPNS_4DeclES2_")]
                internal static extern void setPrimaryMergedDecl_0(global::System.IntPtr instance, global::System.IntPtr D, global::System.IntPtr Primary);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getTranslationUnitDeclEv")]
                internal static extern global::System.IntPtr getTranslationUnitDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getExternalSourceEv")]
                internal static extern global::System.IntPtr getExternalSource_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext10PrintStatsEv")]
                internal static extern void PrintStats_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19buildImplicitRecordEN4llvm9StringRefENS_11TagTypeKindE")]
                internal static extern global::System.IntPtr buildImplicitRecord_0(global::System.IntPtr instance, llvm.StringRef.Internal Name, clang.TagTypeKind TK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20buildImplicitTypedefENS_8QualTypeEN4llvm9StringRefE")]
                internal static extern global::System.IntPtr buildImplicitTypedef_0(global::System.IntPtr instance, clang.QualType.Internal T, llvm.StringRef.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getInt128DeclEv")]
                internal static extern global::System.IntPtr getInt128Decl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getUInt128DeclEv")]
                internal static extern global::System.IntPtr getUInt128Decl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getFloat128StubTypeEv")]
                internal static extern global::System.IntPtr getFloat128StubType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getAddrSpaceQualTypeENS_8QualTypeEj")]
                internal static extern clang.QualType.Internal getAddrSpaceQualType_0(global::System.IntPtr instance, clang.QualType.Internal T, uint AddressSpace);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getObjCGCQualTypeENS_8QualTypeENS_10Qualifiers2GCE")]
                internal static extern clang.QualType.Internal getObjCGCQualType_0(global::System.IntPtr instance, clang.QualType.Internal T, clang.Qualifiers.GC gcAttr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15getRestrictTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getRestrictType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15getVolatileTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getVolatileType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getConstTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getConstType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext18adjustFunctionTypeEPKNS_12FunctionTypeENS1_7ExtInfoE")]
                internal static extern global::System.IntPtr adjustFunctionType_0(global::System.IntPtr instance, global::System.IntPtr Fn, clang.FunctionType.ExtInfo.Internal EInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext31adjustDeducedFunctionResultTypeEPNS_12FunctionDeclENS_8QualTypeE")]
                internal static extern void adjustDeducedFunctionResultType_0(global::System.IntPtr instance, global::System.IntPtr FD, clang.QualType.Internal ResultType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext19adjustExceptionSpecEPNS_12FunctionDeclERKNS_17FunctionProtoType17ExceptionSpecInfoEb")]
                internal static extern void adjustExceptionSpec_0(global::System.IntPtr instance, global::System.IntPtr FD, global::System.IntPtr ESI, bool AsWritten);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getComplexTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getComplexType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getPointerTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getPointerType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15getAdjustedTypeENS_8QualTypeES1_")]
                internal static extern clang.QualType.Internal getAdjustedType_0(global::System.IntPtr instance, clang.QualType.Internal Orig, clang.QualType.Internal New);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getDecayedTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getDecayedType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getAtomicTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getAtomicType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getBlockPointerTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getBlockPointerType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getBlockDescriptorTypeEv")]
                internal static extern clang.QualType.Internal getBlockDescriptorType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext30getBlockDescriptorExtendedTypeEv")]
                internal static extern clang.QualType.Internal getBlockDescriptorExtendedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext24setcudaConfigureCallDeclEPNS_12FunctionDeclE")]
                internal static extern void setcudaConfigureCallDecl_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext24getcudaConfigureCallDeclEv")]
                internal static extern global::System.IntPtr getcudaConfigureCallDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext20BlockRequiresCopyingENS_8QualTypeEPKNS_7VarDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool BlockRequiresCopying_0(global::System.IntPtr instance, clang.QualType.Internal Ty, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getByrefLifetimeENS_8QualTypeERNS_10Qualifiers12ObjCLifetimeERb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getByrefLifetime_0(global::System.IntPtr instance, clang.QualType.Internal Ty, clang.Qualifiers.ObjCLifetime* Lifetime, bool* HasByrefExtendedLayout);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getLValueReferenceTypeENS_8QualTypeEb")]
                internal static extern clang.QualType.Internal getLValueReferenceType_0(global::System.IntPtr instance, clang.QualType.Internal T, bool SpelledAsLValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getRValueReferenceTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getRValueReferenceType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getMemberPointerTypeENS_8QualTypeEPKNS_4TypeE")]
                internal static extern clang.QualType.Internal getMemberPointerType_0(global::System.IntPtr instance, clang.QualType.Internal T, global::System.IntPtr Cls);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getIncompleteArrayTypeENS_8QualTypeENS_9ArrayType17ArraySizeModifierEj")]
                internal static extern clang.QualType.Internal getIncompleteArrayType_0(global::System.IntPtr instance, clang.QualType.Internal EltTy, clang.ArrayType.ArraySizeModifier ASM, uint IndexTypeQuals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getConstantArrayTypeENS_8QualTypeERKN4llvm5APIntENS_9ArrayType17ArraySizeModifierEj")]
                internal static extern clang.QualType.Internal getConstantArrayType_0(global::System.IntPtr instance, clang.QualType.Internal EltTy, global::System.IntPtr ArySize, clang.ArrayType.ArraySizeModifier ASM, uint IndexTypeQuals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext27getVariableArrayDecayedTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getVariableArrayDecayedType_0(global::System.IntPtr instance, clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getVectorTypeENS_8QualTypeEjNS_10VectorType10VectorKindE")]
                internal static extern clang.QualType.Internal getVectorType_0(global::System.IntPtr instance, clang.QualType.Internal VectorType, uint NumElts, clang.VectorType.VectorKind VecKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getExtVectorTypeENS_8QualTypeEj")]
                internal static extern clang.QualType.Internal getExtVectorType_0(global::System.IntPtr instance, clang.QualType.Internal VectorType, uint NumElts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getFunctionNoProtoTypeENS_8QualTypeERKNS_12FunctionType7ExtInfoE")]
                internal static extern clang.QualType.Internal getFunctionNoProtoType_0(global::System.IntPtr instance, clang.QualType.Internal ResultTy, global::System.IntPtr Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getFunctionNoProtoTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getFunctionNoProtoType_1(global::System.IntPtr instance, clang.QualType.Internal ResultTy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15getTypeDeclTypeEPKNS_8TypeDeclES3_")]
                internal static extern clang.QualType.Internal getTypeDeclType_0(global::System.IntPtr instance, global::System.IntPtr Decl, global::System.IntPtr PrevDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getTypedefTypeEPKNS_15TypedefNameDeclENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getTypedefType_0(global::System.IntPtr instance, global::System.IntPtr Decl, clang.QualType.Internal Canon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getRecordTypeEPKNS_10RecordDeclE")]
                internal static extern clang.QualType.Internal getRecordType_0(global::System.IntPtr instance, global::System.IntPtr Decl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getEnumTypeEPKNS_8EnumDeclE")]
                internal static extern clang.QualType.Internal getEnumType_0(global::System.IntPtr instance, global::System.IntPtr Decl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17getAttributedTypeENS_14AttributedType4KindENS_8QualTypeES3_")]
                internal static extern clang.QualType.Internal getAttributedType_0(global::System.IntPtr instance, clang.AttributedType.Kind attrKind, clang.QualType.Internal modifiedType, clang.QualType.Internal equivalentType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getSubstTemplateTypeParmTypeEPKNS_20TemplateTypeParmTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getSubstTemplateTypeParmType_0(global::System.IntPtr instance, global::System.IntPtr Replaced, clang.QualType.Internal Replacement);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext32getSubstTemplateTypeParmPackTypeEPKNS_20TemplateTypeParmTypeERKNS_16TemplateArgumentE")]
                internal static extern clang.QualType.Internal getSubstTemplateTypeParmPackType_0(global::System.IntPtr instance, global::System.IntPtr Replaced, global::System.IntPtr ArgPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext29getTemplateSpecializationTypeENS_12TemplateNameEPKNS_16TemplateArgumentEjNS_8QualTypeE")]
                internal static extern clang.QualType.Internal getTemplateSpecializationType_0(global::System.IntPtr instance, clang.TemplateName.Internal T, global::System.IntPtr Args, uint NumArgs, clang.QualType.Internal Canon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext38getCanonicalTemplateSpecializationTypeENS_12TemplateNameEPKNS_16TemplateArgumentEj")]
                internal static extern clang.QualType.Internal getCanonicalTemplateSpecializationType_0(global::System.IntPtr instance, clang.TemplateName.Internal T, global::System.IntPtr Args, uint NumArgs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext29getTemplateSpecializationTypeENS_12TemplateNameERKNS_24TemplateArgumentListInfoENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getTemplateSpecializationType_1(global::System.IntPtr instance, clang.TemplateName.Internal T, global::System.IntPtr Args, clang.QualType.Internal Canon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext33getTemplateSpecializationTypeInfoENS_12TemplateNameENS_14SourceLocationERKNS_24TemplateArgumentListInfoENS_8QualTypeE")]
                internal static extern global::System.IntPtr getTemplateSpecializationTypeInfo_0(global::System.IntPtr instance, clang.TemplateName.Internal T, clang.SourceLocation.Internal TLoc, global::System.IntPtr Args, clang.QualType.Internal Canon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getParenTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getParenType_0(global::System.IntPtr instance, clang.QualType.Internal NamedType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getElaboratedTypeENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getElaboratedType_0(global::System.IntPtr instance, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, clang.QualType.Internal NamedType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getDependentNameTypeENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getDependentNameType_0(global::System.IntPtr instance, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, global::System.IntPtr Name, clang.QualType.Internal Canon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext38getDependentTemplateSpecializationTypeENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoERKNS_24TemplateArgumentListInfoE")]
                internal static extern clang.QualType.Internal getDependentTemplateSpecializationType_0(global::System.IntPtr instance, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, global::System.IntPtr Name, global::System.IntPtr Args);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext38getDependentTemplateSpecializationTypeENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoEjPKNS_16TemplateArgumentE")]
                internal static extern clang.QualType.Internal getDependentTemplateSpecializationType_1(global::System.IntPtr instance, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, global::System.IntPtr Name, uint NumArgs, global::System.IntPtr Args);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getObjCObjectPointerTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getObjCObjectPointerType_0(global::System.IntPtr instance, clang.QualType.Internal OIT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getTypeOfTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getTypeOfType_0(global::System.IntPtr instance, clang.QualType.Internal t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getUnaryTransformTypeENS_8QualTypeES1_NS_18UnaryTransformType7UTTKindE")]
                internal static extern clang.QualType.Internal getUnaryTransformType_0(global::System.IntPtr instance, clang.QualType.Internal BaseType, clang.QualType.Internal UnderlyingType, clang.UnaryTransformType.UTTKind UKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getAutoTypeENS_8QualTypeEbb")]
                internal static extern clang.QualType.Internal getAutoType_0(global::System.IntPtr instance, clang.QualType.Internal DeducedType, bool IsDecltypeAuto, bool IsDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getAutoDeductTypeEv")]
                internal static extern clang.QualType.Internal getAutoDeductType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getAutoRRefDeductTypeEv")]
                internal static extern clang.QualType.Internal getAutoRRefDeductType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getTagDeclTypeEPKNS_7TagDeclE")]
                internal static extern clang.QualType.Internal getTagDeclType_0(global::System.IntPtr instance, global::System.IntPtr Decl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getWCharTypeEv")]
                internal static extern clang.QualType.Internal getWCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15getWideCharTypeEv")]
                internal static extern clang.QualType.Internal getWideCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getSignedWCharTypeEv")]
                internal static extern clang.QualType.Internal getSignedWCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getUnsignedWCharTypeEv")]
                internal static extern clang.QualType.Internal getUnsignedWCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getWIntTypeEv")]
                internal static extern clang.QualType.Internal getWIntType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getIntPtrTypeEv")]
                internal static extern clang.QualType.Internal getIntPtrType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getUIntPtrTypeEv")]
                internal static extern clang.QualType.Internal getUIntPtrType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getPointerDiffTypeEv")]
                internal static extern clang.QualType.Internal getPointerDiffType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getProcessIDTypeEv")]
                internal static extern clang.QualType.Internal getProcessIDType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext23getCFConstantStringTypeEv")]
                internal static extern clang.QualType.Internal getCFConstantStringType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getObjCSuperTypeEv")]
                internal static extern clang.QualType.Internal getObjCSuperType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext16setObjCSuperTypeENS_8QualTypeE")]
                internal static extern void setObjCSuperType_0(global::System.IntPtr instance, clang.QualType.Internal ST);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext26getRawCFConstantStringTypeEv")]
                internal static extern clang.QualType.Internal getRawCFConstantStringType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23setCFConstantStringTypeENS_8QualTypeE")]
                internal static extern void setCFConstantStringType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext30getObjCConstantStringInterfaceEv")]
                internal static extern clang.QualType.Internal getObjCConstantStringInterface_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getObjCNSStringTypeEv")]
                internal static extern clang.QualType.Internal getObjCNSStringType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext19setObjCNSStringTypeENS_8QualTypeE")]
                internal static extern void setObjCNSStringType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext25getObjCIdRedefinitionTypeEv")]
                internal static extern clang.QualType.Internal getObjCIdRedefinitionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext25setObjCIdRedefinitionTypeENS_8QualTypeE")]
                internal static extern void setObjCIdRedefinitionType_0(global::System.IntPtr instance, clang.QualType.Internal RedefType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getObjCClassRedefinitionTypeEv")]
                internal static extern clang.QualType.Internal getObjCClassRedefinitionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext28setObjCClassRedefinitionTypeENS_8QualTypeE")]
                internal static extern void setObjCClassRedefinitionType_0(global::System.IntPtr instance, clang.QualType.Internal RedefType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext26getObjCSelRedefinitionTypeEv")]
                internal static extern clang.QualType.Internal getObjCSelRedefinitionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext26setObjCSelRedefinitionTypeENS_8QualTypeE")]
                internal static extern void setObjCSelRedefinitionType_0(global::System.IntPtr instance, clang.QualType.Internal RedefType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext19getObjCInstanceTypeEv")]
                internal static extern clang.QualType.Internal getObjCInstanceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23getObjCInstanceTypeDeclEv")]
                internal static extern global::System.IntPtr getObjCInstanceTypeDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext11setFILEDeclEPNS_8TypeDeclE")]
                internal static extern void setFILEDecl_0(global::System.IntPtr instance, global::System.IntPtr FILEDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getFILETypeEv")]
                internal static extern clang.QualType.Internal getFILEType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext14setjmp_bufDeclEPNS_8TypeDeclE")]
                internal static extern void setjmp_bufDecl_0(global::System.IntPtr instance, global::System.IntPtr jmp_bufDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getjmp_bufTypeEv")]
                internal static extern clang.QualType.Internal getjmp_bufType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17setsigjmp_bufDeclEPNS_8TypeDeclE")]
                internal static extern void setsigjmp_bufDecl_0(global::System.IntPtr instance, global::System.IntPtr sigjmp_bufDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getsigjmp_bufTypeEv")]
                internal static extern clang.QualType.Internal getsigjmp_bufType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17setucontext_tDeclEPNS_8TypeDeclE")]
                internal static extern void setucontext_tDecl_0(global::System.IntPtr instance, global::System.IntPtr ucontext_tDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getucontext_tTypeEv")]
                internal static extern clang.QualType.Internal getucontext_tType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext23getLogicalOperationTypeEv")]
                internal static extern clang.QualType.Internal getLogicalOperationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext29getLegacyIntegralTypeEncodingERNS_8QualTypeE")]
                internal static extern void getLegacyIntegralTypeEncoding_0(global::System.IntPtr instance, global::System.IntPtr t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext23getObjCEncodingTypeSizeENS_8QualTypeE")]
                internal static extern clang.CharUnits.Internal getObjCEncodingTypeSize_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getObjCIdDeclEv")]
                internal static extern global::System.IntPtr getObjCIdDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13getObjCIdTypeEv")]
                internal static extern clang.QualType.Internal getObjCIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getObjCSelDeclEv")]
                internal static extern global::System.IntPtr getObjCSelDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getObjCSelTypeEv")]
                internal static extern clang.QualType.Internal getObjCSelType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getObjCClassDeclEv")]
                internal static extern global::System.IntPtr getObjCClassDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getObjCClassTypeEv")]
                internal static extern clang.QualType.Internal getObjCClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getBOOLDeclEv")]
                internal static extern global::System.IntPtr getBOOLDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext11setBOOLDeclEPNS_11TypedefDeclE")]
                internal static extern void setBOOLDecl_0(global::System.IntPtr instance, global::System.IntPtr TD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getBOOLTypeEv")]
                internal static extern clang.QualType.Internal getBOOLType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getObjCProtoTypeEv")]
                internal static extern clang.QualType.Internal getObjCProtoType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getBuiltinVaListDeclEv")]
                internal static extern global::System.IntPtr getBuiltinVaListDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getBuiltinVaListTypeEv")]
                internal static extern clang.QualType.Internal getBuiltinVaListType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getVaListTagTypeEv")]
                internal static extern clang.QualType.Internal getVaListTagType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getCVRQualifiedTypeENS_8QualTypeEj")]
                internal static extern clang.QualType.Internal getCVRQualifiedType_0(global::System.IntPtr instance, clang.QualType.Internal T, uint CVR);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getQualifiedTypeENS_13SplitQualTypeE")]
                internal static extern clang.QualType.Internal getQualifiedType_0(global::System.IntPtr instance, clang.SplitQualType.Internal split);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getQualifiedTypeENS_8QualTypeENS_10QualifiersE")]
                internal static extern clang.QualType.Internal getQualifiedType_1(global::System.IntPtr instance, clang.QualType.Internal T, clang.Qualifiers.Internal Qs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getQualifiedTypeEPKNS_4TypeENS_10QualifiersE")]
                internal static extern clang.QualType.Internal getQualifiedType_2(global::System.IntPtr instance, global::System.IntPtr T, clang.Qualifiers.Internal Qs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext24getLifetimeQualifiedTypeENS_8QualTypeENS_10Qualifiers12ObjCLifetimeE")]
                internal static extern clang.QualType.Internal getLifetimeQualifiedType_0(global::System.IntPtr instance, clang.QualType.Internal type, clang.Qualifiers.ObjCLifetime lifetime);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext29getUnqualifiedObjCPointerTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getUnqualifiedObjCPointerType_0(global::System.IntPtr instance, clang.QualType.Internal type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getNameForTemplateENS_12TemplateNameENS_14SourceLocationE")]
                internal static extern void getNameForTemplate_0(global::System.IntPtr @return, global::System.IntPtr instance, clang.TemplateName.Internal Name, clang.SourceLocation.Internal NameLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getDependentTemplateNameEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoE")]
                internal static extern clang.TemplateName.Internal getDependentTemplateName_0(global::System.IntPtr instance, global::System.IntPtr NNS, global::System.IntPtr Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getDependentTemplateNameEPNS_19NestedNameSpecifierENS_22OverloadedOperatorKindE")]
                internal static extern clang.TemplateName.Internal getDependentTemplateName_1(global::System.IntPtr instance, global::System.IntPtr NNS, clang.OverloadedOperatorKind Operator);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14GetBuiltinTypeEjRNS0_19GetBuiltinTypeErrorEPj")]
                internal static extern clang.QualType.Internal GetBuiltinType_0(global::System.IntPtr instance, uint ID, clang.ASTContext.GetBuiltinTypeError* Error, uint* IntegerConstantArgs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getObjCGCAttrKindENS_8QualTypeE")]
                internal static extern clang.Qualifiers.GC getObjCGCAttrKind_0(global::System.IntPtr instance, clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext24areCompatibleVectorTypesENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool areCompatibleVectorTypes_0(global::System.IntPtr instance, clang.QualType.Internal FirstVec, clang.QualType.Internal SecondVec);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext18isObjCNSObjectTypeENS_8QualTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCNSObjectType_0(clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getTypeInfoEPKNS_4TypeE")]
                internal static extern clang.TypeInfo.Internal getTypeInfo_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getTypeInfoENS_8QualTypeE")]
                internal static extern clang.TypeInfo.Internal getTypeInfo_1(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getTypeSizeENS_8QualTypeE")]
                internal static extern ulong getTypeSize_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getTypeSizeEPKNS_4TypeE")]
                internal static extern ulong getTypeSize_1(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getCharWidthEv")]
                internal static extern ulong getCharWidth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19toCharUnitsFromBitsEx")]
                internal static extern clang.CharUnits.Internal toCharUnitsFromBits_0(global::System.IntPtr instance, long BitSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext6toBitsENS_9CharUnitsE")]
                internal static extern long toBits_0(global::System.IntPtr instance, clang.CharUnits.Internal CharSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getTypeSizeInCharsENS_8QualTypeE")]
                internal static extern clang.CharUnits.Internal getTypeSizeInChars_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getTypeSizeInCharsEPKNS_4TypeE")]
                internal static extern clang.CharUnits.Internal getTypeSizeInChars_1(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getTypeAlignENS_8QualTypeE")]
                internal static extern uint getTypeAlign_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getTypeAlignEPKNS_4TypeE")]
                internal static extern uint getTypeAlign_1(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getTypeAlignInCharsENS_8QualTypeE")]
                internal static extern clang.CharUnits.Internal getTypeAlignInChars_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getTypeAlignInCharsEPKNS_4TypeE")]
                internal static extern clang.CharUnits.Internal getTypeAlignInChars_1(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19isAlignmentRequiredEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAlignmentRequired_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19isAlignmentRequiredENS_8QualTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAlignmentRequired_1(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getPreferredTypeAlignEPKNS_4TypeE")]
                internal static extern uint getPreferredTypeAlign_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getAlignOfGlobalVarENS_8QualTypeE")]
                internal static extern uint getAlignOfGlobalVar_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext26getAlignOfGlobalVarInCharsENS_8QualTypeE")]
                internal static extern clang.CharUnits.Internal getAlignOfGlobalVarInChars_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12getDeclAlignEPKNS_4DeclEb")]
                internal static extern clang.CharUnits.Internal getDeclAlign_0(global::System.IntPtr instance, global::System.IntPtr D, bool ForAlignof);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16DumpRecordLayoutEPKNS_10RecordDeclERN4llvm11raw_ostreamEb")]
                internal static extern void DumpRecordLayout_0(global::System.IntPtr instance, global::System.IntPtr RD, global::System.IntPtr OS, bool Simple);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getFieldOffsetEPKNS_9ValueDeclE")]
                internal static extern ulong getFieldOffset_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext16getCanonicalTypeEPKNS_4TypeE")]
                internal static extern global::System.IntPtr getCanonicalType_1(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11hasSameTypeENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSameType_0(global::System.IntPtr instance, clang.QualType.Internal T1, clang.QualType.Internal T2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11hasSameTypeEPKNS_4TypeES3_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSameType_1(global::System.IntPtr instance, global::System.IntPtr T1, global::System.IntPtr T2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23getUnqualifiedArrayTypeENS_8QualTypeERNS_10QualifiersE")]
                internal static extern clang.QualType.Internal getUnqualifiedArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T, global::System.IntPtr Quals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22hasSameUnqualifiedTypeENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSameUnqualifiedType_0(global::System.IntPtr instance, clang.QualType.Internal T1, clang.QualType.Internal T2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext25UnwrapSimilarPointerTypesERNS_8QualTypeES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool UnwrapSimilarPointerTypes_0(global::System.IntPtr instance, global::System.IntPtr T1, global::System.IntPtr T2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext31getCanonicalNestedNameSpecifierEPNS_19NestedNameSpecifierE")]
                internal static extern global::System.IntPtr getCanonicalNestedNameSpecifier_0(global::System.IntPtr instance, global::System.IntPtr NNS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext27getDefaultCallingConventionEbb")]
                internal static extern clang.CallingConv getDefaultCallingConvention_0(global::System.IntPtr instance, bool isVariadic, bool IsCXXMethod);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getCanonicalTemplateNameENS_12TemplateNameE")]
                internal static extern clang.TemplateName.Internal getCanonicalTemplateName_0(global::System.IntPtr instance, clang.TemplateName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext19hasSameTemplateNameENS_12TemplateNameES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSameTemplateName_0(global::System.IntPtr instance, clang.TemplateName.Internal X, clang.TemplateName.Internal Y);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getCanonicalTemplateArgumentERKNS_16TemplateArgumentE")]
                internal static extern void getCanonicalTemplateArgument_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Arg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext14getAsArrayTypeENS_8QualTypeE")]
                internal static extern global::System.IntPtr getAsArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getAsConstantArrayTypeENS_8QualTypeE")]
                internal static extern global::System.IntPtr getAsConstantArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getAsVariableArrayTypeENS_8QualTypeE")]
                internal static extern global::System.IntPtr getAsVariableArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getAsIncompleteArrayTypeENS_8QualTypeE")]
                internal static extern global::System.IntPtr getAsIncompleteArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getAsDependentSizedArrayTypeENS_8QualTypeE")]
                internal static extern global::System.IntPtr getAsDependentSizedArrayType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getBaseElementTypeEPKNS_9ArrayTypeE")]
                internal static extern clang.QualType.Internal getBaseElementType_0(global::System.IntPtr instance, global::System.IntPtr VAT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext18getBaseElementTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getBaseElementType_1(global::System.IntPtr instance, clang.QualType.Internal QT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getConstantArrayElementCountEPKNS_17ConstantArrayTypeE")]
                internal static extern ulong getConstantArrayElementCount_0(global::System.IntPtr instance, global::System.IntPtr CA);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getAdjustedParameterTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getAdjustedParameterType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext25getSignatureParameterTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getSignatureParameterType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getArrayDecayedTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getArrayDecayedType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext22getPromotedIntegerTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getPromotedIntegerType_0(global::System.IntPtr instance, clang.QualType.Internal PromotableType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getInnerObjCOwnershipENS_8QualTypeE")]
                internal static extern clang.Qualifiers.ObjCLifetime getInnerObjCOwnership_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext19getIntegerTypeOrderENS_8QualTypeES1_")]
                internal static extern int getIntegerTypeOrder_0(global::System.IntPtr instance, clang.QualType.Internal LHS, clang.QualType.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getFloatingTypeOrderENS_8QualTypeES1_")]
                internal static extern int getFloatingTypeOrder_0(global::System.IntPtr instance, clang.QualType.Internal LHS, clang.QualType.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext33getFloatingTypeOfSizeWithinDomainENS_8QualTypeES1_")]
                internal static extern clang.QualType.Internal getFloatingTypeOfSizeWithinDomain_0(global::System.IntPtr instance, clang.QualType.Internal typeSize, clang.QualType.Internal typeDomain);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getTargetAddressSpaceENS_8QualTypeE")]
                internal static extern uint getTargetAddressSpace_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getTargetAddressSpaceENS_10QualifiersE")]
                internal static extern uint getTargetAddressSpace_1(global::System.IntPtr instance, clang.Qualifiers.Internal Q);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext21getTargetAddressSpaceEj")]
                internal static extern uint getTargetAddressSpace_2(global::System.IntPtr instance, uint AS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext26addressSpaceMapManglingForEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool addressSpaceMapManglingFor_0(global::System.IntPtr instance, uint AS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext18typesAreCompatibleENS_8QualTypeES1_b")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool typesAreCompatible_0(global::System.IntPtr instance, clang.QualType.Internal T1, clang.QualType.Internal T2, bool CompareUnqualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext26propertyTypesAreCompatibleENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool propertyTypesAreCompatible_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext30typesAreBlockPointerCompatibleENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool typesAreBlockPointerCompatible_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12isObjCIdTypeENS_8QualTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCIdType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext15isObjCClassTypeENS_8QualTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCClassType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext13isObjCSelTypeENS_8QualTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCSelType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext33ObjCQualifiedIdTypesAreCompatibleENS_8QualTypeES1_b")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ObjCQualifiedIdTypesAreCompatible_0(global::System.IntPtr instance, clang.QualType.Internal LHS, clang.QualType.Internal RHS, bool ForCompare);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext36ObjCQualifiedClassTypesAreCompatibleENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ObjCQualifiedClassTypesAreCompatible_0(global::System.IntPtr instance, clang.QualType.Internal LHS, clang.QualType.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23canAssignObjCInterfacesEPKNS_21ObjCObjectPointerTypeES3_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canAssignObjCInterfaces_0(global::System.IntPtr instance, global::System.IntPtr LHSOPT, global::System.IntPtr RHSOPT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23canAssignObjCInterfacesEPKNS_14ObjCObjectTypeES3_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canAssignObjCInterfaces_1(global::System.IntPtr instance, global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext37canAssignObjCInterfacesInBlockPointerEPKNS_21ObjCObjectPointerTypeES3_b")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canAssignObjCInterfacesInBlockPointer_0(global::System.IntPtr instance, global::System.IntPtr LHSOPT, global::System.IntPtr RHSOPT, bool BlockReturnType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext29areComparableObjCPointerTypesENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool areComparableObjCPointerTypes_0(global::System.IntPtr instance, clang.QualType.Internal LHS, clang.QualType.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext23areCommonBaseCompatibleEPKNS_21ObjCObjectPointerTypeES3_")]
                internal static extern clang.QualType.Internal areCommonBaseCompatible_0(global::System.IntPtr instance, global::System.IntPtr LHSOPT, global::System.IntPtr RHSOPT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext21canBindObjCObjectTypeENS_8QualTypeES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canBindObjCObjectType_0(global::System.IntPtr instance, clang.QualType.Internal To, clang.QualType.Internal From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext10mergeTypesENS_8QualTypeES1_bbb")]
                internal static extern clang.QualType.Internal mergeTypes_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1, bool OfBlockPointer, bool Unqualified, bool BlockReturnType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext18mergeFunctionTypesENS_8QualTypeES1_bb")]
                internal static extern clang.QualType.Internal mergeFunctionTypes_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1, bool OfBlockPointer, bool Unqualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext27mergeFunctionParameterTypesENS_8QualTypeES1_bb")]
                internal static extern clang.QualType.Internal mergeFunctionParameterTypes_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1, bool OfBlockPointer, bool Unqualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext25mergeTransparentUnionTypeENS_8QualTypeES1_bb")]
                internal static extern clang.QualType.Internal mergeTransparentUnionType_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1, bool OfBlockPointer, bool Unqualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext21mergeObjCGCQualifiersENS_8QualTypeES1_")]
                internal static extern clang.QualType.Internal mergeObjCGCQualifiers_0(global::System.IntPtr instance, clang.QualType.Internal _0, clang.QualType.Internal _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext35FunctionTypesMatchOnNSConsumedAttrsEPKNS_17FunctionProtoTypeES3_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool FunctionTypesMatchOnNSConsumedAttrs_0(global::System.IntPtr instance, global::System.IntPtr FromFunctionType, global::System.IntPtr ToFunctionType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext11getIntWidthENS_8QualTypeE")]
                internal static extern uint getIntWidth_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext28getCorrespondingUnsignedTypeENS_8QualTypeE")]
                internal static extern clang.QualType.Internal getCorrespondingUnsignedType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext12MakeIntValueEyNS_8QualTypeE")]
                internal static extern void MakeIntValue_0(global::System.IntPtr @return, global::System.IntPtr instance, ulong Value, clang.QualType.Internal Type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext21AnyObjCImplementationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool AnyObjCImplementation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20CreateTypeSourceInfoENS_8QualTypeEj")]
                internal static extern global::System.IntPtr CreateTypeSourceInfo_0(global::System.IntPtr instance, clang.QualType.Internal T, uint Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24getTrivialTypeSourceInfoENS_8QualTypeENS_14SourceLocationE")]
                internal static extern global::System.IntPtr getTrivialTypeSourceInfo_0(global::System.IntPtr instance, clang.QualType.Internal T, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext15AddDeallocationEPFvPvES1_")]
                internal static extern void AddDeallocation_0(global::System.IntPtr instance, global::System.IntPtr Callback, global::System.IntPtr Data);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext24GetGVALinkageForFunctionEPKNS_12FunctionDeclE")]
                internal static extern clang.GVALinkage GetGVALinkageForFunction_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext24GetGVALinkageForVariableEPKNS_7VarDeclE")]
                internal static extern clang.GVALinkage GetGVALinkageForVariable_0(global::System.IntPtr instance, global::System.IntPtr VD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17DeclMustBeEmittedEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool DeclMustBeEmitted_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17setManglingNumberEPKNS_9NamedDeclEj")]
                internal static extern void setManglingNumber_0(global::System.IntPtr instance, global::System.IntPtr ND, uint Number);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getManglingNumberEPKNS_9NamedDeclE")]
                internal static extern uint getManglingNumber_0(global::System.IntPtr instance, global::System.IntPtr ND);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext20setStaticLocalNumberEPKNS_7VarDeclEj")]
                internal static extern void setStaticLocalNumber_0(global::System.IntPtr instance, global::System.IntPtr VD, uint Number);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext20getStaticLocalNumberEPKNS_7VarDeclE")]
                internal static extern uint getStaticLocalNumber_0(global::System.IntPtr instance, global::System.IntPtr VD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ASTContext17setParameterIndexEPKNS_11ParmVarDeclEj")]
                internal static extern void setParameterIndex_0(global::System.IntPtr instance, global::System.IntPtr D, uint index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext17getParameterIndexEPKNS_11ParmVarDeclE")]
                internal static extern uint getParameterIndex_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ASTContext36isMSStaticDataMemberInlineDefinitionEPKNS_7VarDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMSStaticDataMemberInlineDefinition_0(global::System.IntPtr instance, global::System.IntPtr VD);
            }

            public enum GetBuiltinTypeError : uint
            {
                /// <summary>No error</summary>
                GE_None = 0,
                /// <summary>Missing a type from <stdio.h></summary>
                GE_Missing_stdio = 1,
                /// <summary>Missing a type from <setjmp.h></summary>
                GE_Missing_setjmp = 2,
                /// <summary>Missing a type from <ucontext.h></summary>
                GE_Missing_ucontext = 3
            }

            [Flags]
            public enum PragmaSectionFlag : uint
            {
                PSF_None = 0,
                PSF_Read = 0x1,
                PSF_Write = 0x2,
                PSF_Execute = 0x4,
                PSF_Implicit = 0x8,
                PSF_Invalid = 0x80000000
            }

            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            public unsafe delegate void __AnonymousDelegate0(global::System.IntPtr _0);

            /// <summary>
            /// <para>Representation of a &quot;canonical&quot; template template
            /// parameter that is used in canonical template names.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Representation of a &quot;canonical&quot; template
            /// template parameter that</para>
            /// <para>  /// is used in canonical template names.</para>
            /// </remarks>
            internal unsafe partial class CanonicalTemplateTemplateParm
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr NextInFoldingSetBucket;

                    [FieldOffset(8)]
                    public global::System.IntPtr Parm;
                }
            }

            public unsafe partial class RawCommentAndCacheFlags : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.PointerIntPair.Internal Data;

                    [FieldOffset(8)]
                    public global::System.IntPtr OriginalDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext23RawCommentAndCacheFlagsC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext23RawCommentAndCacheFlagsC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10ASTContext23RawCommentAndCacheFlags7getKindEv")]
                    internal static extern clang.ASTContext.RawCommentAndCacheFlags.Kind getKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext23RawCommentAndCacheFlags7setKindENS1_4KindE")]
                    internal static extern void setKind_0(global::System.IntPtr instance, clang.ASTContext.RawCommentAndCacheFlags.Kind K);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10ASTContext23RawCommentAndCacheFlags6getRawEv")]
                    internal static extern global::System.IntPtr getRaw_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext23RawCommentAndCacheFlags6setRawEPKNS_10RawCommentE")]
                    internal static extern void setRaw_0(global::System.IntPtr instance, global::System.IntPtr RC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang10ASTContext23RawCommentAndCacheFlags15getOriginalDeclEv")]
                    internal static extern global::System.IntPtr getOriginalDecl_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext23RawCommentAndCacheFlags15setOriginalDeclEPKNS_4DeclE")]
                    internal static extern void setOriginalDecl_0(global::System.IntPtr instance, global::System.IntPtr Orig);
                }

                public enum Kind : uint
                {
                    /// <summary>We searched for a comment attached to the particular declaration, but didn't find any.</summary>
                    NoCommentInDecl = 0,
                    /// <summary>We have found a comment attached to this particular declaration.</summary>
                    FromDecl = 1,
                    /// <summary>This declaration does not have an attached comment, and we have searched the redeclaration chain.</summary>
                    FromRedecl = 2
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RawCommentAndCacheFlags> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RawCommentAndCacheFlags>();

                private readonly bool __ownsNativeInstance;

                public static RawCommentAndCacheFlags __CreateInstance(global::System.IntPtr native)
                {
                    return new RawCommentAndCacheFlags((RawCommentAndCacheFlags.Internal*) native);
                }

                public static RawCommentAndCacheFlags __CreateInstance(RawCommentAndCacheFlags.Internal native)
                {
                    return new RawCommentAndCacheFlags(native);
                }

                private static RawCommentAndCacheFlags.Internal* __CopyValue(RawCommentAndCacheFlags.Internal native)
                {
                    var ret = (RawCommentAndCacheFlags.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private RawCommentAndCacheFlags(RawCommentAndCacheFlags.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RawCommentAndCacheFlags(RawCommentAndCacheFlags.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public RawCommentAndCacheFlags()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ASTContext.RawCommentAndCacheFlags __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.ASTContext.RawCommentAndCacheFlags.Kind getKind()
                {
                    var __ret = Internal.getKind_0(__Instance);
                    return __ret;
                }

                public void setKind(clang.ASTContext.RawCommentAndCacheFlags.Kind K)
                {
                    var arg0 = K;
                    Internal.setKind_0(__Instance, arg0);
                }

                public clang.RawComment getRaw()
                {
                    var __ret = Internal.getRaw_0(__Instance);
                    clang.RawComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.RawComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.RawComment) clang.RawComment.NativeToManagedMap[__ret];
                    else __result0 = clang.RawComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void setRaw(clang.RawComment RC)
                {
                    var arg0 = ReferenceEquals(RC, null) ? global::System.IntPtr.Zero : RC.__Instance;
                    Internal.setRaw_0(__Instance, arg0);
                }

                public clang.Decl getOriginalDecl()
                {
                    var __ret = Internal.getOriginalDecl_0(__Instance);
                    clang.Decl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                    else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                    return __result0;
                }

                public void setOriginalDecl(clang.Decl Orig)
                {
                    var arg0 = ReferenceEquals(Orig, null) ? global::System.IntPtr.Zero : Orig.__Instance;
                    Internal.setOriginalDecl_0(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Iterator that visits import declarations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterator that visits import declarations.</para>
            /// </remarks>
            internal unsafe partial class import_iterator
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Import;
                }
            }

            public unsafe partial class SectionInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Decl;

                    [FieldOffset(8)]
                    public clang.SourceLocation.Internal PragmaSectionLocation;

                    [FieldOffset(12)]
                    public int SectionFlags;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext11SectionInfoC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext11SectionInfoC2EPNS_14DeclaratorDeclENS_14SourceLocationEi")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Decl, clang.SourceLocation.Internal PragmaSectionLocation, int SectionFlags);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang10ASTContext11SectionInfoC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SectionInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SectionInfo>();

                private readonly bool __ownsNativeInstance;

                public static SectionInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new SectionInfo((SectionInfo.Internal*) native);
                }

                public static SectionInfo __CreateInstance(SectionInfo.Internal native)
                {
                    return new SectionInfo(native);
                }

                private static SectionInfo.Internal* __CopyValue(SectionInfo.Internal native)
                {
                    var ret = (SectionInfo.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private SectionInfo(SectionInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SectionInfo(SectionInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public SectionInfo()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public SectionInfo(clang.DeclaratorDecl Decl, clang.SourceLocation PragmaSectionLocation, int SectionFlags)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                    var arg1 = ReferenceEquals(PragmaSectionLocation, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (PragmaSectionLocation.__Instance);
                    Internal.ctor_1(__Instance, arg0, arg1, SectionFlags);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ASTContext.SectionInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.DeclaratorDecl Decl
                {
                    get
                    {
                        clang.DeclaratorDecl __result0;
                        if (((Internal*) __Instance)->Decl == IntPtr.Zero) __result0 = null;
                        else if (clang.DeclaratorDecl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Decl))
                            __result0 = (clang.DeclaratorDecl) clang.DeclaratorDecl.NativeToManagedMap[((Internal*) __Instance)->Decl];
                        else clang.DeclaratorDecl.NativeToManagedMap[((Internal*) __Instance)->Decl] = __result0 = (clang.DeclaratorDecl) clang.DeclaratorDecl.__CreateInstance(((Internal*) __Instance)->Decl);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Decl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public clang.SourceLocation PragmaSectionLocation
                {
                    get
                    {
                        return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->PragmaSectionLocation);
                    }

                    set
                    {
                        ((Internal*) __Instance)->PragmaSectionLocation = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                    }
                }

                public int SectionFlags
                {
                    get
                    {
                        return ((Internal*) __Instance)->SectionFlags;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SectionFlags = value;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTContext> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTContext>();

            private readonly bool __ownsNativeInstance;

            public static ASTContext __CreateInstance(global::System.IntPtr native)
            {
                return new ASTContext((ASTContext.Internal*) native);
            }

            public static ASTContext __CreateInstance(ASTContext.Internal native)
            {
                return new ASTContext(native);
            }

            private static ASTContext.Internal* __CopyValue(ASTContext.Internal native)
            {
                var ret = (ASTContext.Internal*) Marshal.AllocHGlobal(16696);
                *ret = native;
                return ret;
            }

            private ASTContext(ASTContext.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ASTContext(ASTContext.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ASTContext __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.PrintingPolicy getPrintingPolicy()
            {
                var __ret = Internal.getPrintingPolicy_0(__Instance);
                clang.PrintingPolicy __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[__ret];
                else __result0 = clang.PrintingPolicy.__CreateInstance(__ret);
                return __result0;
            }

            public void setPrintingPolicy(clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.setPrintingPolicy_0(__Instance, arg0);
            }

            public clang.SourceManager getSourceManager()
            {
                var __ret = Internal.getSourceManager_0(__Instance);
                clang.SourceManager __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceManager.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceManager) clang.SourceManager.NativeToManagedMap[__ret];
                else __result0 = clang.SourceManager.__CreateInstance(__ret);
                return __result0;
            }

            public global::System.IntPtr Allocate(ulong Size, uint Align)
            {
                var arg0 = Size;
                var __ret = Internal.Allocate_0(__Instance, arg0, Align);
                return __ret;
            }

            public void Deallocate(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                Internal.Deallocate_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the total amount of physical memory allocated for
            /// representing AST nodes and type information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the total amount of physical memory allocated for
            /// representing</para>
            /// <para>  /// AST nodes and type information.</para>
            /// </remarks>
            public ulong getASTAllocatedMemory()
            {
                var __ret = Internal.getASTAllocatedMemory_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the total memory used for various side tables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the total memory used for various side tables.</para>
            /// </remarks>
            public ulong getSideTableAllocatedMemory()
            {
                var __ret = Internal.getSideTableAllocatedMemory_0(__Instance);
                return __ret;
            }

            public clang.PartialDiagnostic.StorageAllocator getDiagAllocator()
            {
                var __ret = Internal.getDiagAllocator_0(__Instance);
                clang.PartialDiagnostic.StorageAllocator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.PartialDiagnostic.StorageAllocator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.PartialDiagnostic.StorageAllocator) clang.PartialDiagnostic.StorageAllocator.NativeToManagedMap[__ret];
                else __result0 = clang.PartialDiagnostic.StorageAllocator.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getIntTypeForBitwidth - sets integer QualTy according to
            /// specified details: bitwidth, signed/unsigned. Returns empty type if there
            /// is no appropriate target types.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getIntTypeForBitwidth -</para>
            /// <para>  /// sets integer QualTy according to specified details:</para>
            /// <para>  /// bitwidth, signed/unsigned.</para>
            /// <para>  /// Returns empty type if there is no appropriate target
            /// types.</para>
            /// </remarks>
            public clang.QualType getIntTypeForBitwidth(uint DestWidth, uint Signed)
            {
                var __ret = Internal.getIntTypeForBitwidth_0(__Instance, DestWidth, Signed);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getRealTypeForBitwidth - sets floating point QualTy according to
            /// specified bitwidth. Returns empty type if there is no appropriate target
            /// types.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getRealTypeForBitwidth -</para>
            /// <para>  /// sets floating point QualTy according to specified
            /// bitwidth.</para>
            /// <para>  /// Returns empty type if there is no appropriate target
            /// types.</para>
            /// </remarks>
            public clang.QualType getRealTypeForBitwidth(uint DestWidth)
            {
                var __ret = Internal.getRealTypeForBitwidth_0(__Instance, DestWidth);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.LangOptions getLangOpts()
            {
                var __ret = Internal.getLangOpts_0(__Instance);
                clang.LangOptions __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LangOptions.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LangOptions) clang.LangOptions.NativeToManagedMap[__ret];
                else __result0 = clang.LangOptions.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SanitizerBlacklist getSanitizerBlacklist()
            {
                var __ret = Internal.getSanitizerBlacklist_0(__Instance);
                clang.SanitizerBlacklist __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SanitizerBlacklist.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SanitizerBlacklist) clang.SanitizerBlacklist.NativeToManagedMap[__ret];
                else __result0 = clang.SanitizerBlacklist.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DiagnosticsEngine getDiagnostics()
            {
                var __ret = Internal.getDiagnostics_0(__Instance);
                clang.DiagnosticsEngine __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticsEngine.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticsEngine) clang.DiagnosticsEngine.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticsEngine.__CreateInstance(__ret);
                return __result0;
            }

            public clang.FullSourceLoc getFullLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getFullLoc_0(__Instance, arg0);
                return clang.FullSourceLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the documentation comment attached to a given declaration,
            /// without looking into cache.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the documentation comment attached to a given
            /// declaration,</para>
            /// <para>  /// without looking into cache.</para>
            /// </remarks>
            public clang.RawComment getRawCommentForDeclNoCache(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getRawCommentForDeclNoCache_0(__Instance, arg0);
                clang.RawComment __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RawComment.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RawComment) clang.RawComment.NativeToManagedMap[__ret];
                else __result0 = clang.RawComment.__CreateInstance(__ret);
                return __result0;
            }

            public clang.RawCommentList getRawCommentList()
            {
                var __ret = Internal.getRawCommentList_0(__Instance);
                clang.RawCommentList __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RawCommentList.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RawCommentList) clang.RawCommentList.NativeToManagedMap[__ret];
                else __result0 = clang.RawCommentList.__CreateInstance(__ret);
                return __result0;
            }

            public void addComment(clang.RawComment RC)
            {
                var arg0 = ReferenceEquals(RC, null) ? global::System.IntPtr.Zero : RC.__Instance;
                Internal.addComment_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the documentation comment attached to a given declaration.
            /// Returns NULL if no comment is attached.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the documentation comment attached to a given
            /// declaration.</para>
            /// <para>  /// Returns NULL if no comment is attached.</para>
            /// <para>  ///</para>
            /// <para>  /// \param OriginalDecl if not NULL, is set to declaration AST
            /// node that had</para>
            /// <para>  /// the comment, if the comment we found comes from a
            /// redeclaration.</para>
            /// </remarks>
            public clang.RawComment getRawCommentForAnyRedecl(clang.Decl D, clang.Decl OriginalDecl)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg1 = ReferenceEquals(OriginalDecl, null) ? global::System.IntPtr.Zero : OriginalDecl.__Instance;
                var __ret = Internal.getRawCommentForAnyRedecl_0(__Instance, arg0, arg1);
                clang.RawComment __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RawComment.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RawComment) clang.RawComment.NativeToManagedMap[__ret];
                else __result0 = clang.RawComment.__CreateInstance(__ret);
                return __result0;
            }

            public clang.comments.CommandTraits getCommentCommandTraits()
            {
                var __ret = Internal.getCommentCommandTraits_0(__Instance);
                clang.comments.CommandTraits __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.comments.CommandTraits.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.comments.CommandTraits) clang.comments.CommandTraits.NativeToManagedMap[__ret];
                else __result0 = clang.comments.CommandTraits.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Erase the attributes corresponding to the given
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Erase the attributes corresponding to the given
            /// declaration.</para>
            /// </remarks>
            public void eraseDeclAttrs(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.eraseDeclAttrs_0(__Instance, arg0);
            }

            public clang.FunctionDecl getClassScopeSpecializationPattern(clang.FunctionDecl FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var __ret = Internal.getClassScopeSpecializationPattern_0(__Instance, arg0);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setClassScopeSpecializationPattern(clang.FunctionDecl FD, clang.FunctionDecl Pattern)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var arg1 = ReferenceEquals(Pattern, null) ? global::System.IntPtr.Zero : Pattern.__Instance;
                Internal.setClassScopeSpecializationPattern_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Note that the static data member Inst is an instantiation of the
            /// static data member template Tmpl of a class template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Note that the static data member \p Inst is an
            /// instantiation of</para>
            /// <para>  /// the static data member template \p Tmpl of a class
            /// template.</para>
            /// </remarks>
            public void setInstantiatedFromStaticDataMember(clang.VarDecl Inst, clang.VarDecl Tmpl, clang.TemplateSpecializationKind TSK, clang.SourceLocation PointOfInstantiation)
            {
                var arg0 = ReferenceEquals(Inst, null) ? global::System.IntPtr.Zero : Inst.__Instance;
                var arg1 = ReferenceEquals(Tmpl, null) ? global::System.IntPtr.Zero : Tmpl.__Instance;
                var arg2 = TSK;
                var arg3 = ReferenceEquals(PointOfInstantiation, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (PointOfInstantiation.__Instance);
                Internal.setInstantiatedFromStaticDataMember_0(__Instance, arg0, arg1, arg2, arg3);
            }

            public clang.FieldDecl getInstantiatedFromUnnamedFieldDecl(clang.FieldDecl Field)
            {
                var arg0 = ReferenceEquals(Field, null) ? global::System.IntPtr.Zero : Field.__Instance;
                var __ret = Internal.getInstantiatedFromUnnamedFieldDecl_0(__Instance, arg0);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setInstantiatedFromUnnamedFieldDecl(clang.FieldDecl Inst, clang.FieldDecl Tmpl)
            {
                var arg0 = ReferenceEquals(Inst, null) ? global::System.IntPtr.Zero : Inst.__Instance;
                var arg1 = ReferenceEquals(Tmpl, null) ? global::System.IntPtr.Zero : Tmpl.__Instance;
                Internal.setInstantiatedFromUnnamedFieldDecl_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Notify the AST context that a new import declaration has been
            /// parsed or implicitly created within this translation unit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Notify the AST context that a new import declaration
            /// has been</para>
            /// <para>  /// parsed or implicitly created within this translation
            /// unit.</para>
            /// </remarks>
            public void addedLocalImportDecl(clang.ImportDecl Import)
            {
                var arg0 = ReferenceEquals(Import, null) ? global::System.IntPtr.Zero : Import.__Instance;
                Internal.addedLocalImportDecl_0(__Instance, arg0);
            }

            public clang.Decl getPrimaryMergedDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getPrimaryMergedDecl_0(__Instance, arg0);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public void setPrimaryMergedDecl(clang.Decl D, clang.Decl Primary)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg1 = ReferenceEquals(Primary, null) ? global::System.IntPtr.Zero : Primary.__Instance;
                Internal.setPrimaryMergedDecl_0(__Instance, arg0, arg1);
            }

            public clang.TranslationUnitDecl getTranslationUnitDecl()
            {
                var __ret = Internal.getTranslationUnitDecl_0(__Instance);
                clang.TranslationUnitDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TranslationUnitDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.NativeToManagedMap[__ret];
                else clang.TranslationUnitDecl.NativeToManagedMap[__ret] = __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve a pointer to the external AST source associated with
            /// this AST context, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve a pointer to the external AST source
            /// associated</para>
            /// <para>  /// with this AST context, if any.</para>
            /// </remarks>
            public clang.ExternalASTSource getExternalSource()
            {
                var __ret = Internal.getExternalSource_0(__Instance);
                clang.ExternalASTSource __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ExternalASTSource.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ExternalASTSource) clang.ExternalASTSource.NativeToManagedMap[__ret];
                else clang.ExternalASTSource.NativeToManagedMap[__ret] = __result0 = (clang.ExternalASTSource) clang.ExternalASTSource.__CreateInstance(__ret);
                return __result0;
            }

            public void PrintStats()
            {
                Internal.PrintStats_0(__Instance);
            }

            /// <summary>
            /// <para>Create a new implicit TU-level CXXRecordDecl or RecordDecl
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new implicit TU-level CXXRecordDecl or
            /// RecordDecl</para>
            /// <para>  /// declaration.</para>
            /// </remarks>
            public clang.RecordDecl buildImplicitRecord(llvm.StringRef Name, clang.TagTypeKind TK)
            {
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var arg1 = TK;
                var __ret = Internal.buildImplicitRecord_0(__Instance, arg0, arg1);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Create a new implicit TU-level typedef declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new implicit TU-level typedef
            /// declaration.</para>
            /// </remarks>
            public clang.TypedefDecl buildImplicitTypedef(clang.QualType T, llvm.StringRef Name)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var __ret = Internal.buildImplicitTypedef_0(__Instance, arg0, arg1);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the declaration for the 128-bit signed integer
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the declaration for the 128-bit signed
            /// integer type.</para>
            /// </remarks>
            public clang.TypedefDecl getInt128Decl()
            {
                var __ret = Internal.getInt128Decl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the declaration for the 128-bit unsigned integer
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the declaration for the 128-bit unsigned
            /// integer type.</para>
            /// </remarks>
            public clang.TypedefDecl getUInt128Decl()
            {
                var __ret = Internal.getUInt128Decl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the declaration for a 128-bit float stub type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the declaration for a 128-bit float stub
            /// type.</para>
            /// </remarks>
            public clang.TypeDecl getFloat128StubType()
            {
                var __ret = Internal.getFloat128StubType_0(__Instance);
                clang.TypeDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeDecl) clang.TypeDecl.NativeToManagedMap[__ret];
                else clang.TypeDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypeDecl) clang.TypeDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for an address space
            /// qualified type with the specified type and address space.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for an
            /// address space</para>
            /// <para>  /// qualified type with the specified type and address
            /// space.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type has a union of the qualifiers from T and
            /// the address</para>
            /// <para>  /// space. If T already has an address space specifier, it is
            /// silently</para>
            /// <para>  /// replaced.</para>
            /// </remarks>
            public clang.QualType getAddrSpaceQualType(clang.QualType T, uint AddressSpace)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAddrSpaceQualType_0(__Instance, arg0, AddressSpace);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for an Objective-C
            /// gc-qualified type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for an
            /// Objective-C</para>
            /// <para>  /// gc-qualified type.</para>
            /// <para>  ///</para>
            /// <para>  /// The retulting type has a union of the qualifiers from T and
            /// the gc</para>
            /// <para>  /// attribute.</para>
            /// </remarks>
            public clang.QualType getObjCGCQualType(clang.QualType T, clang.Qualifiers.GC gcAttr)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = gcAttr;
                var __ret = Internal.getObjCGCQualType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a restrict qualified
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a \c
            /// restrict</para>
            /// <para>  /// qualified type.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type has a union of the qualifiers from \p T
            /// and</para>
            /// <para>  /// \c restrict.</para>
            /// </remarks>
            public clang.QualType getRestrictType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getRestrictType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a volatile qualified
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a \c
            /// volatile</para>
            /// <para>  /// qualified type.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type has a union of the qualifiers from \p T
            /// and</para>
            /// <para>  /// \c volatile.</para>
            /// </remarks>
            public clang.QualType getVolatileType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getVolatileType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a const qualified
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a \c
            /// const</para>
            /// <para>  /// qualified type.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type has a union of the qualifiers from \p T
            /// and \c const.</para>
            /// <para>  ///</para>
            /// <para>  /// It can be reasonably expected that this will always be
            /// equivalent to</para>
            /// <para>  /// calling T.withConst().</para>
            /// </remarks>
            public clang.QualType getConstType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getConstType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Change the ExtInfo on a function type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Change the ExtInfo on a function type.</para>
            /// </remarks>
            public clang.FunctionType adjustFunctionType(clang.FunctionType Fn, clang.FunctionType.ExtInfo EInfo)
            {
                var arg0 = ReferenceEquals(Fn, null) ? global::System.IntPtr.Zero : Fn.__Instance;
                var arg1 = ReferenceEquals(EInfo, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (EInfo.__Instance);
                var __ret = Internal.adjustFunctionType_0(__Instance, arg0, arg1);
                clang.FunctionType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionType) clang.FunctionType.NativeToManagedMap[__ret];
                else __result0 = clang.FunctionType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Change the result type of a function type once it is
            /// deduced.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Change the result type of a function type once it is
            /// deduced.</para>
            /// </remarks>
            public void adjustDeducedFunctionResultType(clang.FunctionDecl FD, clang.QualType ResultType)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var arg1 = ReferenceEquals(ResultType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResultType.__Instance);
                Internal.adjustDeducedFunctionResultType_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Change the exception specification on a function once it is
            /// delay-parsed, instantiated, or computed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Change the exception specification on a function once
            /// it is</para>
            /// <para>  /// delay-parsed, instantiated, or computed.</para>
            /// </remarks>
            public void adjustExceptionSpec(clang.FunctionDecl FD, clang.FunctionProtoType.ExceptionSpecInfo ESI, bool AsWritten)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var arg1 = ReferenceEquals(ESI, null) ? global::System.IntPtr.Zero : ESI.__Instance;
                Internal.adjustExceptionSpec_0(__Instance, arg0, arg1, AsWritten);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a complex number
            /// with the specified element type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a
            /// complex</para>
            /// <para>  /// number with the specified element type.</para>
            /// </remarks>
            public clang.QualType getComplexType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getComplexType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a pointer to the
            /// specified type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a pointer
            /// to</para>
            /// <para>  /// the specified type.</para>
            /// </remarks>
            public clang.QualType getPointerType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getPointerType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to a type adjusted from the original
            /// type to a new type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to a type adjusted from
            /// the original</para>
            /// <para>  /// type to a new type.</para>
            /// </remarks>
            public clang.QualType getAdjustedType(clang.QualType Orig, clang.QualType New)
            {
                var arg0 = ReferenceEquals(Orig, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Orig.__Instance);
                var arg1 = ReferenceEquals(New, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (New.__Instance);
                var __ret = Internal.getAdjustedType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the decayed version of the given
            /// type. Can only be called on array and function types which decay to pointer
            /// types.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the decayed version of
            /// the given</para>
            /// <para>  /// type.  Can only be called on array and function types which
            /// decay to</para>
            /// <para>  /// pointer types.</para>
            /// </remarks>
            public clang.QualType getDecayedType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getDecayedType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the atomic type for the specified
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the atomic type for
            /// the specified</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public clang.QualType getAtomicType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAtomicType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a block of the
            /// specified type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a block
            /// of the</para>
            /// <para>  /// specified type.</para>
            /// </remarks>
            public clang.QualType getBlockPointerType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getBlockPointerType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Gets the struct used to keep track of the descriptor for pointer
            /// to blocks.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the struct used to keep track of the descriptor for
            /// pointer to</para>
            /// <para>  /// blocks.</para>
            /// </remarks>
            public clang.QualType getBlockDescriptorType()
            {
                var __ret = Internal.getBlockDescriptorType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Gets the struct used to keep track of the extended descriptor for
            /// pointer to blocks.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the struct used to keep track of the extended descriptor
            /// for</para>
            /// <para>  /// pointer to blocks.</para>
            /// </remarks>
            public clang.QualType getBlockDescriptorExtendedType()
            {
                var __ret = Internal.getBlockDescriptorExtendedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setcudaConfigureCallDecl(clang.FunctionDecl FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                Internal.setcudaConfigureCallDecl_0(__Instance, arg0);
            }

            public clang.FunctionDecl getcudaConfigureCallDecl()
            {
                var __ret = Internal.getcudaConfigureCallDecl_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns true iff we need copy/dispose helpers for the given
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true iff we need copy/dispose helpers for the given
            /// type.</para>
            /// </remarks>
            public bool BlockRequiresCopying(clang.QualType Ty, clang.VarDecl D)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var arg1 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.BlockRequiresCopying_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true, if given type has a known lifetime.
            /// HasByrefExtendedLayout is set to false in this case. If
            /// HasByrefExtendedLayout returns true, byref variable has extended
            /// lifetime.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true, if given type has a known lifetime.
            /// HasByrefExtendedLayout is set</para>
            /// <para>  /// to false in this case. If HasByrefExtendedLayout returns
            /// true, byref variable</para>
            /// <para>  /// has extended lifetime. </para>
            /// </remarks>
            public bool getByrefLifetime(clang.QualType Ty, clang.Qualifiers.ObjCLifetime* Lifetime, ref bool HasByrefExtendedLayout)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var arg1 = Lifetime;
                fixed (bool* arg2 = &HasByrefExtendedLayout)
                {
                    var __ret = Internal.getByrefLifetime_0(__Instance, arg0, arg1, arg2);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for an lvalue reference
            /// to the specified type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for an lvalue
            /// reference</para>
            /// <para>  /// to the specified type.</para>
            /// </remarks>
            public clang.QualType getLValueReferenceType(clang.QualType T, bool SpelledAsLValue)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getLValueReferenceType_0(__Instance, arg0, SpelledAsLValue);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for an rvalue reference
            /// to the specified type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for an rvalue
            /// reference</para>
            /// <para>  /// to the specified type.</para>
            /// </remarks>
            public clang.QualType getRValueReferenceType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getRValueReferenceType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the uniqued reference to the type for a member pointer to
            /// the specified type in the specified class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued reference to the type for a member
            /// pointer to</para>
            /// <para>  /// the specified type in the specified class.</para>
            /// <para>  ///</para>
            /// <para>  /// The class \p Cls is a \c Type because it could be a
            /// dependent name.</para>
            /// </remarks>
            public clang.QualType getMemberPointerType(clang.QualType T, clang.Type Cls)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Cls, null) ? global::System.IntPtr.Zero : Cls.__Instance;
                var __ret = Internal.getMemberPointerType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a unique reference to the type for an incomplete array of
            /// the specified element type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a unique reference to the type for an
            /// incomplete array of</para>
            /// <para>  /// the specified element type.</para>
            /// </remarks>
            public clang.QualType getIncompleteArrayType(clang.QualType EltTy, clang.ArrayType.ArraySizeModifier ASM, uint IndexTypeQuals)
            {
                var arg0 = ReferenceEquals(EltTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (EltTy.__Instance);
                var arg1 = ASM;
                var __ret = Internal.getIncompleteArrayType_0(__Instance, arg0, arg1, IndexTypeQuals);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to the type for a constant array of
            /// the specified element type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to the type for a constant
            /// array of</para>
            /// <para>  /// the specified element type.</para>
            /// </remarks>
            public clang.QualType getConstantArrayType(clang.QualType EltTy, llvm.APInt ArySize, clang.ArrayType.ArraySizeModifier ASM, uint IndexTypeQuals)
            {
                var arg0 = ReferenceEquals(EltTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (EltTy.__Instance);
                var arg1 = ReferenceEquals(ArySize, null) ? global::System.IntPtr.Zero : ArySize.__Instance;
                var arg2 = ASM;
                var __ret = Internal.getConstantArrayType_0(__Instance, arg0, arg1, arg2, IndexTypeQuals);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns a vla type where known sizes are replaced with
            /// [*].</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns a vla type where known sizes are replaced with
            /// [*].</para>
            /// </remarks>
            public clang.QualType getVariableArrayDecayedType(clang.QualType Ty)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var __ret = Internal.getVariableArrayDecayedType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to a vector type of the specified
            /// element type and size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to a vector type of the
            /// specified</para>
            /// <para>  /// element type and size.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre \p VectorType must be a built-in type.</para>
            /// </remarks>
            public clang.QualType getVectorType(clang.QualType VectorType, uint NumElts, clang.VectorType.VectorKind VecKind)
            {
                var arg0 = ReferenceEquals(VectorType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (VectorType.__Instance);
                var arg2 = VecKind;
                var __ret = Internal.getVectorType_0(__Instance, arg0, NumElts, arg2);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to an extended vector type of the
            /// specified element type and size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to an extended vector
            /// type</para>
            /// <para>  /// of the specified element type and size.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre \p VectorType must be a built-in type.</para>
            /// </remarks>
            public clang.QualType getExtVectorType(clang.QualType VectorType, uint NumElts)
            {
                var arg0 = ReferenceEquals(VectorType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (VectorType.__Instance);
                var __ret = Internal.getExtVectorType_0(__Instance, arg0, NumElts);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a K&amp;R style C function type like 'int()'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a K&amp;R style C function type like
            /// 'int()'.</para>
            /// </remarks>
            public clang.QualType getFunctionNoProtoType(clang.QualType ResultTy, clang.FunctionType.ExtInfo Info)
            {
                var arg0 = ReferenceEquals(ResultTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResultTy.__Instance);
                var arg1 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                var __ret = Internal.getFunctionNoProtoType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getFunctionNoProtoType(clang.QualType ResultTy)
            {
                var arg0 = ReferenceEquals(ResultTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResultTy.__Instance);
                var __ret = Internal.getFunctionNoProtoType_1(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to the type for the specified type
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to the type for the
            /// specified type</para>
            /// <para>  /// declaration.</para>
            /// </remarks>
            public clang.QualType getTypeDeclType(clang.TypeDecl Decl, clang.TypeDecl PrevDecl)
            {
                var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                var arg1 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                var __ret = Internal.getTypeDeclType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to the type for the specified
            /// typedef-name decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to the type for the
            /// specified</para>
            /// <para>  /// typedef-name decl.</para>
            /// </remarks>
            public clang.QualType getTypedefType(clang.TypedefNameDecl Decl, clang.QualType Canon)
            {
                var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                var arg1 = ReferenceEquals(Canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canon.__Instance);
                var __ret = Internal.getTypedefType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getRecordType(clang.RecordDecl Decl)
            {
                var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                var __ret = Internal.getRecordType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getEnumType(clang.EnumDecl Decl)
            {
                var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                var __ret = Internal.getEnumType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getAttributedType(clang.AttributedType.Kind attrKind, clang.QualType modifiedType, clang.QualType equivalentType)
            {
                var arg0 = attrKind;
                var arg1 = ReferenceEquals(modifiedType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (modifiedType.__Instance);
                var arg2 = ReferenceEquals(equivalentType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (equivalentType.__Instance);
                var __ret = Internal.getAttributedType_0(__Instance, arg0, arg1, arg2);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getSubstTemplateTypeParmType(clang.TemplateTypeParmType Replaced, clang.QualType Replacement)
            {
                var arg0 = ReferenceEquals(Replaced, null) ? global::System.IntPtr.Zero : Replaced.__Instance;
                var arg1 = ReferenceEquals(Replacement, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Replacement.__Instance);
                var __ret = Internal.getSubstTemplateTypeParmType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getSubstTemplateTypeParmPackType(clang.TemplateTypeParmType Replaced, clang.TemplateArgument ArgPack)
            {
                var arg0 = ReferenceEquals(Replaced, null) ? global::System.IntPtr.Zero : Replaced.__Instance;
                var arg1 = ReferenceEquals(ArgPack, null) ? global::System.IntPtr.Zero : ArgPack.__Instance;
                var __ret = Internal.getSubstTemplateTypeParmPackType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getTemplateSpecializationType(clang.TemplateName T, clang.TemplateArgument Args, uint NumArgs, clang.QualType Canon)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg3 = ReferenceEquals(Canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canon.__Instance);
                var __ret = Internal.getTemplateSpecializationType_0(__Instance, arg0, arg1, NumArgs, arg3);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getCanonicalTemplateSpecializationType(clang.TemplateName T, clang.TemplateArgument Args, uint NumArgs)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var __ret = Internal.getCanonicalTemplateSpecializationType_0(__Instance, arg0, arg1, NumArgs);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getTemplateSpecializationType(clang.TemplateName T, clang.TemplateArgumentListInfo Args, clang.QualType Canon)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg2 = ReferenceEquals(Canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canon.__Instance);
                var __ret = Internal.getTemplateSpecializationType_1(__Instance, arg0, arg1, arg2);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TypeSourceInfo getTemplateSpecializationTypeInfo(clang.TemplateName T, clang.SourceLocation TLoc, clang.TemplateArgumentListInfo Args, clang.QualType Canon)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(TLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TLoc.__Instance);
                var arg2 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg3 = ReferenceEquals(Canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canon.__Instance);
                var __ret = Internal.getTemplateSpecializationTypeInfo_0(__Instance, arg0, arg1, arg2, arg3);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType getParenType(clang.QualType NamedType)
            {
                var arg0 = ReferenceEquals(NamedType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (NamedType.__Instance);
                var __ret = Internal.getParenType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getElaboratedType(clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.QualType NamedType)
            {
                var arg0 = Keyword;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = ReferenceEquals(NamedType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (NamedType.__Instance);
                var __ret = Internal.getElaboratedType_0(__Instance, arg0, arg1, arg2);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getDependentNameType(clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.IdentifierInfo Name, clang.QualType Canon)
            {
                var arg0 = Keyword;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var arg3 = ReferenceEquals(Canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canon.__Instance);
                var __ret = Internal.getDependentNameType_0(__Instance, arg0, arg1, arg2, arg3);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getDependentTemplateSpecializationType(clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.IdentifierInfo Name, clang.TemplateArgumentListInfo Args)
            {
                var arg0 = Keyword;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var arg3 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var __ret = Internal.getDependentTemplateSpecializationType_0(__Instance, arg0, arg1, arg2, arg3);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getDependentTemplateSpecializationType(clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.IdentifierInfo Name, uint NumArgs, clang.TemplateArgument Args)
            {
                var arg0 = Keyword;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var arg4 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var __ret = Internal.getDependentTemplateSpecializationType_1(__Instance, arg0, arg1, arg2, NumArgs, arg4);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a ObjCObjectPointerType type for the given
            /// ObjCObjectType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a ObjCObjectPointerType type for the given
            /// ObjCObjectType.</para>
            /// </remarks>
            public clang.QualType getObjCObjectPointerType(clang.QualType OIT)
            {
                var arg0 = ReferenceEquals(OIT, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (OIT.__Instance);
                var __ret = Internal.getObjCObjectPointerType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getTypeOfType(clang.QualType t)
            {
                var arg0 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var __ret = Internal.getTypeOfType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Unary type transforms</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Unary type transforms</para>
            /// </remarks>
            public clang.QualType getUnaryTransformType(clang.QualType BaseType, clang.QualType UnderlyingType, clang.UnaryTransformType.UTTKind UKind)
            {
                var arg0 = ReferenceEquals(BaseType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (BaseType.__Instance);
                var arg1 = ReferenceEquals(UnderlyingType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (UnderlyingType.__Instance);
                var arg2 = UKind;
                var __ret = Internal.getUnaryTransformType_0(__Instance, arg0, arg1, arg2);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>C++11 deduced auto type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief C++11 deduced auto type.</para>
            /// </remarks>
            public clang.QualType getAutoType(clang.QualType DeducedType, bool IsDecltypeAuto, bool IsDependent)
            {
                var arg0 = ReferenceEquals(DeducedType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (DeducedType.__Instance);
                var __ret = Internal.getAutoType_0(__Instance, arg0, IsDecltypeAuto, IsDependent);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>C++11 deduction pattern for 'auto' type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief C++11 deduction pattern for 'auto' type.</para>
            /// </remarks>
            public clang.QualType getAutoDeductType()
            {
                var __ret = Internal.getAutoDeductType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>C++11 deduction pattern for 'auto &amp;&amp;' type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief C++11 deduction pattern for 'auto &amp;&amp;'
            /// type.</para>
            /// </remarks>
            public clang.QualType getAutoRRefDeductType()
            {
                var __ret = Internal.getAutoRRefDeductType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique reference to the type for the specified TagDecl
            /// (struct/union/class/enum) decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique reference to the type for the
            /// specified TagDecl</para>
            /// <para>  /// (struct/union/class/enum) decl.</para>
            /// </remarks>
            public clang.QualType getTagDeclType(clang.TagDecl Decl)
            {
                var arg0 = ReferenceEquals(Decl, null) ? global::System.IntPtr.Zero : Decl.__Instance;
                var __ret = Internal.getTagDeclType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique wchar_t type available in C++ (and available as
            /// __wchar_t as a Microsoft extension).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique wchar_t type available in C++ (and
            /// available as</para>
            /// <para>  /// __wchar_t as a Microsoft extension).</para>
            /// </remarks>
            public clang.QualType getWCharType()
            {
                var __ret = Internal.getWCharType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the type of wide characters. In C++, this returns the
            /// unique wchar_t type. In C99, this returns a type compatible with the type
            /// defined in &lt;stddef.h&gt; as defined by the target.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type of wide characters. In C++, this
            /// returns the</para>
            /// <para>  /// unique wchar_t type. In C99, this returns a type compatible
            /// with the type</para>
            /// <para>  /// defined in &lt;stddef.h&gt; as defined by the
            /// target.</para>
            /// </remarks>
            public clang.QualType getWideCharType()
            {
                var __ret = Internal.getWideCharType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the type of &quot;signed wchar_t&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type of &quot;signed wchar_t&quot;.</para>
            /// <para>  ///</para>
            /// <para>  /// Used when in C++, as a GCC extension.</para>
            /// </remarks>
            public clang.QualType getSignedWCharType()
            {
                var __ret = Internal.getSignedWCharType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the type of &quot;unsigned wchar_t&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type of &quot;unsigned
            /// wchar_t&quot;.</para>
            /// <para>  ///</para>
            /// <para>  /// Used when in C++, as a GCC extension.</para>
            /// </remarks>
            public clang.QualType getUnsignedWCharType()
            {
                var __ret = Internal.getUnsignedWCharType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>In C99, this returns a type compatible with the type defined in
            /// &lt;stddef.h&gt; as defined by the target.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief In C99, this returns a type compatible with the
            /// type</para>
            /// <para>  /// defined in &lt;stddef.h&gt; as defined by the
            /// target.</para>
            /// </remarks>
            public clang.QualType getWIntType()
            {
                var __ret = Internal.getWIntType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type compatible with &quot;intptr_t&quot; (C99
            /// 7.18.1.4), as defined by the target.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type compatible with &quot;intptr_t&quot;
            /// (C99 7.18.1.4),</para>
            /// <para>  /// as defined by the target.</para>
            /// </remarks>
            public clang.QualType getIntPtrType()
            {
                var __ret = Internal.getIntPtrType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type compatible with &quot;uintptr_t&quot; (C99
            /// 7.18.1.4), as defined by the target.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type compatible with &quot;uintptr_t&quot;
            /// (C99 7.18.1.4),</para>
            /// <para>  /// as defined by the target.</para>
            /// </remarks>
            public clang.QualType getUIntPtrType()
            {
                var __ret = Internal.getUIntPtrType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique type for &quot;ptrdiff_t&quot; (C99 7.17)
            /// defined in &lt;stddef.h&gt;. Pointer - pointer requires this (C99
            /// 6.5.6p9).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique type for &quot;ptrdiff_t&quot; (C99
            /// 7.17) defined in</para>
            /// <para>  /// &lt;stddef.h&gt;. Pointer - pointer requires this (C99
            /// 6.5.6p9).</para>
            /// </remarks>
            public clang.QualType getPointerDiffType()
            {
                var __ret = Internal.getPointerDiffType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the unique type for &quot;pid_t&quot; defined in
            /// &lt;sys/types.h&gt;. We need this to compute the correct type for
            /// vfork().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the unique type for &quot;pid_t&quot; defined
            /// in</para>
            /// <para>  /// &lt;sys/types.h&gt;. We need this to compute the correct
            /// type for vfork().</para>
            /// </remarks>
            public clang.QualType getProcessIDType()
            {
                var __ret = Internal.getProcessIDType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the C structure type used to represent constant
            /// CFStrings.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the C structure type used to represent constant
            /// CFStrings.</para>
            /// </remarks>
            public clang.QualType getCFConstantStringType()
            {
                var __ret = Internal.getCFConstantStringType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the C struct type for objc_super</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the C struct type for objc_super</para>
            /// </remarks>
            public clang.QualType getObjCSuperType()
            {
                var __ret = Internal.getObjCSuperType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setObjCSuperType(clang.QualType ST)
            {
                var arg0 = ReferenceEquals(ST, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ST.__Instance);
                Internal.setObjCSuperType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Get the structure type used to representation CFStrings, or NULL
            /// if it hasn't yet been built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Get the structure type used to representation CFStrings, or
            /// NULL</para>
            /// <para>  /// if it hasn't yet been built.</para>
            /// </remarks>
            public clang.QualType getRawCFConstantStringType()
            {
                var __ret = Internal.getRawCFConstantStringType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setCFConstantStringType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setCFConstantStringType_0(__Instance, arg0);
            }

            public clang.QualType getObjCConstantStringInterface()
            {
                var __ret = Internal.getObjCConstantStringInterface_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getObjCNSStringType()
            {
                var __ret = Internal.getObjCNSStringType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setObjCNSStringType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setObjCNSStringType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the type that id has been defined to, which may be
            /// different from the built-in id if id has been typedef'd.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type that \c id has been defined to,
            /// which may be</para>
            /// <para>  /// different from the built-in \c id if \c id has been
            /// typedef'd.</para>
            /// </remarks>
            public clang.QualType getObjCIdRedefinitionType()
            {
                var __ret = Internal.getObjCIdRedefinitionType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the user-written type that redefines id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the user-written type that redefines \c id.</para>
            /// </remarks>
            public void setObjCIdRedefinitionType(clang.QualType RedefType)
            {
                var arg0 = ReferenceEquals(RedefType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RedefType.__Instance);
                Internal.setObjCIdRedefinitionType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the type that Class has been defined to, which may be
            /// different from the built-in Class if Class has been typedef'd.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type that \c Class has been defined to,
            /// which may be</para>
            /// <para>  /// different from the built-in \c Class if \c Class has been
            /// typedef'd.</para>
            /// </remarks>
            public clang.QualType getObjCClassRedefinitionType()
            {
                var __ret = Internal.getObjCClassRedefinitionType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the user-written type that redefines 'SEL'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the user-written type that redefines 'SEL'.</para>
            /// </remarks>
            public void setObjCClassRedefinitionType(clang.QualType RedefType)
            {
                var arg0 = ReferenceEquals(RedefType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RedefType.__Instance);
                Internal.setObjCClassRedefinitionType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the type that 'SEL' has been defined to, which may be
            /// different from the built-in 'SEL' if 'SEL' has been typedef'd.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type that 'SEL' has been defined to,
            /// which may be</para>
            /// <para>  /// different from the built-in 'SEL' if 'SEL' has been
            /// typedef'd.</para>
            /// </remarks>
            public clang.QualType getObjCSelRedefinitionType()
            {
                var __ret = Internal.getObjCSelRedefinitionType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the user-written type that redefines 'SEL'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the user-written type that redefines 'SEL'.</para>
            /// </remarks>
            public void setObjCSelRedefinitionType(clang.QualType RedefType)
            {
                var arg0 = ReferenceEquals(RedefType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RedefType.__Instance);
                Internal.setObjCSelRedefinitionType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the Objective-C &quot;instancetype&quot; type, if
            /// already known; otherwise, returns a NULL type;</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the Objective-C &quot;instancetype&quot;
            /// type, if already known;</para>
            /// <para>  /// otherwise, returns a NULL type;</para>
            /// </remarks>
            public clang.QualType getObjCInstanceType()
            {
                var __ret = Internal.getObjCInstanceType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the typedef declaration corresponding to the Objective-C
            /// &quot;instancetype&quot; type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the typedef declaration corresponding to the
            /// Objective-C</para>
            /// <para>  /// &quot;instancetype&quot; type.</para>
            /// </remarks>
            public clang.TypedefDecl getObjCInstanceTypeDecl()
            {
                var __ret = Internal.getObjCInstanceTypeDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set the type for the C FILE type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the type for the C FILE type.</para>
            /// </remarks>
            public void setFILEDecl(clang.TypeDecl FILEDecl)
            {
                var arg0 = ReferenceEquals(FILEDecl, null) ? global::System.IntPtr.Zero : FILEDecl.__Instance;
                Internal.setFILEDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the C FILE type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C FILE type.</para>
            /// </remarks>
            public clang.QualType getFILEType()
            {
                var __ret = Internal.getFILEType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the type for the C jmp_buf type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the type for the C jmp_buf type.</para>
            /// </remarks>
            public void setjmp_bufDecl(clang.TypeDecl jmp_bufDecl)
            {
                var arg0 = ReferenceEquals(jmp_bufDecl, null) ? global::System.IntPtr.Zero : jmp_bufDecl.__Instance;
                Internal.setjmp_bufDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the C jmp_buf type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C jmp_buf type.</para>
            /// </remarks>
            public clang.QualType getjmp_bufType()
            {
                var __ret = Internal.getjmp_bufType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the type for the C sigjmp_buf type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the type for the C sigjmp_buf type.</para>
            /// </remarks>
            public void setsigjmp_bufDecl(clang.TypeDecl sigjmp_bufDecl)
            {
                var arg0 = ReferenceEquals(sigjmp_bufDecl, null) ? global::System.IntPtr.Zero : sigjmp_bufDecl.__Instance;
                Internal.setsigjmp_bufDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the C sigjmp_buf type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C sigjmp_buf type.</para>
            /// </remarks>
            public clang.QualType getsigjmp_bufType()
            {
                var __ret = Internal.getsigjmp_bufType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the type for the C ucontext_t type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the type for the C ucontext_t type.</para>
            /// </remarks>
            public void setucontext_tDecl(clang.TypeDecl ucontext_tDecl)
            {
                var arg0 = ReferenceEquals(ucontext_tDecl, null) ? global::System.IntPtr.Zero : ucontext_tDecl.__Instance;
                Internal.setucontext_tDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the C ucontext_t type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C ucontext_t type.</para>
            /// </remarks>
            public clang.QualType getucontext_tType()
            {
                var __ret = Internal.getucontext_tType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>The result type of logical operations, '&lt;', '&gt;', '!=',
            /// etc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The result type of logical operations, '&lt;', '&gt;',
            /// '!=', etc.</para>
            /// </remarks>
            public clang.QualType getLogicalOperationType()
            {
                var __ret = Internal.getLogicalOperationType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void getLegacyIntegralTypeEncoding(clang.QualType t)
            {
                var arg0 = ReferenceEquals(t, null) ? global::System.IntPtr.Zero : t.__Instance;
                Internal.getLegacyIntegralTypeEncoding_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the size of type T for Objective-C encoding purpose, in
            /// characters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the size of type \p T for Objective-C encoding
            /// purpose,</para>
            /// <para>  /// in characters.</para>
            /// </remarks>
            public clang.CharUnits getObjCEncodingTypeSize(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getObjCEncodingTypeSize_0(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the typedef corresponding to the predefined id type in
            /// Objective-C.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the typedef corresponding to the predefined
            /// \c id type</para>
            /// <para>  /// in Objective-C.</para>
            /// </remarks>
            public clang.TypedefDecl getObjCIdDecl()
            {
                var __ret = Internal.getObjCIdDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Represents the Objective-CC id type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Represents the Objective-CC \c id type.</para>
            /// <para>  ///</para>
            /// <para>  /// This is set up lazily, by Sema.  \c id is always a (typedef
            /// for a)</para>
            /// <para>  /// pointer type, a pointer to a struct.</para>
            /// </remarks>
            public clang.QualType getObjCIdType()
            {
                var __ret = Internal.getObjCIdType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the typedef corresponding to the predefined 'SEL' type
            /// in Objective-C.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the typedef corresponding to the predefined
            /// 'SEL' type</para>
            /// <para>  /// in Objective-C.</para>
            /// </remarks>
            public clang.TypedefDecl getObjCSelDecl()
            {
                var __ret = Internal.getObjCSelDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the type that corresponds to the predefined Objective-C
            /// 'SEL' type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type that corresponds to the predefined
            /// Objective-C</para>
            /// <para>  /// 'SEL' type.</para>
            /// </remarks>
            public clang.QualType getObjCSelType()
            {
                var __ret = Internal.getObjCSelType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the typedef declaration corresponding to the predefined
            /// Objective-C 'Class' type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the typedef declaration corresponding to the
            /// predefined</para>
            /// <para>  /// Objective-C 'Class' type.</para>
            /// </remarks>
            public clang.TypedefDecl getObjCClassDecl()
            {
                var __ret = Internal.getObjCClassDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Represents the Objective-C Class type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Represents the Objective-C \c Class type.</para>
            /// <para>  ///</para>
            /// <para>  /// This is set up lazily, by Sema.  \c Class is always a
            /// (typedef for a)</para>
            /// <para>  /// pointer type, a pointer to a struct.</para>
            /// </remarks>
            public clang.QualType getObjCClassType()
            {
                var __ret = Internal.getObjCClassType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve declaration of 'BOOL' typedef</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve declaration of 'BOOL' typedef</para>
            /// </remarks>
            public clang.TypedefDecl getBOOLDecl()
            {
                var __ret = Internal.getBOOLDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Save declaration of 'BOOL' typedef</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Save declaration of 'BOOL' typedef</para>
            /// </remarks>
            public void setBOOLDecl(clang.TypedefDecl TD)
            {
                var arg0 = ReferenceEquals(TD, null) ? global::System.IntPtr.Zero : TD.__Instance;
                Internal.setBOOLDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>type of 'BOOL' type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief type of 'BOOL' type.</para>
            /// </remarks>
            public clang.QualType getBOOLType()
            {
                var __ret = Internal.getBOOLType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the type of the Objective-C Protocol class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type of the Objective-C \c Protocol
            /// class.</para>
            /// </remarks>
            public clang.QualType getObjCProtoType()
            {
                var __ret = Internal.getObjCProtoType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the C type declaration corresponding to the predefined
            /// __builtin_va_list type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C type declaration corresponding to the
            /// predefined</para>
            /// <para>  /// \c __builtin_va_list type.</para>
            /// </remarks>
            public clang.TypedefDecl getBuiltinVaListDecl()
            {
                var __ret = Internal.getBuiltinVaListDecl_0(__Instance);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the type of the __builtin_va_list type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type of the \c __builtin_va_list
            /// type.</para>
            /// </remarks>
            public clang.QualType getBuiltinVaListType()
            {
                var __ret = Internal.getBuiltinVaListType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the C type declaration corresponding to the predefined
            /// __va_list_tag type used to help define the __builtin_va_list type for some
            /// targets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the C type declaration corresponding to the
            /// predefined</para>
            /// <para>  /// \c __va_list_tag type used to help define the \c
            /// __builtin_va_list type</para>
            /// <para>  /// for some targets.</para>
            /// </remarks>
            public clang.QualType getVaListTagType()
            {
                var __ret = Internal.getVaListTagType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type with additional const, volatile, or restrict
            /// qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type with additional \c const, \c volatile,
            /// or</para>
            /// <para>  /// \c restrict qualifiers.</para>
            /// </remarks>
            public clang.QualType getCVRQualifiedType(clang.QualType T, uint CVR)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getCVRQualifiedType_0(__Instance, arg0, CVR);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Un-split a SplitQualType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Un-split a SplitQualType.</para>
            /// </remarks>
            public clang.QualType getQualifiedType(clang.SplitQualType split)
            {
                var arg0 = ReferenceEquals(split, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (split.__Instance);
                var __ret = Internal.getQualifiedType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type with additional qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type with additional qualifiers.</para>
            /// </remarks>
            public clang.QualType getQualifiedType(clang.QualType T, clang.Qualifiers Qs)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Qs.__Instance);
                var __ret = Internal.getQualifiedType_1(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type with additional qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type with additional qualifiers.</para>
            /// </remarks>
            public clang.QualType getQualifiedType(clang.Type T, clang.Qualifiers Qs)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var arg1 = ReferenceEquals(Qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Qs.__Instance);
                var __ret = Internal.getQualifiedType_2(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a type with the given lifetime qualifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a type with the given lifetime
            /// qualifier.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre Neither type.ObjCLifetime() nor \p lifetime may be \c
            /// OCL_None.</para>
            /// </remarks>
            public clang.QualType getLifetimeQualifiedType(clang.QualType type, clang.Qualifiers.ObjCLifetime lifetime)
            {
                var arg0 = ReferenceEquals(type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (type.__Instance);
                var arg1 = lifetime;
                var __ret = Internal.getLifetimeQualifiedType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getUnqualifiedObjCPointerType - Returns version of Objective-C
            /// pointer type with lifetime qualifier removed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getUnqualifiedObjCPointerType - Returns version of</para>
            /// <para>  /// Objective-C pointer type with lifetime qualifier
            /// removed.</para>
            /// </remarks>
            public clang.QualType getUnqualifiedObjCPointerType(clang.QualType type)
            {
                var arg0 = ReferenceEquals(type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (type.__Instance);
                var __ret = Internal.getUnqualifiedObjCPointerType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.DeclarationNameInfo getNameForTemplate(clang.TemplateName Name, clang.SourceLocation NameLoc)
            {
                var arg0 = ReferenceEquals(Name, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (Name.__Instance);
                var arg1 = ReferenceEquals(NameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NameLoc.__Instance);
                var __ret = new clang.DeclarationNameInfo.Internal();
                Internal.getNameForTemplate_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                return clang.DeclarationNameInfo.__CreateInstance(__ret);
            }

            public clang.TemplateName getDependentTemplateName(clang.NestedNameSpecifier NNS, clang.IdentifierInfo Name)
            {
                var arg0 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg1 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var __ret = Internal.getDependentTemplateName_0(__Instance, arg0, arg1);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            public clang.TemplateName getDependentTemplateName(clang.NestedNameSpecifier NNS, clang.OverloadedOperatorKind Operator)
            {
                var arg0 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg1 = Operator;
                var __ret = Internal.getDependentTemplateName_1(__Instance, arg0, arg1);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the type for the specified builtin.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type for the specified builtin.</para>
            /// <para>  ///</para>
            /// <para>  /// If \p IntegerConstantArgs is non-null, it is filled in with
            /// a bitmask of</para>
            /// <para>  /// arguments to the builtin that are required to be integer
            /// constant</para>
            /// <para>  /// expressions.</para>
            /// </remarks>
            public clang.QualType GetBuiltinType(uint ID, clang.ASTContext.GetBuiltinTypeError* Error, ref uint IntegerConstantArgs)
            {
                var arg1 = Error;
                fixed (uint* arg2 = &IntegerConstantArgs)
                {
                    var __ret = Internal.GetBuiltinType_0(__Instance, ID, arg1, arg2);
                    return clang.QualType.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>Return one of the GCNone, Weak or Strong Objective-C garbage
            /// collection attributes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return one of the GCNone, Weak or Strong Objective-C
            /// garbage</para>
            /// <para>  /// collection attributes.</para>
            /// </remarks>
            public clang.Qualifiers.GC getObjCGCAttrKind(clang.QualType Ty)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var __ret = Internal.getObjCGCAttrKind_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if the given vector types are of the same unqualified
            /// type or if they are equivalent to the same GCC vector type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the given vector types are of the same
            /// unqualified</para>
            /// <para>  /// type or if they are equivalent to the same GCC vector
            /// type.</para>
            /// <para>  ///</para>
            /// <para>  /// \note This ignores whether they are target-specific
            /// (AltiVec or Neon)</para>
            /// <para>  /// types.</para>
            /// </remarks>
            public bool areCompatibleVectorTypes(clang.QualType FirstVec, clang.QualType SecondVec)
            {
                var arg0 = ReferenceEquals(FirstVec, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (FirstVec.__Instance);
                var arg1 = ReferenceEquals(SecondVec, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (SecondVec.__Instance);
                var __ret = Internal.areCompatibleVectorTypes_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Get the size and alignment of the specified complete type in
            /// bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the size and alignment of the specified complete
            /// type in bits.</para>
            /// </remarks>
            public clang.TypeInfo getTypeInfo(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getTypeInfo_0(__Instance, arg0);
                return clang.TypeInfo.__CreateInstance(__ret);
            }

            public clang.TypeInfo getTypeInfo(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTypeInfo_1(__Instance, arg0);
                return clang.TypeInfo.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the size of the specified (complete) type T, in
            /// bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the size of the specified (complete) type \p T,
            /// in bits.</para>
            /// </remarks>
            public ulong getTypeSize(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTypeSize_0(__Instance, arg0);
                return __ret;
            }

            public ulong getTypeSize(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getTypeSize_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the size of the character type, in bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the size of the character type, in bits.</para>
            /// </remarks>
            public ulong getCharWidth()
            {
                var __ret = Internal.getCharWidth_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Convert a size in bits to a size in characters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Convert a size in bits to a size in characters.</para>
            /// </remarks>
            public clang.CharUnits toCharUnitsFromBits(long BitSize)
            {
                var arg0 = BitSize;
                var __ret = Internal.toCharUnitsFromBits_0(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Convert a size in characters to a size in bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Convert a size in characters to a size in bits.</para>
            /// </remarks>
            public long toBits(clang.CharUnits CharSize)
            {
                var arg0 = ReferenceEquals(CharSize, null) ? new clang.CharUnits.Internal() : *(clang.CharUnits.Internal*) (CharSize.__Instance);
                var __ret = Internal.toBits_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the size of the specified (complete) type T, in
            /// characters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the size of the specified (complete) type \p T,
            /// in</para>
            /// <para>  /// characters.</para>
            /// </remarks>
            public clang.CharUnits getTypeSizeInChars(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTypeSizeInChars_0(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            public clang.CharUnits getTypeSizeInChars(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getTypeSizeInChars_1(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the ABI-specified alignment of a (complete) type T, in
            /// bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the ABI-specified alignment of a (complete)
            /// type \p T, in</para>
            /// <para>  /// bits.</para>
            /// </remarks>
            public uint getTypeAlign(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTypeAlign_0(__Instance, arg0);
                return __ret;
            }

            public uint getTypeAlign(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getTypeAlign_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the ABI-specified alignment of a (complete) type T, in
            /// characters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the ABI-specified alignment of a (complete)
            /// type \p T, in </para>
            /// <para>  /// characters.</para>
            /// </remarks>
            public clang.CharUnits getTypeAlignInChars(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTypeAlignInChars_0(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            public clang.CharUnits getTypeAlignInChars(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getTypeAlignInChars_1(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine if the alignment the type has was required using an
            /// alignment attribute.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if the alignment the type has was required
            /// using an</para>
            /// <para>  /// alignment attribute.</para>
            /// </remarks>
            public bool isAlignmentRequired(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.isAlignmentRequired_0(__Instance, arg0);
                return __ret;
            }

            public bool isAlignmentRequired(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.isAlignmentRequired_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the &quot;preferred&quot; alignment of the specified type
            /// T for the current target, in bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the &quot;preferred&quot; alignment of the
            /// specified type \p T for</para>
            /// <para>  /// the current target, in bits.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be different than the ABI alignment in cases where
            /// it is</para>
            /// <para>  /// beneficial for performance to overalign a data type.</para>
            /// </remarks>
            public uint getPreferredTypeAlign(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getPreferredTypeAlign_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the alignment in bits that should be given to a global
            /// variable with type T.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the alignment in bits that should be given to
            /// a</para>
            /// <para>  /// global variable with type \p T.</para>
            /// </remarks>
            public uint getAlignOfGlobalVar(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAlignOfGlobalVar_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the alignment in characters that should be given to a
            /// global variable with type T.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the alignment in characters that should be
            /// given to a</para>
            /// <para>  /// global variable with type \p T.</para>
            /// </remarks>
            public clang.CharUnits getAlignOfGlobalVarInChars(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAlignOfGlobalVarInChars_0(__Instance, arg0);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a conservative estimate of the alignment of the specified
            /// decl D.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a conservative estimate of the alignment of the
            /// specified</para>
            /// <para>  /// decl \p D.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre \p D must not be a bitfield type, as bitfields do not
            /// have a valid</para>
            /// <para>  /// alignment.</para>
            /// <para>  ///</para>
            /// <para>  /// If \p ForAlignof, references are treated like their
            /// underlying type</para>
            /// <para>  /// and  large arrays don't get any special treatment. If not
            /// \p ForAlignof</para>
            /// <para>  /// it computes the value expected by CodeGen: references are
            /// treated like</para>
            /// <para>  /// pointers and large arrays get extra alignment.</para>
            /// </remarks>
            public clang.CharUnits getDeclAlign(clang.Decl D, bool ForAlignof)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getDeclAlign_0(__Instance, arg0, ForAlignof);
                return clang.CharUnits.__CreateInstance(__ret);
            }

            public void DumpRecordLayout(clang.RecordDecl RD, llvm.raw_ostream OS, bool Simple)
            {
                var arg0 = ReferenceEquals(RD, null) ? global::System.IntPtr.Zero : RD.__Instance;
                var arg1 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.DumpRecordLayout_0(__Instance, arg0, arg1, Simple);
            }

            /// <summary>
            /// <para>Get the offset of a FieldDecl or IndirectFieldDecl, in
            /// bits.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Get the offset of a FieldDecl or IndirectFieldDecl, in
            /// bits.</para>
            /// </remarks>
            public ulong getFieldOffset(clang.ValueDecl FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var __ret = Internal.getFieldOffset_0(__Instance, arg0);
                return __ret;
            }

            public clang.Type getCanonicalType(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.getCanonicalType_1(__Instance, arg0);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether the given types T1 and T2 are
            /// equivalent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the given types \p T1 and \p T2 are
            /// equivalent.</para>
            /// </remarks>
            public bool hasSameType(clang.QualType T1, clang.QualType T2)
            {
                var arg0 = ReferenceEquals(T1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T1.__Instance);
                var arg1 = ReferenceEquals(T2, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T2.__Instance);
                var __ret = Internal.hasSameType_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool hasSameType(clang.Type T1, clang.Type T2)
            {
                var arg0 = ReferenceEquals(T1, null) ? global::System.IntPtr.Zero : T1.__Instance;
                var arg1 = ReferenceEquals(T2, null) ? global::System.IntPtr.Zero : T2.__Instance;
                var __ret = Internal.hasSameType_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Return this type as a completely-unqualified array type,
            /// capturing the qualifiers in Quals.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return this type as a completely-unqualified array
            /// type,</para>
            /// <para>  /// capturing the qualifiers in \p Quals.</para>
            /// <para>  ///</para>
            /// <para>  /// This will remove the minimal amount of sugaring from the
            /// types, similar</para>
            /// <para>  /// to the behavior of QualType::getUnqualifiedType().</para>
            /// <para>  ///</para>
            /// <para>  /// \param T is the qualified type, which may be an
            /// ArrayType</para>
            /// <para>  ///</para>
            /// <para>  /// \param Quals will receive the full set of qualifiers that
            /// were</para>
            /// <para>  /// applied to the array.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns if this is an array type, the completely
            /// unqualified array type</para>
            /// <para>  /// that corresponds to it. Otherwise, returns
            /// T.getUnqualifiedType().</para>
            /// </remarks>
            public clang.QualType getUnqualifiedArrayType(clang.QualType T, clang.Qualifiers Quals)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Quals, null) ? global::System.IntPtr.Zero : Quals.__Instance;
                var __ret = Internal.getUnqualifiedArrayType_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether the given types are equivalent after
            /// cvr-qualifiers have been removed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the given types are equivalent
            /// after</para>
            /// <para>  /// cvr-qualifiers have been removed.</para>
            /// </remarks>
            public bool hasSameUnqualifiedType(clang.QualType T1, clang.QualType T2)
            {
                var arg0 = ReferenceEquals(T1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T1.__Instance);
                var arg1 = ReferenceEquals(T2, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T2.__Instance);
                var __ret = Internal.hasSameUnqualifiedType_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool UnwrapSimilarPointerTypes(clang.QualType T1, clang.QualType T2)
            {
                var arg0 = ReferenceEquals(T1, null) ? global::System.IntPtr.Zero : T1.__Instance;
                var arg1 = ReferenceEquals(T2, null) ? global::System.IntPtr.Zero : T2.__Instance;
                var __ret = Internal.UnwrapSimilarPointerTypes_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieves the &quot;canonical&quot; nested name specifier for a
            /// given nested name specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the &quot;canonical&quot; nested name
            /// specifier for a</para>
            /// <para>  /// given nested name specifier.</para>
            /// <para>  ///</para>
            /// <para>  /// The canonical nested name specifier is a nested name
            /// specifier</para>
            /// <para>  /// that uniquely identifies a type or namespace within the
            /// type</para>
            /// <para>  /// system. For example, given:</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// namespace N {</para>
            /// <para>  ///   struct S {</para>
            /// <para>  ///     template&lt;typename T&gt; struct X { typename T* type;
            /// };</para>
            /// <para>  ///   };</para>
            /// <para>  /// }</para>
            /// <para>  ///</para>
            /// <para>  /// template&lt;typename T&gt; struct Y {</para>
            /// <para>  ///   typename N::S::X&lt;T&gt;::type member;</para>
            /// <para>  /// };</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// <para>  /// Here, the nested-name-specifier for N::S::X&lt;T&gt;:: will
            /// be</para>
            /// <para>  /// S::X&lt;template-param-0-0&gt;, since 'S' and 'X' are
            /// uniquely defined</para>
            /// <para>  /// by declarations in the type system and the canonical type
            /// for</para>
            /// <para>  /// the template type parameter 'T' is
            /// template-param-0-0.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getCanonicalNestedNameSpecifier(clang.NestedNameSpecifier NNS)
            {
                var arg0 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var __ret = Internal.getCanonicalNestedNameSpecifier_0(__Instance, arg0);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves the default calling convention for the current
            /// target.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the default calling convention for the
            /// current target.</para>
            /// </remarks>
            public clang.CallingConv getDefaultCallingConvention(bool isVariadic, bool IsCXXMethod)
            {
                var __ret = Internal.getDefaultCallingConvention_0(__Instance, isVariadic, IsCXXMethod);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieves the &quot;canonical&quot; template name that refers to
            /// a given template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the &quot;canonical&quot; template name that
            /// refers to a</para>
            /// <para>  /// given template.</para>
            /// <para>  ///</para>
            /// <para>  /// The canonical template name is the simplest expression that
            /// can</para>
            /// <para>  /// be used to refer to a given template. For most templates,
            /// this</para>
            /// <para>  /// expression is just the template declaration itself. For
            /// example,</para>
            /// <para>  /// the template std::vector can be referred to via a variety
            /// of</para>
            /// <para>  /// names---std::vector, \::std::vector, vector (if vector is
            /// in</para>
            /// <para>  /// scope), etc.---but all of these names map down to the
            /// same</para>
            /// <para>  /// TemplateDecl, which is used to form the canonical template
            /// name.</para>
            /// <para>  ///</para>
            /// <para>  /// Dependent template names are more interesting. Here,
            /// the</para>
            /// <para>  /// template name could be something like T::template apply
            /// or</para>
            /// <para>  /// std::allocator&lt;T&gt;::template rebind, where the nested
            /// name</para>
            /// <para>  /// specifier itself is dependent. In this case, the
            /// canonical</para>
            /// <para>  /// template name uses the shortest form of the
            /// dependent</para>
            /// <para>  /// nested-name-specifier, which itself contains all
            /// canonical</para>
            /// <para>  /// types, values, and templates.</para>
            /// </remarks>
            public clang.TemplateName getCanonicalTemplateName(clang.TemplateName Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (Name.__Instance);
                var __ret = Internal.getCanonicalTemplateName_0(__Instance, arg0);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether the given template names refer to the same
            /// template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the given template names refer to
            /// the same</para>
            /// <para>  /// template.</para>
            /// </remarks>
            public bool hasSameTemplateName(clang.TemplateName X, clang.TemplateName Y)
            {
                var arg0 = ReferenceEquals(X, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (X.__Instance);
                var arg1 = ReferenceEquals(Y, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (Y.__Instance);
                var __ret = Internal.hasSameTemplateName_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the &quot;canonical&quot; template argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the &quot;canonical&quot; template
            /// argument.</para>
            /// <para>  ///</para>
            /// <para>  /// The canonical template argument is the simplest template
            /// argument</para>
            /// <para>  /// (which may be a type, value, expression, or declaration)
            /// that</para>
            /// <para>  /// expresses the value of the argument.</para>
            /// </remarks>
            public clang.TemplateArgument getCanonicalTemplateArgument(clang.TemplateArgument Arg)
            {
                var arg0 = ReferenceEquals(Arg, null) ? global::System.IntPtr.Zero : Arg.__Instance;
                var __ret = new clang.TemplateArgument.Internal();
                Internal.getCanonicalTemplateArgument_0(new IntPtr(&__ret), __Instance, arg0);
                return clang.TemplateArgument.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Type Query functions. If the type is an instance of the specified
            /// class, return the Type pointer for the underlying maximally pretty type.
            /// This is a member of ASTContext because this may need to do some amount of
            /// canonicalization, e.g. to move type qualifiers into the element
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Type Query functions.  If the type is an instance of the
            /// specified class,</para>
            /// <para>  /// return the Type pointer for the underlying maximally pretty
            /// type.  This</para>
            /// <para>  /// is a member of ASTContext because this may need to do some
            /// amount of</para>
            /// <para>  /// canonicalization, e.g. to move type qualifiers into the
            /// element type.</para>
            /// </remarks>
            public clang.ArrayType getAsArrayType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAsArrayType_0(__Instance, arg0);
                clang.ArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ArrayType) clang.ArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.ArrayType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ConstantArrayType getAsConstantArrayType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAsConstantArrayType_0(__Instance, arg0);
                clang.ConstantArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ConstantArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ConstantArrayType) clang.ConstantArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.ConstantArrayType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.VariableArrayType getAsVariableArrayType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAsVariableArrayType_0(__Instance, arg0);
                clang.VariableArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VariableArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VariableArrayType) clang.VariableArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.VariableArrayType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.IncompleteArrayType getAsIncompleteArrayType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAsIncompleteArrayType_0(__Instance, arg0);
                clang.IncompleteArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IncompleteArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IncompleteArrayType) clang.IncompleteArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.IncompleteArrayType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DependentSizedArrayType getAsDependentSizedArrayType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAsDependentSizedArrayType_0(__Instance, arg0);
                clang.DependentSizedArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DependentSizedArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DependentSizedArrayType) clang.DependentSizedArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.DependentSizedArrayType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the innermost element type of an array type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the innermost element type of an array
            /// type.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, will return &quot;int&quot; for
            /// int[m][n]</para>
            /// </remarks>
            public clang.QualType getBaseElementType(clang.ArrayType VAT)
            {
                var arg0 = ReferenceEquals(VAT, null) ? global::System.IntPtr.Zero : VAT.__Instance;
                var __ret = Internal.getBaseElementType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the innermost element type of a type (which needn't
            /// actually be an array type).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the innermost element type of a type (which
            /// needn't</para>
            /// <para>  /// actually be an array type).</para>
            /// </remarks>
            public clang.QualType getBaseElementType(clang.QualType QT)
            {
                var arg0 = ReferenceEquals(QT, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (QT.__Instance);
                var __ret = Internal.getBaseElementType_1(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return number of constant array elements.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return number of constant array elements.</para>
            /// </remarks>
            public ulong getConstantArrayElementCount(clang.ConstantArrayType CA)
            {
                var arg0 = ReferenceEquals(CA, null) ? global::System.IntPtr.Zero : CA.__Instance;
                var __ret = Internal.getConstantArrayElementCount_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Perform adjustment on the parameter type of a function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Perform adjustment on the parameter type of a
            /// function.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine adjusts the given parameter type @p T to the
            /// actual</para>
            /// <para>  /// parameter type used by semantic analysis (C99
            /// 6.7.5.3p[7,8],</para>
            /// <para>  /// C++ [dcl.fct]p3). The adjusted parameter type is
            /// returned.</para>
            /// </remarks>
            public clang.QualType getAdjustedParameterType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getAdjustedParameterType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the parameter type as adjusted for use in the signature
            /// of a function, decaying array and function types and removing top-level
            /// cv-qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the parameter type as adjusted for use in the
            /// signature</para>
            /// <para>  /// of a function, decaying array and function types and
            /// removing top-level</para>
            /// <para>  /// cv-qualifiers.</para>
            /// </remarks>
            public clang.QualType getSignatureParameterType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getSignatureParameterType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the properly qualified result of decaying the specified
            /// array type to a pointer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the properly qualified result of decaying the
            /// specified</para>
            /// <para>  /// array type to a pointer.</para>
            /// <para>  ///</para>
            /// <para>  /// This operation is non-trivial when handling typedefs etc.
            /// The canonical</para>
            /// <para>  /// type of \p T must be an array type, this returns a pointer
            /// to a properly</para>
            /// <para>  /// qualified element of the array.</para>
            /// <para>  ///</para>
            /// <para>  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.</para>
            /// </remarks>
            public clang.QualType getArrayDecayedType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getArrayDecayedType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the type that PromotableType will promote to: C99
            /// 6.3.1.1p2, assuming that PromotableType is a promotable integer
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type that \p PromotableType will promote
            /// to: C99</para>
            /// <para>  /// 6.3.1.1p2, assuming that \p PromotableType is a promotable
            /// integer type.</para>
            /// </remarks>
            public clang.QualType getPromotedIntegerType(clang.QualType PromotableType)
            {
                var arg0 = ReferenceEquals(PromotableType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (PromotableType.__Instance);
                var __ret = Internal.getPromotedIntegerType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Recurses in pointer/array types until it finds an Objective-C
            /// retainable type and returns its ownership.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Recurses in pointer/array types until it finds an
            /// Objective-C</para>
            /// <para>  /// retainable type and returns its ownership.</para>
            /// </remarks>
            public clang.Qualifiers.ObjCLifetime getInnerObjCOwnership(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getInnerObjCOwnership_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Return the highest ranked integer type, see C99 6.3.1.8p1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the highest ranked integer type, see C99
            /// 6.3.1.8p1. </para>
            /// <para>  ///</para>
            /// <para>  /// If \p LHS &gt; \p RHS, returns 1.  If \p LHS == \p RHS,
            /// returns 0.  If</para>
            /// <para>  /// \p LHS &lt; \p RHS, return -1.</para>
            /// </remarks>
            public int getIntegerTypeOrder(clang.QualType LHS, clang.QualType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RHS.__Instance);
                var __ret = Internal.getIntegerTypeOrder_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Compare the rank of the two specified floating point types,
            /// ignoring the domain of the type (i.e. 'double' == '_Complex
            /// double').</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compare the rank of the two specified floating point
            /// types,</para>
            /// <para>  /// ignoring the domain of the type (i.e. 'double' == '_Complex
            /// double').</para>
            /// <para>  ///</para>
            /// <para>  /// If \p LHS &gt; \p RHS, returns 1.  If \p LHS == \p RHS,
            /// returns 0.  If</para>
            /// <para>  /// \p LHS &lt; \p RHS, return -1.</para>
            /// </remarks>
            public int getFloatingTypeOrder(clang.QualType LHS, clang.QualType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RHS.__Instance);
                var __ret = Internal.getFloatingTypeOrder_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Return a real floating point or a complex type (based on
            /// typeDomain/ typeSize).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a real floating point or a complex type (based
            /// on</para>
            /// <para>  /// \p typeDomain/\p typeSize).</para>
            /// <para>  ///</para>
            /// <para>  /// \param typeDomain a real floating point or complex
            /// type.</para>
            /// <para>  /// \param typeSize a real floating point or complex
            /// type.</para>
            /// </remarks>
            public clang.QualType getFloatingTypeOfSizeWithinDomain(clang.QualType typeSize, clang.QualType typeDomain)
            {
                var arg0 = ReferenceEquals(typeSize, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (typeSize.__Instance);
                var arg1 = ReferenceEquals(typeDomain, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (typeDomain.__Instance);
                var __ret = Internal.getFloatingTypeOfSizeWithinDomain_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public uint getTargetAddressSpace(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getTargetAddressSpace_0(__Instance, arg0);
                return __ret;
            }

            public uint getTargetAddressSpace(clang.Qualifiers Q)
            {
                var arg0 = ReferenceEquals(Q, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Q.__Instance);
                var __ret = Internal.getTargetAddressSpace_1(__Instance, arg0);
                return __ret;
            }

            public uint getTargetAddressSpace(uint AS)
            {
                var __ret = Internal.getTargetAddressSpace_2(__Instance, AS);
                return __ret;
            }

            public bool addressSpaceMapManglingFor(uint AS)
            {
                var __ret = Internal.addressSpaceMapManglingFor_0(__Instance, AS);
                return __ret;
            }

            /// <summary>
            /// <para>Compatibility predicates used to check assignment
            /// expressions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Compatibility predicates used to check assignment
            /// expressions.</para>
            /// </remarks>
            public bool typesAreCompatible(clang.QualType T1, clang.QualType T2, bool CompareUnqualified)
            {
                var arg0 = ReferenceEquals(T1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T1.__Instance);
                var arg1 = ReferenceEquals(T2, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T2.__Instance);
                var __ret = Internal.typesAreCompatible_0(__Instance, arg0, arg1, CompareUnqualified);
                return __ret;
            }

            public bool propertyTypesAreCompatible(clang.QualType _0, clang.QualType _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.propertyTypesAreCompatible_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool typesAreBlockPointerCompatible(clang.QualType _0, clang.QualType _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.typesAreBlockPointerCompatible_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool isObjCIdType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.isObjCIdType_0(__Instance, arg0);
                return __ret;
            }

            public bool isObjCClassType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.isObjCClassType_0(__Instance, arg0);
                return __ret;
            }

            public bool isObjCSelType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.isObjCSelType_0(__Instance, arg0);
                return __ret;
            }

            public bool ObjCQualifiedIdTypesAreCompatible(clang.QualType LHS, clang.QualType RHS, bool ForCompare)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RHS.__Instance);
                var __ret = Internal.ObjCQualifiedIdTypesAreCompatible_0(__Instance, arg0, arg1, ForCompare);
                return __ret;
            }

            public bool ObjCQualifiedClassTypesAreCompatible(clang.QualType LHS, clang.QualType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RHS.__Instance);
                var __ret = Internal.ObjCQualifiedClassTypesAreCompatible_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool canAssignObjCInterfaces(clang.ObjCObjectPointerType LHSOPT, clang.ObjCObjectPointerType RHSOPT)
            {
                var arg0 = ReferenceEquals(LHSOPT, null) ? global::System.IntPtr.Zero : LHSOPT.__Instance;
                var arg1 = ReferenceEquals(RHSOPT, null) ? global::System.IntPtr.Zero : RHSOPT.__Instance;
                var __ret = Internal.canAssignObjCInterfaces_0(__Instance, arg0, arg1);
                return __ret;
            }

            public bool canAssignObjCInterfaces(clang.ObjCObjectType LHS, clang.ObjCObjectType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.canAssignObjCInterfaces_1(__Instance, arg0, arg1);
                return __ret;
            }

            public bool canAssignObjCInterfacesInBlockPointer(clang.ObjCObjectPointerType LHSOPT, clang.ObjCObjectPointerType RHSOPT, bool BlockReturnType)
            {
                var arg0 = ReferenceEquals(LHSOPT, null) ? global::System.IntPtr.Zero : LHSOPT.__Instance;
                var arg1 = ReferenceEquals(RHSOPT, null) ? global::System.IntPtr.Zero : RHSOPT.__Instance;
                var __ret = Internal.canAssignObjCInterfacesInBlockPointer_0(__Instance, arg0, arg1, BlockReturnType);
                return __ret;
            }

            public bool areComparableObjCPointerTypes(clang.QualType LHS, clang.QualType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (RHS.__Instance);
                var __ret = Internal.areComparableObjCPointerTypes_0(__Instance, arg0, arg1);
                return __ret;
            }

            public clang.QualType areCommonBaseCompatible(clang.ObjCObjectPointerType LHSOPT, clang.ObjCObjectPointerType RHSOPT)
            {
                var arg0 = ReferenceEquals(LHSOPT, null) ? global::System.IntPtr.Zero : LHSOPT.__Instance;
                var arg1 = ReferenceEquals(RHSOPT, null) ? global::System.IntPtr.Zero : RHSOPT.__Instance;
                var __ret = Internal.areCommonBaseCompatible_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool canBindObjCObjectType(clang.QualType To, clang.QualType From)
            {
                var arg0 = ReferenceEquals(To, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (To.__Instance);
                var arg1 = ReferenceEquals(From, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (From.__Instance);
                var __ret = Internal.canBindObjCObjectType_0(__Instance, arg0, arg1);
                return __ret;
            }

            public clang.QualType mergeTypes(clang.QualType _0, clang.QualType _1, bool OfBlockPointer, bool Unqualified, bool BlockReturnType)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.mergeTypes_0(__Instance, arg0, arg1, OfBlockPointer, Unqualified, BlockReturnType);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType mergeFunctionTypes(clang.QualType _0, clang.QualType _1, bool OfBlockPointer, bool Unqualified)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.mergeFunctionTypes_0(__Instance, arg0, arg1, OfBlockPointer, Unqualified);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType mergeFunctionParameterTypes(clang.QualType _0, clang.QualType _1, bool OfBlockPointer, bool Unqualified)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.mergeFunctionParameterTypes_0(__Instance, arg0, arg1, OfBlockPointer, Unqualified);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType mergeTransparentUnionType(clang.QualType _0, clang.QualType _1, bool OfBlockPointer, bool Unqualified)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.mergeTransparentUnionType_0(__Instance, arg0, arg1, OfBlockPointer, Unqualified);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType mergeObjCGCQualifiers(clang.QualType _0, clang.QualType _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_0.__Instance);
                var arg1 = ReferenceEquals(_1, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (_1.__Instance);
                var __ret = Internal.mergeObjCGCQualifiers_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool FunctionTypesMatchOnNSConsumedAttrs(clang.FunctionProtoType FromFunctionType, clang.FunctionProtoType ToFunctionType)
            {
                var arg0 = ReferenceEquals(FromFunctionType, null) ? global::System.IntPtr.Zero : FromFunctionType.__Instance;
                var arg1 = ReferenceEquals(ToFunctionType, null) ? global::System.IntPtr.Zero : ToFunctionType.__Instance;
                var __ret = Internal.FunctionTypesMatchOnNSConsumedAttrs_0(__Instance, arg0, arg1);
                return __ret;
            }

            public uint getIntWidth(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getIntWidth_0(__Instance, arg0);
                return __ret;
            }

            public clang.QualType getCorrespondingUnsignedType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getCorrespondingUnsignedType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Make an APSInt of the appropriate width and signedness for the
            /// given Value and integer Type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Make an APSInt of the appropriate width and signedness
            /// for the</para>
            /// <para>  /// given \p Value and integer \p Type.</para>
            /// </remarks>
            public llvm.APSInt MakeIntValue(ulong Value, clang.QualType Type)
            {
                var arg0 = Value;
                var arg1 = ReferenceEquals(Type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Type.__Instance);
                var __ret = new llvm.APSInt.Internal();
                Internal.MakeIntValue_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                return llvm.APSInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return true if there is at least one @implementation in the
            /// TU.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if there is at least one \@implementation
            /// in the TU.</para>
            /// </remarks>
            public bool AnyObjCImplementation()
            {
                var __ret = Internal.AnyObjCImplementation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Allocate an uninitialized TypeSourceInfo.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Allocate an uninitialized TypeSourceInfo.</para>
            /// <para>  ///</para>
            /// <para>  /// The caller should initialize the memory held by
            /// TypeSourceInfo using</para>
            /// <para>  /// the TypeLoc wrappers.</para>
            /// <para>  ///</para>
            /// <para>  /// \param T the type that will be the basis for type source
            /// info. This type</para>
            /// <para>  /// should refer to how the declarator was written in source
            /// code, not to</para>
            /// <para>  /// what type semantic analysis resolved the declarator
            /// to.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Size the size of the type info to create, or 0 if
            /// the size</para>
            /// <para>  /// should be calculated based on the type.</para>
            /// </remarks>
            public clang.TypeSourceInfo CreateTypeSourceInfo(clang.QualType T, uint Size)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.CreateTypeSourceInfo_0(__Instance, arg0, Size);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Allocate a TypeSourceInfo where all locations have been
            /// initialized to a given location, which defaults to the empty
            /// location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Allocate a TypeSourceInfo where all locations have
            /// been</para>
            /// <para>  /// initialized to a given location, which defaults to the
            /// empty</para>
            /// <para>  /// location.</para>
            /// </remarks>
            public clang.TypeSourceInfo getTrivialTypeSourceInfo(clang.QualType T, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getTrivialTypeSourceInfo_0(__Instance, arg0, arg1);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Add a deallocation callback that will be invoked when the
            /// ASTContext is destroyed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Add a deallocation callback that will be invoked when
            /// the </para>
            /// <para>  /// ASTContext is destroyed.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Callback A callback function that will be invoked on
            /// destruction.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Data Pointer data that will be provided to the
            /// callback function</para>
            /// <para>  /// when it is called.</para>
            /// </remarks>
            public void AddDeallocation(clang.ASTContext.__AnonymousDelegate0 Callback, global::System.IntPtr Data)
            {
                var arg0 = Callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(Callback);
                var arg1 = Data;
                Internal.AddDeallocation_0(__Instance, arg0, arg1);
            }

            public clang.GVALinkage GetGVALinkageForFunction(clang.FunctionDecl FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var __ret = Internal.GetGVALinkageForFunction_0(__Instance, arg0);
                return __ret;
            }

            public clang.GVALinkage GetGVALinkageForVariable(clang.VarDecl VD)
            {
                var arg0 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                var __ret = Internal.GetGVALinkageForVariable_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if the decl can be CodeGen'ed or deserialized from PCH
            /// lazily, only when used; this is only relevant for function or file scoped
            /// var definitions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines if the decl can be CodeGen'ed or
            /// deserialized from PCH</para>
            /// <para>  /// lazily, only when used; this is only relevant for function
            /// or file scoped</para>
            /// <para>  /// var definitions.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if the function/var must be
            /// CodeGen'ed/deserialized even if</para>
            /// <para>  /// it is not used.</para>
            /// </remarks>
            public bool DeclMustBeEmitted(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.DeclMustBeEmitted_0(__Instance, arg0);
                return __ret;
            }

            public void setManglingNumber(clang.NamedDecl ND, uint Number)
            {
                var arg0 = ReferenceEquals(ND, null) ? global::System.IntPtr.Zero : ND.__Instance;
                Internal.setManglingNumber_0(__Instance, arg0, Number);
            }

            public uint getManglingNumber(clang.NamedDecl ND)
            {
                var arg0 = ReferenceEquals(ND, null) ? global::System.IntPtr.Zero : ND.__Instance;
                var __ret = Internal.getManglingNumber_0(__Instance, arg0);
                return __ret;
            }

            public void setStaticLocalNumber(clang.VarDecl VD, uint Number)
            {
                var arg0 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                Internal.setStaticLocalNumber_0(__Instance, arg0, Number);
            }

            public uint getStaticLocalNumber(clang.VarDecl VD)
            {
                var arg0 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                var __ret = Internal.getStaticLocalNumber_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Used by ParmVarDecl to store on the side the index of the
            /// parameter when it exceeds the size of the normal bitfield.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Used by ParmVarDecl to store on the side the</para>
            /// <para>  /// index of the parameter when it exceeds the size of the
            /// normal bitfield.</para>
            /// </remarks>
            public void setParameterIndex(clang.ParmVarDecl D, uint index)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setParameterIndex_0(__Instance, arg0, index);
            }

            /// <summary>
            /// <para>Used by ParmVarDecl to retrieve on the side the index of the
            /// parameter when it exceeds the size of the normal bitfield.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Used by ParmVarDecl to retrieve on the side the</para>
            /// <para>  /// index of the parameter when it exceeds the size of the
            /// normal bitfield.</para>
            /// </remarks>
            public uint getParameterIndex(clang.ParmVarDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getParameterIndex_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this is an inline-initialized static data member
            /// which is treated as a definition for MSVC compatibility.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is an inline-initialized static
            /// data member</para>
            /// <para>  /// which is treated as a definition for MSVC
            /// compatibility.</para>
            /// </remarks>
            public bool isMSStaticDataMemberInlineDefinition(clang.VarDecl VD)
            {
                var arg0 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                var __ret = Internal.isMSStaticDataMemberInlineDefinition_0(__Instance, arg0);
                return __ret;
            }

            public static clang.ImportDecl getNextLocalImport(clang.ImportDecl Import)
            {
                var arg0 = ReferenceEquals(Import, null) ? global::System.IntPtr.Zero : Import.__Instance;
                var __ret = Internal.getNextLocalImport_0(arg0);
                clang.ImportDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImportDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImportDecl) clang.ImportDecl.NativeToManagedMap[__ret];
                else clang.ImportDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImportDecl) clang.ImportDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return true if this is an NSObject object with its NSObject
            /// attribute set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this is an \c NSObject object with its
            /// \c NSObject</para>
            /// <para>  /// attribute set.</para>
            /// </remarks>
            public static bool isObjCNSObjectType(clang.QualType Ty)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var __ret = Internal.isObjCNSObjectType_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>The number of implicitly-declared default constructors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared default
            /// constructors.</para>
            /// </remarks>
            public static uint NumImplicitDefaultConstructors
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext30NumImplicitDefaultConstructorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared default constructors for which
            /// declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared default constructors
            /// for </para>
            /// <para>  /// which declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitDefaultConstructorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext38NumImplicitDefaultConstructorsDeclaredE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared copy constructors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared copy
            /// constructors.</para>
            /// </remarks>
            public static uint NumImplicitCopyConstructors
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext27NumImplicitCopyConstructorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared copy constructors for which
            /// declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared copy constructors
            /// for </para>
            /// <para>  /// which declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitCopyConstructorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext35NumImplicitCopyConstructorsDeclaredE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared move constructors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared move
            /// constructors.</para>
            /// </remarks>
            public static uint NumImplicitMoveConstructors
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext27NumImplicitMoveConstructorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared move constructors for which
            /// declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared move constructors
            /// for</para>
            /// <para>  /// which declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitMoveConstructorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext35NumImplicitMoveConstructorsDeclaredE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared copy assignment
            /// operators.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared copy assignment
            /// operators.</para>
            /// </remarks>
            public static uint NumImplicitCopyAssignmentOperators
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext34NumImplicitCopyAssignmentOperatorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared copy assignment operators for
            /// which declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared copy assignment
            /// operators for </para>
            /// <para>  /// which declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitCopyAssignmentOperatorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext42NumImplicitCopyAssignmentOperatorsDeclaredE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared move assignment
            /// operators.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared move assignment
            /// operators.</para>
            /// </remarks>
            public static uint NumImplicitMoveAssignmentOperators
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext34NumImplicitMoveAssignmentOperatorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared move assignment operators for
            /// which declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared move assignment
            /// operators for </para>
            /// <para>  /// which declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitMoveAssignmentOperatorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext42NumImplicitMoveAssignmentOperatorsDeclaredE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared destructors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared destructors.</para>
            /// </remarks>
            public static uint NumImplicitDestructors
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext22NumImplicitDestructorsE");
                    return *__ptr;
                }
            }

            /// <summary>
            /// <para>The number of implicitly-declared destructors for which
            /// declarations were built.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of implicitly-declared destructors for
            /// which </para>
            /// <para>  /// declarations were built.</para>
            /// </remarks>
            public static uint NumImplicitDestructorsDeclared
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang10ASTContext30NumImplicitDestructorsDeclaredE");
                    return *__ptr;
                }
            }

            public clang.IdentifierTable Idents
            {
                get
                {
                    clang.IdentifierTable __result0;
                    if (((Internal*) __Instance)->Idents == IntPtr.Zero) __result0 = null;
                    else if (clang.IdentifierTable.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Idents))
                        __result0 = (clang.IdentifierTable) clang.IdentifierTable.NativeToManagedMap[((Internal*) __Instance)->Idents];
                    else __result0 = clang.IdentifierTable.__CreateInstance(((Internal*) __Instance)->Idents);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->Idents = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public clang.SelectorTable Selectors
            {
                get
                {
                    clang.SelectorTable __result0;
                    if (((Internal*) __Instance)->Selectors == IntPtr.Zero) __result0 = null;
                    else if (clang.SelectorTable.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Selectors))
                        __result0 = (clang.SelectorTable) clang.SelectorTable.NativeToManagedMap[((Internal*) __Instance)->Selectors];
                    else __result0 = clang.SelectorTable.__CreateInstance(((Internal*) __Instance)->Selectors);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->Selectors = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public clang.DeclarationNameTable DeclarationNames
            {
                get
                {
                    return clang.DeclarationNameTable.__CreateInstance(((Internal*) __Instance)->DeclarationNames);
                }

                set
                {
                    ((Internal*) __Instance)->DeclarationNames = ReferenceEquals(value, null) ? new clang.DeclarationNameTable.Internal() : *(clang.DeclarationNameTable.Internal*) (value.__Instance);
                }
            }

            public clang.RawCommentList Comments
            {
                get
                {
                    return clang.RawCommentList.__CreateInstance(((Internal*) __Instance)->Comments);
                }

                set
                {
                    ((Internal*) __Instance)->Comments = ReferenceEquals(value, null) ? new clang.RawCommentList.Internal() : *(clang.RawCommentList.Internal*) (value.__Instance);
                }
            }

            public bool CommentsLoaded
            {
                get
                {
                    return ((Internal*) __Instance)->CommentsLoaded;
                }

                set
                {
                    ((Internal*) __Instance)->CommentsLoaded = value;
                }
            }

            public clang.QualType AutoDeductTy
            {
                get
                {
                    return clang.QualType.__CreateInstance(((Internal*) __Instance)->AutoDeductTy);
                }

                set
                {
                    ((Internal*) __Instance)->AutoDeductTy = ReferenceEquals(value, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (value.__Instance);
                }
            }

            public clang.QualType AutoRRefDeductTy
            {
                get
                {
                    return clang.QualType.__CreateInstance(((Internal*) __Instance)->AutoRRefDeductTy);
                }

                set
                {
                    ((Internal*) __Instance)->AutoRRefDeductTy = ReferenceEquals(value, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (value.__Instance);
                }
            }

            public clang.QualType VaListTagTy
            {
                get
                {
                    return clang.QualType.__CreateInstance(((Internal*) __Instance)->VaListTagTy);
                }

                set
                {
                    ((Internal*) __Instance)->VaListTagTy = ReferenceEquals(value, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class ASTContext
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangL18GetNullarySelectorEN4llvm9StringRefERNS_10ASTContextE")]
                internal static extern clang.Selector.Internal GetNullarySelector_0(llvm.StringRef.Internal name, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangL16GetUnarySelectorEN4llvm9StringRefERNS_10ASTContextE")]
                internal static extern clang.Selector.Internal GetUnarySelector_0(llvm.StringRef.Internal name, global::System.IntPtr Ctx);
            }

            /// <summary>
            /// <para>Utility function for constructing a nullary selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Utility function for constructing a nullary
            /// selector.</para>
            /// </remarks>
            public static clang.Selector GetNullarySelector(llvm.StringRef name, clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (name.__Instance);
                var arg1 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.GetNullarySelector_0(arg0, arg1);
                return clang.Selector.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Utility function for constructing an unary selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Utility function for constructing an unary
            /// selector.</para>
            /// </remarks>
            public static clang.Selector GetUnarySelector(llvm.StringRef name, clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (name.__Instance);
                var arg1 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.GetUnarySelector_0(arg0, arg1);
                return clang.Selector.__CreateInstance(__ret);
            }
        }

        namespace Builtin
        {
        }

        namespace comments
        {
        }
    }

    namespace llvm
    {
    }
}
