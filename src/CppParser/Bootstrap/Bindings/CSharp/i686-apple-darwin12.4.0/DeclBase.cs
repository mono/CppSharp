//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class DeclBase
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        /// <summary>
        /// <para>Captures the result of checking the availability of a
        /// declaration.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Captures the result of checking the availability of
        /// a</para>
        /// <para>  /// declaration.</para>
        /// </remarks>
        public enum AvailabilityResult : uint
        {
            AR_Available = 0,
            AR_NotYetIntroduced = 1,
            AR_Deprecated = 2,
            AR_Unavailable = 3
        }

        public unsafe static partial class cast_convert_decl_context
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Decl - This represents one declaration (or definition), e.g. a
        /// variable, typedef, function, struct, etc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Decl - This represents one declaration (or definition), e.g.
        /// a variable,</para>
        /// <para>/// typedef, function, struct, etc.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class Decl : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct Internal
            {
                [FieldOffset(4)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(8)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(16)]
                public uint DeclKind;

                [FieldOffset(17)]
                public uint InvalidDecl;

                [FieldOffset(17)]
                public uint HasAttrs;

                [FieldOffset(17)]
                public uint Implicit;

                [FieldOffset(17)]
                public uint Used;

                [FieldOffset(17)]
                public uint Referenced;

                [FieldOffset(17)]
                public uint Access;

                [FieldOffset(17)]
                public uint FromASTFile;

                [FieldOffset(18)]
                public uint Hidden;

                [FieldOffset(18)]
                public uint IdentifierNamespace;

                [FieldOffset(19)]
                public uint CacheValidAndLinkage;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4DeclC2ENS0_4KindEPNS_11DeclContextENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr DC, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4DeclC2ENS0_4KindENS0_10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Decl.Kind DK, clang.Decl.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4DeclC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4DeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15updateOutOfDateERNS_14IdentifierInfoE")]
                internal static extern void updateOutOfDate_0(global::System.IntPtr instance, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl16getCachedLinkageEv")]
                internal static extern clang.Linkage getCachedLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl16setCachedLinkageENS_7LinkageE")]
                internal static extern void setCachedLinkage_0(global::System.IntPtr instance, clang.Linkage L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl16hasCachedLinkageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasCachedLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl7getKindEv")]
                internal static extern clang.Decl.Kind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15getDeclKindNameEv")]
                internal static extern global::System.IntPtr getDeclKindName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl20getNextDeclInContextEv")]
                internal static extern global::System.IntPtr getNextDeclInContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl14getDeclContextEv")]
                internal static extern global::System.IntPtr getDeclContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl20getNonClosureContextEv")]
                internal static extern global::System.IntPtr getNonClosureContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl22getTranslationUnitDeclEv")]
                internal static extern global::System.IntPtr getTranslationUnitDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl22isInAnonymousNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInAnonymousNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl16isInStdNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInStdNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl13getASTContextEv")]
                internal static extern global::System.IntPtr getASTContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl9setAccessENS_15AccessSpecifierE")]
                internal static extern void setAccess_0(global::System.IntPtr instance, clang.AccessSpecifier AS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl9getAccessEv")]
                internal static extern clang.AccessSpecifier getAccess_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15getAccessUnsafeEv")]
                internal static extern clang.AccessSpecifier getAccessUnsafe_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl8hasAttrsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAttrs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl9dropAttrsEv")]
                internal static extern void dropAttrs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl10attr_beginEv")]
                internal static extern global::System.IntPtr attr_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl8attr_endEv")]
                internal static extern global::System.IntPtr attr_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15getMaxAlignmentEv")]
                internal static extern uint getMaxAlignment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl14setInvalidDeclEb")]
                internal static extern void setInvalidDecl_0(global::System.IntPtr instance, bool Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl13isInvalidDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalidDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl10isImplicitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImplicit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl11setImplicitEb")]
                internal static extern void setImplicit_0(global::System.IntPtr instance, bool I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl6isUsedEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUsed_0(global::System.IntPtr instance, bool CheckUsedAttr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl9setIsUsedEv")]
                internal static extern void setIsUsed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl8markUsedERNS_10ASTContextE")]
                internal static extern void markUsed_0(global::System.IntPtr instance, global::System.IntPtr C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl12isReferencedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isReferenced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl27isThisDeclarationReferencedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isThisDeclarationReferenced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl13setReferencedEb")]
                internal static extern void setReferenced_0(global::System.IntPtr instance, bool R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl29isTopLevelDeclInObjCContainerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTopLevelDeclInObjCContainer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl30setTopLevelDeclInObjCContainerEb")]
                internal static extern void setTopLevelDeclInObjCContainer_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15isModulePrivateEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isModulePrivate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl16setModulePrivateEb")]
                internal static extern void setModulePrivate_0(global::System.IntPtr instance, bool MP);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl17setOwningModuleIDEj")]
                internal static extern void setOwningModuleID_0(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl14isWeakImportedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWeakImported_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl17canBeWeakImportedERb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canBeWeakImported_0(global::System.IntPtr instance, bool* IsDefinition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl13isFromASTFileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFromASTFile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11getGlobalIDEv")]
                internal static extern uint getGlobalID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl17getOwningModuleIDEv")]
                internal static extern uint getOwningModuleID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl22getIdentifierNamespaceEv")]
                internal static extern uint getIdentifierNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl23isInIdentifierNamespaceEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInIdentifierNamespace_0(global::System.IntPtr instance, uint NS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl29getIdentifierNamespaceForKindENS0_4KindE")]
                internal static extern uint getIdentifierNamespaceForKind_0(clang.Decl.Kind DK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl25hasTagIdentifierNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTagIdentifierNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl24isTagIdentifierNamespaceEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTagIdentifierNamespace_0(uint NS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl21getLexicalDeclContextEv")]
                internal static extern global::System.IntPtr getLexicalDeclContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11isOutOfLineEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOutOfLine_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl14setDeclContextEPNS_11DeclContextE")]
                internal static extern void setDeclContext_0(global::System.IntPtr instance, global::System.IntPtr DC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl21setLexicalDeclContextEPNS_11DeclContextE")]
                internal static extern void setLexicalDeclContext_0(global::System.IntPtr instance, global::System.IntPtr DC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl32isDefinedOutsideFunctionOrMethodEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefinedOutsideFunctionOrMethod_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl25getParentFunctionOrMethodEv")]
                internal static extern global::System.IntPtr getParentFunctionOrMethod_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15isCanonicalDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl13redecls_beginEv")]
                internal static extern clang.Decl.redecl_iterator.Internal redecls_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11redecls_endEv")]
                internal static extern clang.Decl.redecl_iterator.Internal redecls_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl15getPreviousDeclEv")]
                internal static extern global::System.IntPtr getPreviousDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl11isFirstDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFirstDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl17getMostRecentDeclEv")]
                internal static extern global::System.IntPtr getMostRecentDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl7hasBodyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl13getBodyRBraceEv")]
                internal static extern clang.SourceLocation.Internal getBodyRBrace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl3addENS0_4KindE")]
                internal static extern void add_0(clang.Decl.Kind k);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl16EnableStatisticsEv")]
                internal static extern void EnableStatistics_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl10PrintStatsEv")]
                internal static extern void PrintStats_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl19isTemplateParameterEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateParameter_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl23isTemplateParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15isParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl14isTemplateDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl28isFunctionOrFunctionTemplateEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionOrFunctionTemplate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl13getAsFunctionEv")]
                internal static extern global::System.IntPtr getAsFunction_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl18setLocalExternDeclEv")]
                internal static extern void setLocalExternDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl17isLocalExternDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalExternDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl21setObjectOfFriendDeclEb")]
                internal static extern void setObjectOfFriendDecl_0(global::System.IntPtr instance, bool PerformFriendInjection);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl19getFriendObjectKindEv")]
                internal static extern clang.Decl.FriendObjectKind getFriendObjectKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl20setNonMemberOperatorEv")]
                internal static extern void setNonMemberOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl11classofKindENS0_4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl5printERN4llvm11raw_ostreamEjb")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr Out, uint Indentation, bool PrintInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyEjb")]
                internal static extern void print_1(global::System.IntPtr instance, global::System.IntPtr Out, global::System.IntPtr Policy, uint Indentation, bool PrintInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Decl10printGroupEPPS0_jRN4llvm11raw_ostreamERKNS_14PrintingPolicyEj")]
                internal static extern void printGroup_0(global::System.IntPtr Begin, uint NumDecls, global::System.IntPtr Out, global::System.IntPtr Policy, uint Indentation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl9dumpColorEv")]
                internal static extern void dumpColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl4dumpERN4llvm11raw_ostreamE")]
                internal static extern void dump_1(global::System.IntPtr instance, global::System.IntPtr Out);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Decl15getFunctionTypeEb")]
                internal static extern global::System.IntPtr getFunctionType_0(global::System.IntPtr instance, bool BlocksToo);
            }

            /// <summary>
            /// <para>Lists the kind of concrete classes of Decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Lists the kind of concrete classes of Decl.</para>
            /// </remarks>
            public enum Kind : uint
            {
                AccessSpec = 0,
                Block = 1,
                Captured = 2,
                ClassScopeFunctionSpecialization = 3,
                Empty = 4,
                FileScopeAsm = 5,
                Friend = 6,
                FriendTemplate = 7,
                Import = 8,
                LinkageSpec = 9,
                Label = 10,
                Namespace = 11,
                NamespaceAlias = 12,
                ObjCCompatibleAlias = 13,
                ObjCCategory = 14,
                ObjCCategoryImpl = 15,
                ObjCImplementation = 16,
                firstObjCImpl = 15,
                lastObjCImpl = 16,
                ObjCInterface = 17,
                ObjCProtocol = 18,
                firstObjCContainer = 14,
                lastObjCContainer = 18,
                ObjCMethod = 19,
                ObjCProperty = 20,
                ClassTemplate = 21,
                FunctionTemplate = 22,
                TypeAliasTemplate = 23,
                VarTemplate = 24,
                firstRedeclarableTemplate = 21,
                lastRedeclarableTemplate = 24,
                TemplateTemplateParm = 25,
                firstTemplate = 21,
                lastTemplate = 25,
                Enum = 26,
                Record = 27,
                CXXRecord = 28,
                ClassTemplateSpecialization = 29,
                ClassTemplatePartialSpecialization = 30,
                firstClassTemplateSpecialization = 29,
                lastClassTemplateSpecialization = 30,
                firstCXXRecord = 28,
                lastCXXRecord = 30,
                firstRecord = 27,
                lastRecord = 30,
                firstTag = 26,
                lastTag = 30,
                TemplateTypeParm = 31,
                TypeAlias = 32,
                Typedef = 33,
                firstTypedefName = 32,
                lastTypedefName = 33,
                UnresolvedUsingTypename = 34,
                firstType = 26,
                lastType = 34,
                Using = 35,
                UsingDirective = 36,
                UsingShadow = 37,
                Field = 38,
                ObjCAtDefsField = 39,
                ObjCIvar = 40,
                firstField = 38,
                lastField = 40,
                Function = 41,
                CXXMethod = 42,
                CXXConstructor = 43,
                CXXConversion = 44,
                CXXDestructor = 45,
                firstCXXMethod = 42,
                lastCXXMethod = 45,
                firstFunction = 41,
                lastFunction = 45,
                MSProperty = 46,
                NonTypeTemplateParm = 47,
                Var = 48,
                ImplicitParam = 49,
                ParmVar = 50,
                VarTemplateSpecialization = 51,
                VarTemplatePartialSpecialization = 52,
                firstVarTemplateSpecialization = 51,
                lastVarTemplateSpecialization = 52,
                firstVar = 48,
                lastVar = 52,
                firstDeclarator = 38,
                lastDeclarator = 52,
                EnumConstant = 53,
                IndirectField = 54,
                UnresolvedUsingValue = 55,
                firstValue = 38,
                lastValue = 55,
                firstNamed = 10,
                lastNamed = 55,
                OMPThreadPrivate = 56,
                ObjCPropertyImpl = 57,
                StaticAssert = 58,
                TranslationUnit = 59,
                firstDecl = 0,
                lastDecl = 59
            }

            /// <summary>
            /// <para>IdentifierNamespace - The different namespaces in which
            /// declarations may appear. According to C99 6.2.3, there are four namespaces,
            /// labels, tags, members and ordinary identifiers. C++ describes lookup
            /// completely differently: certain lookups merely &quot;ignore&quot; certain
            /// kinds of declarations, usually based on whether the declaration is of a
            /// type, etc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IdentifierNamespace - The different namespaces in
            /// which</para>
            /// <para>  /// declarations may appear.  According to C99 6.2.3, there
            /// are</para>
            /// <para>  /// four namespaces, labels, tags, members and ordinary</para>
            /// <para>  /// identifiers.  C++ describes lookup completely
            /// differently:</para>
            /// <para>  /// certain lookups merely &quot;ignore&quot; certain kinds of
            /// declarations,</para>
            /// <para>  /// usually based on whether the declaration is of a type,
            /// etc.</para>
            /// <para>  ///</para>
            /// <para>  /// These are meant as bitmasks, so that searches in</para>
            /// <para>  /// C++ can look into the &quot;tag&quot; namespace during
            /// ordinary lookup.</para>
            /// <para>  ///</para>
            /// <para>  /// Decl currently provides 15 bits of IDNS bits.</para>
            /// </remarks>
            [Flags]
            public enum IdentifierNamespace : uint
            {
                /// <summary>Labels, declared with 'x:' and referenced with 'goto x'.</summary>
                IDNS_Label = 0x1,
                /// <summary>Tags, declared with 'struct foo;' and referenced with 'struct foo'. All tags are also types. This is what elaborated-type-specifiers look for in C.</summary>
                IDNS_Tag = 0x2,
                /// <summary>Types, declared with 'struct foo', typedefs, etc. This is what elaborated-type-specifiers look for in C++, but note that it's ill-formed to find a non-tag.</summary>
                IDNS_Type = 0x4,
                /// <summary>Members, declared with object declarations within tag definitions. In C, these can only be found by "qualified" lookup in member expressions. In C++, they're found by normal lookup.</summary>
                IDNS_Member = 0x8,
                /// <summary>Namespaces, declared with 'namespace foo {}'. Lookup for nested-name-specifiers find these.</summary>
                IDNS_Namespace = 0x10,
                /// <summary>Ordinary names. In C, everything that's not a label, tag, or member ends up here.</summary>
                IDNS_Ordinary = 0x20,
                /// <summary>Objective C @protocol.</summary>
                IDNS_ObjCProtocol = 0x40,
                /// <summary>This declaration is a friend function. A friend function declaration is always in this namespace but may also be in IDNS_Ordinary if it was previously declared.</summary>
                IDNS_OrdinaryFriend = 0x80,
                /// <summary>This declaration is a friend class. A friend class declaration is always in this namespace but may also be in IDNS_Tag|IDNS_Type if it was previously declared.</summary>
                IDNS_TagFriend = 0x100,
                /// <summary>This declaration is a using declaration. A using declaration *introduces* a number of other declarations into the current scope, and those declarations use the IDNS of their targets, but the actual using declarations go in this namespace.</summary>
                IDNS_Using = 0x200,
                /// <summary>This declaration is a C++ operator declared in a non-class context. All such operators are also in IDNS_Ordinary. C++ lexical operator lookup looks for these.</summary>
                IDNS_NonMemberOperator = 0x400,
                /// <summary>This declaration is a function-local extern declaration of a variable or function. This may also be IDNS_Ordinary if it has been declared outside any function.</summary>
                IDNS_LocalExtern = 0x800
            }

            /// <summary>
            /// <para>ObjCDeclQualifier - 'Qualifiers' written next to the return and
            /// parameter types in method declarations. Other than remembering them and
            /// mangling them into the method's signature string, these are ignored by the
            /// compiler; they are consumed by certain remote-messaging frameworks.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ObjCDeclQualifier - 'Qualifiers' written next to the return
            /// and</para>
            /// <para>  /// parameter types in method declarations.  Other than
            /// remembering</para>
            /// <para>  /// them and mangling them into the method's signature string,
            /// these</para>
            /// <para>  /// are ignored by the compiler; they are consumed by
            /// certain</para>
            /// <para>  /// remote-messaging frameworks.</para>
            /// <para>  ///</para>
            /// <para>  /// in, inout, and out are mutually exclusive and apply only
            /// to</para>
            /// <para>  /// method parameters.  bycopy and byref are mutually exclusive
            /// and</para>
            /// <para>  /// apply only to method parameters (?).  oneway applies only
            /// to</para>
            /// <para>  /// results.  All of these expect their corresponding parameter
            /// to</para>
            /// <para>  /// have a particular type.  None of this is currently enforced
            /// by</para>
            /// <para>  /// clang.</para>
            /// <para>  ///</para>
            /// <para>  /// This should be kept in sync with
            /// ObjCDeclSpec::ObjCDeclQualifier.</para>
            /// </remarks>
            [Flags]
            public enum ObjCDeclQualifier : uint
            {
                OBJC_TQ_None = 0x0,
                OBJC_TQ_In = 0x1,
                OBJC_TQ_Inout = 0x2,
                OBJC_TQ_Out = 0x4,
                OBJC_TQ_Bycopy = 0x8,
                OBJC_TQ_Byref = 0x10,
                OBJC_TQ_Oneway = 0x20
            }

            public enum _0 : uint
            {
                /// <summary>Whether this declaration is a top-level declaration (function, global variable, etc.) that is lexically inside an objc container definition.</summary>
                TopLevelDeclInObjCContainerFlag = 0x1,
                /// <summary>Whether this declaration is private to the module in which it was defined.</summary>
                ModulePrivateFlag = 0x2
            }

            public enum FriendObjectKind : uint
            {
                /// <summary>Not a friend object.</summary>
                FOK_None = 0,
                /// <summary>A friend of a previously-declared entity.</summary>
                FOK_Declared = 1,
                /// <summary>A friend of a previously-undeclared entity.</summary>
                FOK_Undeclared = 2
            }

            /// <summary>
            /// <para>A placeholder type used to construct an empty shell of a
            /// decl-derived type that will be filled in later (e.g., by some
            /// deserialization method).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A placeholder type used to construct an empty shell of
            /// a</para>
            /// <para>  /// decl-derived type that will be filled in later (e.g., by
            /// some</para>
            /// <para>  /// deserialization method).</para>
            /// </remarks>
            public unsafe partial class EmptyShell : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Decl10EmptyShellC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EmptyShell> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EmptyShell>();

                private readonly bool __ownsNativeInstance;

                public static EmptyShell __CreateInstance(global::System.IntPtr native)
                {
                    return new EmptyShell((EmptyShell.Internal*) native);
                }

                public static EmptyShell __CreateInstance(EmptyShell.Internal native)
                {
                    return new EmptyShell(native);
                }

                private static EmptyShell.Internal* __CopyValue(EmptyShell.Internal native)
                {
                    var ret = (EmptyShell.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private EmptyShell(EmptyShell.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected EmptyShell(EmptyShell.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public EmptyShell()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Decl.EmptyShell __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            internal unsafe partial class MultipleDC
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr SemanticDC;

                    [FieldOffset(4)]
                    public global::System.IntPtr LexicalDC;
                }
            }

            /// <summary>
            /// <para>Iterates through all the redeclarations of the same decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterates through all the redeclarations of the same
            /// decl.</para>
            /// </remarks>
            public unsafe partial class redecl_iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Current;

                    [FieldOffset(4)]
                    public global::System.IntPtr Starter;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Decl15redecl_iteratorC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Decl15redecl_iteratorC2EPS0_")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr C);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Decl15redecl_iteratorC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Decl15redecl_iteratorppEv")]
                    internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clangeqENS_4Decl15redecl_iteratorES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(clang.Decl.redecl_iterator.Internal x, clang.Decl.redecl_iterator.Internal y);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clangneENS_4Decl15redecl_iteratorES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(clang.Decl.redecl_iterator.Internal x, clang.Decl.redecl_iterator.Internal y);
                }

                public class value_type { }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, redecl_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, redecl_iterator>();

                private readonly bool __ownsNativeInstance;

                public static redecl_iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new redecl_iterator((redecl_iterator.Internal*) native);
                }

                public static redecl_iterator __CreateInstance(redecl_iterator.Internal native)
                {
                    return new redecl_iterator(native);
                }

                private static redecl_iterator.Internal* __CopyValue(redecl_iterator.Internal native)
                {
                    var ret = (redecl_iterator.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private redecl_iterator(redecl_iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected redecl_iterator(redecl_iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public redecl_iterator()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public redecl_iterator(clang.Decl C)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                    Internal.ctor_1(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Decl.redecl_iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public static clang.Decl.redecl_iterator operator ++(clang.Decl.redecl_iterator __op)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var __ret = Internal.OperatorPlusPlus_0(arg0);
                    clang.Decl.redecl_iterator __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.redecl_iterator.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.Decl.redecl_iterator) clang.Decl.redecl_iterator.NativeToManagedMap[__ret];
                    else __result0 = clang.Decl.redecl_iterator.__CreateInstance(__ret);
                    return __result0;
                }

                public static bool operator ==(clang.Decl.redecl_iterator x, clang.Decl.redecl_iterator y)
                {
                    bool xNull = ReferenceEquals(x, null);
                    bool yNull = ReferenceEquals(y, null);
                    if (xNull || yNull)
                        return xNull && yNull;
                    var arg0 = ReferenceEquals(x, null) ? new clang.Decl.redecl_iterator.Internal() : *(clang.Decl.redecl_iterator.Internal*) (x.__Instance);
                    var arg1 = ReferenceEquals(y, null) ? new clang.Decl.redecl_iterator.Internal() : *(clang.Decl.redecl_iterator.Internal*) (y.__Instance);
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as redecl_iterator;
                }

                public static bool operator !=(clang.Decl.redecl_iterator x, clang.Decl.redecl_iterator y)
                {
                    var arg0 = ReferenceEquals(x, null) ? new clang.Decl.redecl_iterator.Internal() : *(clang.Decl.redecl_iterator.Internal*) (x.__Instance);
                    var arg1 = ReferenceEquals(y, null) ? new clang.Decl.redecl_iterator.Internal() : *(clang.Decl.redecl_iterator.Internal*) (y.__Instance);
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Decl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Decl>();

            private readonly bool __ownsNativeInstance;

            public static Decl __CreateInstance(global::System.IntPtr native)
            {
                return new Decl((Decl.Internal*) native);
            }

            public static Decl __CreateInstance(Decl.Internal native)
            {
                return new Decl(native);
            }

            private static Decl.Internal* __CopyValue(Decl.Internal native)
            {
                var ret = (Decl.Internal*) Marshal.AllocHGlobal(20);
                *ret = native;
                return ret;
            }

            private Decl(Decl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Decl(Decl.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected Decl(clang.Decl.Kind DK, clang.DeclContext DC, clang.SourceLocation L)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
                SetupVTables(__Instance);
            }

            protected Decl(clang.Decl.Kind DK, clang.Decl.EmptyShell Empty)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(Empty, null) ? new clang.Decl.EmptyShell.Internal() : *(clang.Decl.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Update a potentially out-of-date declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Update a potentially out-of-date declaration.</para>
            /// </remarks>
            protected void updateOutOfDate(clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                Internal.updateOutOfDate_0(__Instance, arg0);
            }

            protected clang.Linkage getCachedLinkage()
            {
                var __ret = Internal.getCachedLinkage_0(__Instance);
                return __ret;
            }

            protected void setCachedLinkage(clang.Linkage L)
            {
                var arg0 = L;
                Internal.setCachedLinkage_0(__Instance, arg0);
            }

            protected bool hasCachedLinkage()
            {
                var __ret = Internal.hasCachedLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Source range that this declaration covers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Source range that this declaration covers.</para>
            /// </remarks>
            public virtual clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocation(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public clang.Decl.Kind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public string getDeclKindName()
            {
                var __ret = Internal.getDeclKindName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public clang.Decl getNextDeclInContext()
            {
                var __ret = Internal.getNextDeclInContext_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DeclContext getDeclContext()
            {
                var __ret = Internal.getDeclContext_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Find the innermost non-closure ancestor of this declaration,
            /// walking up through blocks, lambdas, etc. If that ancestor is not a code
            /// context (!isFunctionOrMethod()), returns null.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the innermost non-closure ancestor of this
            /// declaration,</para>
            /// <para>  /// walking up through blocks, lambdas, etc.  If that ancestor
            /// is</para>
            /// <para>  /// not a code context (!isFunctionOrMethod()), returns
            /// null.</para>
            /// <para>  ///</para>
            /// <para>  /// A declaration may be its own non-closure context.</para>
            /// </remarks>
            public clang.Decl getNonClosureContext()
            {
                var __ret = Internal.getNonClosureContext_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TranslationUnitDecl getTranslationUnitDecl()
            {
                var __ret = Internal.getTranslationUnitDecl_0(__Instance);
                clang.TranslationUnitDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TranslationUnitDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.NativeToManagedMap[__ret];
                else clang.TranslationUnitDecl.NativeToManagedMap[__ret] = __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool isInAnonymousNamespace()
            {
                var __ret = Internal.isInAnonymousNamespace_0(__Instance);
                return __ret;
            }

            public bool isInStdNamespace()
            {
                var __ret = Internal.isInStdNamespace_0(__Instance);
                return __ret;
            }

            public clang.ASTContext getASTContext()
            {
                var __ret = Internal.getASTContext_0(__Instance);
                clang.ASTContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTContext) clang.ASTContext.NativeToManagedMap[__ret];
                else __result0 = clang.ASTContext.__CreateInstance(__ret);
                return __result0;
            }

            public void setAccess(clang.AccessSpecifier AS)
            {
                var arg0 = AS;
                Internal.setAccess_0(__Instance, arg0);
            }

            public clang.AccessSpecifier getAccess()
            {
                var __ret = Internal.getAccess_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the access specifier for this declaration, even though
            /// it may not yet have been properly set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the access specifier for this declaration,
            /// even though</para>
            /// <para>  /// it may not yet have been properly set.</para>
            /// </remarks>
            public clang.AccessSpecifier getAccessUnsafe()
            {
                var __ret = Internal.getAccessUnsafe_0(__Instance);
                return __ret;
            }

            public bool hasAttrs()
            {
                var __ret = Internal.hasAttrs_0(__Instance);
                return __ret;
            }

            public void dropAttrs()
            {
                Internal.dropAttrs_0(__Instance);
            }

            public clang.Attr attr_begin()
            {
                var __ret = Internal.attr_begin_0(__Instance);
                clang.Attr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Attr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Attr) clang.Attr.NativeToManagedMap[__ret];
                else __result0 = clang.Attr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Attr attr_end()
            {
                var __ret = Internal.attr_end_0(__Instance);
                clang.Attr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Attr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Attr) clang.Attr.NativeToManagedMap[__ret];
                else __result0 = clang.Attr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getMaxAlignment - return the maximum alignment specified by
            /// attributes on this decl, 0 if there are none.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getMaxAlignment - return the maximum alignment specified by
            /// attributes</para>
            /// <para>  /// on this decl, 0 if there are none.</para>
            /// </remarks>
            public uint getMaxAlignment()
            {
                var __ret = Internal.getMaxAlignment_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setInvalidDecl - Indicates the Decl had a semantic error. This
            /// allows for graceful error recovery.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setInvalidDecl - Indicates the Decl had a semantic error.
            /// This</para>
            /// <para>  /// allows for graceful error recovery.</para>
            /// </remarks>
            public void setInvalidDecl(bool Invalid)
            {
                Internal.setInvalidDecl_0(__Instance, Invalid);
            }

            public bool isInvalidDecl()
            {
                var __ret = Internal.isInvalidDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isImplicit - Indicates whether the declaration was implicitly
            /// generated by the implementation. If false, this declaration was written
            /// explicitly in the source code.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isImplicit - Indicates whether the declaration was
            /// implicitly</para>
            /// <para>  /// generated by the implementation. If false, this
            /// declaration</para>
            /// <para>  /// was written explicitly in the source code.</para>
            /// </remarks>
            public bool isImplicit()
            {
                var __ret = Internal.isImplicit_0(__Instance);
                return __ret;
            }

            public void setImplicit(bool I)
            {
                Internal.setImplicit_0(__Instance, I);
            }

            /// <summary>
            /// <para>Whether this declaration was used, meaning that a definition is
            /// required.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration was used, meaning that a
            /// definition</para>
            /// <para>  /// is required.</para>
            /// <para>  ///</para>
            /// <para>  /// \param CheckUsedAttr When true, also consider the
            /// &quot;used&quot; attribute</para>
            /// <para>  /// (in addition to the &quot;used&quot; bit set by \c
            /// setUsed()) when determining</para>
            /// <para>  /// whether the function is used.</para>
            /// </remarks>
            public bool isUsed(bool CheckUsedAttr)
            {
                var __ret = Internal.isUsed_0(__Instance, CheckUsedAttr);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether the declaration is used, in the sense of
            /// odr-use.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether the declaration is used, in the sense of
            /// odr-use.</para>
            /// <para>  ///</para>
            /// <para>  /// This should only be used immediately after creating a
            /// declaration.</para>
            /// </remarks>
            public void setIsUsed()
            {
                Internal.setIsUsed_0(__Instance);
            }

            /// <summary>
            /// <para>Mark the declaration used, in the sense of odr-use.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Mark the declaration used, in the sense of
            /// odr-use.</para>
            /// <para>  ///</para>
            /// <para>  /// This notifies any mutation listeners in addition to setting
            /// a bit</para>
            /// <para>  /// indicating the declaration is used.</para>
            /// </remarks>
            public void markUsed(clang.ASTContext C)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                Internal.markUsed_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Whether any declaration of this entity was referenced.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether any declaration of this entity was
            /// referenced.</para>
            /// </remarks>
            public bool isReferenced()
            {
                var __ret = Internal.isReferenced_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this declaration was referenced. This should not be
            /// relied upon for anything other than debugging.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration was referenced. This should
            /// not be relied</para>
            /// <para>  /// upon for anything other than debugging.</para>
            /// </remarks>
            public bool isThisDeclarationReferenced()
            {
                var __ret = Internal.isThisDeclarationReferenced_0(__Instance);
                return __ret;
            }

            public void setReferenced(bool R)
            {
                Internal.setReferenced_0(__Instance, R);
            }

            /// <summary>
            /// <para>Whether this declaration is a top-level declaration (function,
            /// global variable, etc.) that is lexically inside an objc container
            /// definition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration is a top-level declaration
            /// (function,</para>
            /// <para>  /// global variable, etc.) that is lexically inside an objc
            /// container</para>
            /// <para>  /// definition.</para>
            /// </remarks>
            public bool isTopLevelDeclInObjCContainer()
            {
                var __ret = Internal.isTopLevelDeclInObjCContainer_0(__Instance);
                return __ret;
            }

            public void setTopLevelDeclInObjCContainer(bool V)
            {
                Internal.setTopLevelDeclInObjCContainer_0(__Instance, V);
            }

            /// <summary>
            /// <para>Whether this declaration was marked as being private to the
            /// module in which it was defined.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration was marked as being private
            /// to the</para>
            /// <para>  /// module in which it was defined.</para>
            /// </remarks>
            public bool isModulePrivate()
            {
                var __ret = Internal.isModulePrivate_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Specify whether this declaration was marked as being private to
            /// the module in which it was defined.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify whether this declaration was marked as being
            /// private</para>
            /// <para>  /// to the module in which it was defined.</para>
            /// </remarks>
            protected void setModulePrivate(bool MP)
            {
                Internal.setModulePrivate_0(__Instance, MP);
            }

            /// <summary>
            /// <para>Set the owning module ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the owning module ID.</para>
            /// </remarks>
            protected void setOwningModuleID(uint ID)
            {
                Internal.setOwningModuleID_0(__Instance, ID);
            }

            /// <summary>
            /// <para>Determine whether this is a weak-imported symbol.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is a weak-imported
            /// symbol.</para>
            /// <para>  ///</para>
            /// <para>  /// Weak-imported symbols are typically marked with the</para>
            /// <para>  /// 'weak_import' attribute, but may also be marked with
            /// an</para>
            /// <para>  /// 'availability' attribute where we're targing a platform
            /// prior to</para>
            /// <para>  /// the introduction of this feature.</para>
            /// </remarks>
            public bool isWeakImported()
            {
                var __ret = Internal.isWeakImported_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this symbol can be weak-imported, e.g.,
            /// whether it would be well-formed to add the weak_import attribute.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this symbol can be
            /// weak-imported,</para>
            /// <para>  /// e.g., whether it would be well-formed to add the
            /// weak_import</para>
            /// <para>  /// attribute.</para>
            /// <para>  ///</para>
            /// <para>  /// \param IsDefinition Set to \c true to indicate that
            /// this</para>
            /// <para>  /// declaration cannot be weak-imported because it has a
            /// definition.</para>
            /// </remarks>
            public bool canBeWeakImported(ref bool IsDefinition)
            {
                fixed (bool* arg0 = &IsDefinition)
                {
                    var __ret = Internal.canBeWeakImported_0(__Instance, arg0);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Determine whether this declaration came from an AST file (such as
            /// a precompiled header or module) rather than having been parsed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration came from an AST
            /// file (such as</para>
            /// <para>  /// a precompiled header or module) rather than having been
            /// parsed.</para>
            /// </remarks>
            public bool isFromASTFile()
            {
                var __ret = Internal.isFromASTFile_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the global declaration ID associated with this
            /// declaration, which specifies where in the</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the global declaration ID associated with
            /// this </para>
            /// <para>  /// declaration, which specifies where in the </para>
            /// </remarks>
            public uint getGlobalID()
            {
                var __ret = Internal.getGlobalID_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the global ID of the module that owns this particular
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the global ID of the module that owns this
            /// particular</para>
            /// <para>  /// declaration.</para>
            /// </remarks>
            public uint getOwningModuleID()
            {
                var __ret = Internal.getOwningModuleID_0(__Instance);
                return __ret;
            }

            public uint getIdentifierNamespace()
            {
                var __ret = Internal.getIdentifierNamespace_0(__Instance);
                return __ret;
            }

            public bool isInIdentifierNamespace(uint NS)
            {
                var __ret = Internal.isInIdentifierNamespace_0(__Instance, NS);
                return __ret;
            }

            public bool hasTagIdentifierNamespace()
            {
                var __ret = Internal.hasTagIdentifierNamespace_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getLexicalDeclContext - The declaration context where this Decl
            /// was lexically declared (LexicalDC). May be different from getDeclContext()
            /// (SemanticDC). e.g.:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getLexicalDeclContext - The declaration context where this
            /// Decl was</para>
            /// <para>  /// lexically declared (LexicalDC). May be different
            /// from</para>
            /// <para>  /// getDeclContext() (SemanticDC).</para>
            /// <para>  /// e.g.:</para>
            /// <para>  ///</para>
            /// <para>  ///   namespace A {</para>
            /// <para>  ///      void f(); // SemanticDC == LexicalDC == 'namespace
            /// A'</para>
            /// <para>  ///   }</para>
            /// <para>  ///   void A::f(); // SemanticDC == namespace 'A'</para>
            /// <para>  ///                // LexicalDC == global namespace</para>
            /// </remarks>
            public clang.DeclContext getLexicalDeclContext()
            {
                var __ret = Internal.getLexicalDeclContext_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this declaration is declared out of line
            /// (outside its semantic context).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determine whether this declaration is declared out of line
            /// (outside its</para>
            /// <para>  /// semantic context).</para>
            /// </remarks>
            public virtual bool isOutOfLine()
            {
                var __ret = Internal.isOutOfLine_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setDeclContext - Set both the semantic and lexical DeclContext to
            /// DC.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setDeclContext - Set both the semantic and lexical
            /// DeclContext</para>
            /// <para>  /// to DC.</para>
            /// </remarks>
            public void setDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                Internal.setDeclContext_0(__Instance, arg0);
            }

            public void setLexicalDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                Internal.setLexicalDeclContext_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>isDefinedOutsideFunctionOrMethod - This predicate returns true if
            /// this scoped decl is defined outside the current function or method. This is
            /// roughly global variables and functions, but also handles enums (which could
            /// be defined inside or outside a function etc).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isDefinedOutsideFunctionOrMethod - This predicate returns
            /// true if this</para>
            /// <para>  /// scoped decl is defined outside the current function or
            /// method.  This is</para>
            /// <para>  /// roughly global variables and functions, but also handles
            /// enums (which</para>
            /// <para>  /// could be defined inside or outside a function etc).</para>
            /// </remarks>
            public bool isDefinedOutsideFunctionOrMethod()
            {
                var __ret = Internal.isDefinedOutsideFunctionOrMethod_0(__Instance);
                return __ret;
            }

            public clang.DeclContext getParentFunctionOrMethod()
            {
                var __ret = Internal.getParentFunctionOrMethod_1(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves the &quot;canonical&quot; declaration of the given
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the &quot;canonical&quot; declaration of the
            /// given declaration.</para>
            /// </remarks>
            public virtual clang.Decl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Whether this particular Decl is a canonical one.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this particular Decl is a canonical
            /// one.</para>
            /// </remarks>
            public bool isCanonicalDecl()
            {
                var __ret = Internal.isCanonicalDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the next redeclaration or itself if this is the only
            /// decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the next redeclaration or itself if this is
            /// the only decl.</para>
            /// <para>  ///</para>
            /// <para>  /// Decl subclasses that can be redeclared should override this
            /// method so that</para>
            /// <para>  /// Decl::redecl_iterator can iterate over them.</para>
            /// </remarks>
            protected virtual clang.Decl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Implementation of getPreviousDecl(), to be overridden by any
            /// subclass that has a redeclaration chain.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Implementation of getPreviousDecl(), to be overridden
            /// by any</para>
            /// <para>  /// subclass that has a redeclaration chain.</para>
            /// </remarks>
            protected virtual clang.Decl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Implementation of getMostRecentDecl(), to be overridden by any
            /// subclass that has a redeclaration chain.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Implementation of getMostRecentDecl(), to be
            /// overridden by any</para>
            /// <para>  /// subclass that has a redeclaration chain.</para>
            /// </remarks>
            protected virtual clang.Decl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Decl.redecl_iterator redecls_begin()
            {
                var __ret = Internal.redecls_begin_0(__Instance);
                return clang.Decl.redecl_iterator.__CreateInstance(__ret);
            }

            public clang.Decl.redecl_iterator redecls_end()
            {
                var __ret = Internal.redecls_end_0(__Instance);
                return clang.Decl.redecl_iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the previous declaration that declares the same entity
            /// as this declaration, or NULL if there is no previous declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the previous declaration that declares the
            /// same entity</para>
            /// <para>  /// as this declaration, or NULL if there is no previous
            /// declaration.</para>
            /// </remarks>
            public clang.Decl getPreviousDecl()
            {
                var __ret = Internal.getPreviousDecl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>True if this is the first declaration in its redeclaration
            /// chain.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if this is the first declaration in its
            /// redeclaration chain.</para>
            /// </remarks>
            public bool isFirstDecl()
            {
                var __ret = Internal.isFirstDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the most recent declaration that declares the same
            /// entity as this declaration (which may be this declaration).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the most recent declaration that declares the
            /// same entity</para>
            /// <para>  /// as this declaration (which may be this declaration).</para>
            /// </remarks>
            public clang.Decl getMostRecentDecl()
            {
                var __ret = Internal.getMostRecentDecl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getBody - If this Decl represents a declaration for a body of
            /// code, such as a function or method definition, this method returns the
            /// top-level Stmt* of that body. Otherwise this method returns null.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBody - If this Decl represents a declaration for a body of
            /// code,</para>
            /// <para>  ///  such as a function or method definition, this method
            /// returns the</para>
            /// <para>  ///  top-level Stmt* of that body.  Otherwise this method
            /// returns null.</para>
            /// </remarks>
            public virtual clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns true if this Decl represents a declaration for a body of
            /// code, such as a function or method definition. Note that hasBody can also
            /// return true if any redeclaration of this Decl represents a declaration for
            /// a body of code.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this \c Decl represents a declaration
            /// for a body of</para>
            /// <para>  /// code, such as a function or method definition.</para>
            /// <para>  /// Note that \c hasBody can also return true if any
            /// redeclaration of this</para>
            /// <para>  /// \c Decl represents a declaration for a body of code.</para>
            /// </remarks>
            public virtual bool hasBody()
            {
                var __ret = Internal.hasBody_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getBodyRBrace - Gets the right brace of the body, if a body
            /// exists. This works whether the body is a CompoundStmt or a
            /// CXXTryStmt.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBodyRBrace - Gets the right brace of the body, if a body
            /// exists.</para>
            /// <para>  /// This works whether the body is a CompoundStmt or a
            /// CXXTryStmt.</para>
            /// </remarks>
            public clang.SourceLocation getBodyRBrace()
            {
                var __ret = Internal.getBodyRBrace_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>isTemplateParameter - Determines whether this declaration is a
            /// template parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTemplateParameter - Determines whether this declaration is
            /// a</para>
            /// <para>  /// template parameter.</para>
            /// </remarks>
            public bool isTemplateParameter()
            {
                var __ret = Internal.isTemplateParameter_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isTemplateParameter - Determines whether this declaration is a
            /// template parameter pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTemplateParameter - Determines whether this declaration is
            /// a</para>
            /// <para>  /// template parameter pack.</para>
            /// </remarks>
            public bool isTemplateParameterPack()
            {
                var __ret = Internal.isTemplateParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this declaration is a parameter pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration is a parameter pack.</para>
            /// </remarks>
            public bool isParameterPack()
            {
                var __ret = Internal.isParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>returns true if this declaration is a template</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief returns true if this declaration is a template</para>
            /// </remarks>
            public bool isTemplateDecl()
            {
                var __ret = Internal.isTemplateDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this declaration is a function or function
            /// template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration is a function or function
            /// template.</para>
            /// </remarks>
            public bool isFunctionOrFunctionTemplate()
            {
                var __ret = Internal.isFunctionOrFunctionTemplate_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the function itself, or the templated function if this is
            /// a function template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the function itself, or the templated function
            /// if this is a</para>
            /// <para>  /// function template.</para>
            /// </remarks>
            public clang.FunctionDecl getAsFunction()
            {
                var __ret = Internal.getAsFunction_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Changes the namespace of this declaration to reflect that it's a
            /// function-local extern declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Changes the namespace of this declaration to reflect
            /// that it's</para>
            /// <para>  /// a function-local extern declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// These declarations appear in the lexical context of the
            /// extern</para>
            /// <para>  /// declaration, but in the semantic context of the enclosing
            /// namespace</para>
            /// <para>  /// scope.</para>
            /// </remarks>
            public void setLocalExternDecl()
            {
                Internal.setLocalExternDecl_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this is a block-scope declaration with linkage.
            /// This will either be a local variable declaration declared 'extern', or a
            /// local function declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is a block-scope declaration
            /// with linkage.</para>
            /// <para>  /// This will either be a local variable declaration declared
            /// 'extern', or a</para>
            /// <para>  /// local function declaration.</para>
            /// </remarks>
            public bool isLocalExternDecl()
            {
                var __ret = Internal.isLocalExternDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Changes the namespace of this declaration to reflect that it's
            /// the object of a friend declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Changes the namespace of this declaration to reflect
            /// that it's</para>
            /// <para>  /// the object of a friend declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// These declarations appear in the lexical context of the
            /// friending</para>
            /// <para>  /// class, but in the semantic context of the actual entity.
            /// This property</para>
            /// <para>  /// applies only to a specific decl object;  other
            /// redeclarations of the</para>
            /// <para>  /// same entity may not (and probably don't) share this
            /// property.</para>
            /// </remarks>
            public void setObjectOfFriendDecl(bool PerformFriendInjection)
            {
                Internal.setObjectOfFriendDecl_0(__Instance, PerformFriendInjection);
            }

            /// <summary>
            /// <para>Determines whether this declaration is the object of a friend
            /// declaration and, if so, what kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this declaration is the object of
            /// a</para>
            /// <para>  /// friend declaration and, if so, what kind.</para>
            /// <para>  ///</para>
            /// <para>  /// There is currently no direct way to find the associated
            /// FriendDecl.</para>
            /// </remarks>
            public clang.Decl.FriendObjectKind getFriendObjectKind()
            {
                var __ret = Internal.getFriendObjectKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Specifies that this declaration is a C++ overloaded
            /// non-member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Specifies that this declaration is a C++ overloaded
            /// non-member.</para>
            /// </remarks>
            public void setNonMemberOperator()
            {
                Internal.setNonMemberOperator_0(__Instance);
            }

            public void print(llvm.raw_ostream Out, uint Indentation, bool PrintInstantiation)
            {
                var arg0 = ReferenceEquals(Out, null) ? global::System.IntPtr.Zero : Out.__Instance;
                Internal.print_0(__Instance, arg0, Indentation, PrintInstantiation);
            }

            public void print(llvm.raw_ostream Out, clang.PrintingPolicy Policy, uint Indentation, bool PrintInstantiation)
            {
                var arg0 = ReferenceEquals(Out, null) ? global::System.IntPtr.Zero : Out.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.print_1(__Instance, arg0, arg1, Indentation, PrintInstantiation);
            }

            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            public void dumpColor()
            {
                Internal.dumpColor_0(__Instance);
            }

            public void dump(llvm.raw_ostream Out)
            {
                var arg0 = ReferenceEquals(Out, null) ? global::System.IntPtr.Zero : Out.__Instance;
                Internal.dump_1(__Instance, arg0);
            }

            /// <summary>
            /// <para>Looks through the Decl's underlying type to extract a
            /// FunctionType when possible. Will return null if the type underlying the
            /// Decl does not have a FunctionType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Looks through the Decl's underlying type to extract a
            /// FunctionType</para>
            /// <para>  /// when possible. Will return null if the type underlying the
            /// Decl does not</para>
            /// <para>  /// have a FunctionType.</para>
            /// </remarks>
            public clang.FunctionType getFunctionType(bool BlocksToo)
            {
                var __ret = Internal.getFunctionType_0(__Instance, BlocksToo);
                clang.FunctionType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionType) clang.FunctionType.NativeToManagedMap[__ret];
                else __result0 = clang.FunctionType.__CreateInstance(__ret);
                return __result0;
            }

            public static uint getIdentifierNamespaceForKind(clang.Decl.Kind DK)
            {
                var arg0 = DK;
                var __ret = Internal.getIdentifierNamespaceForKind_0(arg0);
                return __ret;
            }

            public static bool isTagIdentifierNamespace(uint NS)
            {
                var __ret = Internal.isTagIdentifierNamespace_0(NS);
                return __ret;
            }

            public static void add(clang.Decl.Kind k)
            {
                var arg0 = k;
                Internal.add_0(arg0);
            }

            public static void EnableStatistics()
            {
                Internal.EnableStatistics_0();
            }

            public static void PrintStats()
            {
                Internal.PrintStats_0();
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.Decl _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.Decl castFromDeclContext(clang.DeclContext _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public static void printGroup(clang.Decl Begin, uint NumDecls, llvm.raw_ostream Out, clang.PrintingPolicy Policy, uint Indentation)
            {
                var arg0 = ReferenceEquals(Begin, null) ? global::System.IntPtr.Zero : Begin.__Instance;
                var arg2 = ReferenceEquals(Out, null) ? global::System.IntPtr.Zero : Out.__Instance;
                var arg3 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.printGroup_0(arg0, NumDecls, arg2, arg3, Indentation);
            }

            protected uint Access
            {
                get
                {
                    return ((Internal*) __Instance)->Access;
                }

                set
                {
                    ((Internal*) __Instance)->Access = value;
                }
            }

            protected uint FromASTFile
            {
                get
                {
                    return ((Internal*) __Instance)->FromASTFile;
                }

                set
                {
                    ((Internal*) __Instance)->FromASTFile = value;
                }
            }

            protected uint Hidden
            {
                get
                {
                    return ((Internal*) __Instance)->Hidden;
                }

                set
                {
                    ((Internal*) __Instance)->Hidden = value;
                }
            }

            protected uint IdentifierNamespace
            {
                get
                {
                    return ((Internal*) __Instance)->IdentifierNamespace;
                }

                set
                {
                    ((Internal*) __Instance)->IdentifierNamespace = value;
                }
            }

            protected uint CacheValidAndLinkage
            {
                get
                {
                    return ((Internal*) __Instance)->CacheValidAndLinkage;
                }

                set
                {
                    ((Internal*) __Instance)->CacheValidAndLinkage = value;
                }
            }

            #region Virtual table interop

            // virtual ~Decl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (Decl) _References[instance].Target;
                var __ret = target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                    *(void**)(vfptr0 + 24) = _Thunks[5];
                    *(void**)(vfptr0 + 28) = _Thunks[6];
                    *(void**)(vfptr0 + 32) = _Thunks[7];
                    *(void**)(vfptr0 + 36) = _Thunks[8];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>PrettyStackTraceDecl - If a crash occurs, indicate that it
        /// happened when doing something to a specific decl.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// PrettyStackTraceDecl - If a crash occurs, indicate that it
        /// happened when</para>
        /// <para>/// doing something to a specific decl.</para>
        /// </remarks>
        public unsafe partial class PrettyStackTraceDecl : llvm.PrettyStackTraceEntry, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(4)]
                public global::System.IntPtr NextEntry;

                [FieldOffset(8)]
                public global::System.IntPtr TheDecl;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(16)]
                public global::System.IntPtr SM;

                [FieldOffset(20)]
                public global::System.IntPtr Message;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PrettyStackTraceDeclC2EPKNS_4DeclENS_14SourceLocationERNS_13SourceManagerEPKc")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr theDecl, clang.SourceLocation.Internal L, global::System.IntPtr sm, global::System.IntPtr Msg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PrettyStackTraceDeclC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PrettyStackTraceDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20PrettyStackTraceDecl5printERN4llvm11raw_ostreamE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS);
            }

            private readonly bool __ownsNativeInstance;

            public static PrettyStackTraceDecl __CreateInstance(global::System.IntPtr native)
            {
                return new PrettyStackTraceDecl((PrettyStackTraceDecl.Internal*) native);
            }

            public static PrettyStackTraceDecl __CreateInstance(PrettyStackTraceDecl.Internal native)
            {
                return new PrettyStackTraceDecl(native);
            }

            private static PrettyStackTraceDecl.Internal* __CopyValue(PrettyStackTraceDecl.Internal native)
            {
                var ret = (PrettyStackTraceDecl.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private PrettyStackTraceDecl(PrettyStackTraceDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PrettyStackTraceDecl(PrettyStackTraceDecl.Internal* native, bool isInternalImpl = false)
                : base((llvm.PrettyStackTraceEntry.Internal*) native)
            {
            }

            public PrettyStackTraceDecl(clang.Decl theDecl, clang.SourceLocation L, clang.SourceManager sm, string Msg)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(theDecl, null) ? global::System.IntPtr.Zero : theDecl.__Instance;
                var arg1 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg2 = ReferenceEquals(sm, null) ? global::System.IntPtr.Zero : sm.__Instance;
                var arg3 = Marshal.StringToHGlobalAnsi(Msg);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
                Marshal.FreeHGlobal(arg3);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.PrettyStackTraceEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override void print(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.print_0(__Instance, arg0);
            }

            #region Virtual table interop

            // PrettyStackTraceDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (PrettyStackTraceDecl) _References[instance].Target;
                target.DestroyNativeInstance();
            }

            // void print(raw_ostream &OS) const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _print_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS);
            private static _print_0Delegate _print_0DelegateInstance;

            private static void _print_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var target = (PrettyStackTraceDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                target.print(__result0);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _print_0DelegateInstance += _print_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_print_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>The results of name lookup within a DeclContext. This is either a
        /// single result (with no stable storage) or a collection of results (with
        /// stable storage provided by the lookup table).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The results of name lookup within a DeclContext. This
        /// is either a</para>
        /// <para>/// single result (with no stable storage) or a collection of
        /// results (with</para>
        /// <para>/// stable storage provided by the lookup table).</para>
        /// </remarks>
        public unsafe partial class DeclContextLookupResult : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.ArrayRef.Internal Result;

                [FieldOffset(8)]
                public global::System.IntPtr Single;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DeclContextLookupResultC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DeclContextLookupResultC2EPNS_9NamedDeclE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr Single);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DeclContextLookupResultC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult5beginEv")]
                internal static extern clang.DeclContextLookupResult.iterator.Internal begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult3endEv")]
                internal static extern clang.DeclContextLookupResult.iterator.Internal end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult4dataEv")]
                internal static extern global::System.IntPtr data_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult5frontEv")]
                internal static extern global::System.IntPtr front_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult4backEv")]
                internal static extern global::System.IntPtr back_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResult5sliceEm")]
                internal static extern void slice_0(global::System.IntPtr @return, global::System.IntPtr instance, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DeclContextLookupResultixEm")]
                internal static extern global::System.IntPtr OperatorSubscript_0(global::System.IntPtr instance, uint N);
            }

            public unsafe partial class iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(4)]
                    public global::System.IntPtr SingleElement;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang23DeclContextLookupResult8iteratorC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang23DeclContextLookupResult8iteratorC2EPKPNS_9NamedDeclES3_")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Pos, global::System.IntPtr Single);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang23DeclContextLookupResult8iteratorC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator>();

                private readonly bool __ownsNativeInstance;

                public static iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new iterator((iterator.Internal*) native);
                }

                public static iterator __CreateInstance(iterator.Internal native)
                {
                    return new iterator(native);
                }

                private static iterator.Internal* __CopyValue(iterator.Internal native)
                {
                    var ret = (iterator.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private iterator(iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected iterator(iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public iterator()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public iterator(clang.NamedDecl Pos, clang.NamedDecl Single)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Pos, null) ? global::System.IntPtr.Zero : Pos.__Instance;
                    var arg1 = ReferenceEquals(Single, null) ? global::System.IntPtr.Zero : Single.__Instance;
                    Internal.ctor_1(__Instance, arg0, arg1);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclContextLookupResult.iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclContextLookupResult> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclContextLookupResult>();

            private readonly bool __ownsNativeInstance;

            public static DeclContextLookupResult __CreateInstance(global::System.IntPtr native)
            {
                return new DeclContextLookupResult((DeclContextLookupResult.Internal*) native);
            }

            public static DeclContextLookupResult __CreateInstance(DeclContextLookupResult.Internal native)
            {
                return new DeclContextLookupResult(native);
            }

            private static DeclContextLookupResult.Internal* __CopyValue(DeclContextLookupResult.Internal native)
            {
                var ret = (DeclContextLookupResult.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private DeclContextLookupResult(DeclContextLookupResult.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclContextLookupResult(DeclContextLookupResult.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DeclContextLookupResult()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public DeclContextLookupResult(clang.NamedDecl Single)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Single, null) ? global::System.IntPtr.Zero : Single.__Instance;
                Internal.ctor_2(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclContextLookupResult __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.DeclContextLookupResult.iterator begin()
            {
                var __ret = Internal.begin_0(__Instance);
                return clang.DeclContextLookupResult.iterator.__CreateInstance(__ret);
            }

            public clang.DeclContextLookupResult.iterator end()
            {
                var __ret = Internal.end_0(__Instance);
                return clang.DeclContextLookupResult.iterator.__CreateInstance(__ret);
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            public clang.NamedDecl data()
            {
                var __ret = Internal.data_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public clang.NamedDecl front()
            {
                var __ret = Internal.front_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NamedDecl back()
            {
                var __ret = Internal.back_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DeclContextLookupResult slice(uint N)
            {
                var arg0 = N;
                var __ret = new clang.DeclContextLookupResult.Internal();
                Internal.slice_0(new IntPtr(&__ret), __Instance, arg0);
                return clang.DeclContextLookupResult.__CreateInstance(__ret);
            }

            public clang.NamedDecl this[uint N]
            {
                get
                {
                    var arg0 = N;
                    var __ret = Internal.OperatorSubscript_0(__Instance, arg0);
                    clang.NamedDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                    else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>
        /// <para>DeclContext - This is used only as base class of specific decl
        /// types that can act as declaration contexts. These decls are (only the top
        /// classes that directly derive from DeclContext are mentioned, not their
        /// subclasses):</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclContext - This is used only as base class of specific
        /// decl types that</para>
        /// <para>/// can act as declaration contexts. These decls are (only the
        /// top classes</para>
        /// <para>/// that directly derive from DeclContext are mentioned, not
        /// their subclasses):</para>
        /// <para>///</para>
        /// <para>///   TranslationUnitDecl</para>
        /// <para>///   NamespaceDecl</para>
        /// <para>///   FunctionDecl</para>
        /// <para>///   TagDecl</para>
        /// <para>///   ObjCMethodDecl</para>
        /// <para>///   ObjCContainerDecl</para>
        /// <para>///   LinkageSpecDecl</para>
        /// <para>///   BlockDecl</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class DeclContext : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(4)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(8)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(12)]
                public global::System.IntPtr LastDecl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContextC2ENS_4Decl4KindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContextC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContextD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11getDeclKindEv")]
                internal static extern clang.Decl.Kind getDeclKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext15getDeclKindNameEv")]
                internal static extern global::System.IntPtr getDeclKindName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext9getParentEv")]
                internal static extern global::System.IntPtr getParent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext16getLexicalParentEv")]
                internal static extern global::System.IntPtr getLexicalParent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext15getLookupParentEv")]
                internal static extern global::System.IntPtr getLookupParent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext19getParentASTContextEv")]
                internal static extern global::System.IntPtr getParentASTContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext9isClosureEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isClosure_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext15isObjCContainerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCContainer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext18isFunctionOrMethodEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionOrMethod_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext13isFileContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFileContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext17isTranslationUnitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTranslationUnit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext8isRecordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRecord_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11isNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext14isStdNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStdNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext17isInlineNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInlineNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext18isDependentContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependentContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext20isTransparentContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTransparentContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext16isExternCContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExternCContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext18isExternCXXContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExternCXXContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext6EqualsEPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Equals_0(global::System.IntPtr instance, global::System.IntPtr DC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext8EnclosesEPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Encloses_0(global::System.IntPtr instance, global::System.IntPtr DC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext21getNonClosureAncestorEv")]
                internal static extern global::System.IntPtr getNonClosureAncestor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext17getPrimaryContextEv")]
                internal static extern global::System.IntPtr getPrimaryContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext16getRedeclContextEv")]
                internal static extern global::System.IntPtr getRedeclContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext28getEnclosingNamespaceContextEv")]
                internal static extern global::System.IntPtr getEnclosingNamespaceContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext28getOuterLexicalRecordContextEv")]
                internal static extern global::System.IntPtr getOuterLexicalRecordContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext25InEnclosingNamespaceSetOfEPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool InEnclosingNamespaceSetOf_0(global::System.IntPtr instance, global::System.IntPtr NS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11decls_beginEv")]
                internal static extern clang.DeclContext.decl_iterator.Internal decls_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext9decls_endEv")]
                internal static extern clang.DeclContext.decl_iterator.Internal decls_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11decls_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool decls_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext18noload_decls_beginEv")]
                internal static extern clang.DeclContext.decl_iterator.Internal noload_decls_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext16noload_decls_endEv")]
                internal static extern clang.DeclContext.decl_iterator.Internal noload_decls_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext7addDeclEPNS_4DeclE")]
                internal static extern void addDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext15addDeclInternalEPNS_4DeclE")]
                internal static extern void addDeclInternal_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext13addHiddenDeclEPNS_4DeclE")]
                internal static extern void addHiddenDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext10removeDeclEPNS_4DeclE")]
                internal static extern void removeDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext12containsDeclEPNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext6lookupENS_15DeclarationNameE")]
                internal static extern void lookup_0(global::System.IntPtr @return, global::System.IntPtr instance, clang.DeclarationName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext13noload_lookupENS_15DeclarationNameE")]
                internal static extern void noload_lookup_0(global::System.IntPtr @return, global::System.IntPtr instance, clang.DeclarationName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext24makeDeclVisibleInContextEPNS_9NamedDeclE")]
                internal static extern void makeDeclVisibleInContext_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext23setMustBuildLookupTableEv")]
                internal static extern void setMustBuildLookupTable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext25hasExternalLexicalStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExternalLexicalStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext28setHasExternalLexicalStorageEb")]
                internal static extern void setHasExternalLexicalStorage_0(global::System.IntPtr instance, bool ES);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext25hasExternalVisibleStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExternalVisibleStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext28setHasExternalVisibleStorageEb")]
                internal static extern void setHasExternalVisibleStorage_0(global::System.IntPtr instance, bool ES);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext24isDeclInLexicalTraversalEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDeclInLexicalTraversal_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclContext7classofEPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_1(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext15dumpDeclContextEv")]
                internal static extern void dumpDeclContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11dumpLookupsEv")]
                internal static extern void dumpLookups_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclContext11dumpLookupsERN4llvm11raw_ostreamEb")]
                internal static extern void dumpLookups_1(global::System.IntPtr instance, global::System.IntPtr OS, bool DumpDecls);
            }

            /// <summary>
            /// <para>specific_decl_iterator - Iterates over a subrange of declarations
            /// stored in a DeclContext, providing only those that are of type SpecificDecl
            /// (or a class derived from it). This iterator is used, for example, to
            /// provide iteration over just the fields within a RecordDecl (with
            /// SpecificDecl = FieldDecl).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// specific_decl_iterator - Iterates over a subrange of</para>
            /// <para>  /// declarations stored in a DeclContext, providing only those
            /// that</para>
            /// <para>  /// are of type SpecificDecl (or a class derived from it).
            /// This</para>
            /// <para>  /// iterator is used, for example, to provide iteration over
            /// just</para>
            /// <para>  /// the fields within a RecordDecl (with SpecificDecl =
            /// FieldDecl).</para>
            /// </remarks>
            public unsafe partial class specific_decl_iterator
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.DeclContext.decl_iterator.Internal Current;
                }
            }

            /// <summary>
            /// <para>decl_iterator - Iterates through the declarations stored within
            /// this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// decl_iterator - Iterates through the declarations
            /// stored</para>
            /// <para>  /// within this context.</para>
            /// </remarks>
            public unsafe partial class decl_iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Current;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13decl_iteratorC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13decl_iteratorC2EPNS_4DeclE")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr C);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13decl_iteratorC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13decl_iteratorppEv")]
                    internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clangeqENS_11DeclContext13decl_iteratorES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(clang.DeclContext.decl_iterator.Internal x, clang.DeclContext.decl_iterator.Internal y);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clangneENS_11DeclContext13decl_iteratorES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(clang.DeclContext.decl_iterator.Internal x, clang.DeclContext.decl_iterator.Internal y);
                }

                public class value_type { }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, decl_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, decl_iterator>();

                private readonly bool __ownsNativeInstance;

                public static decl_iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new decl_iterator((decl_iterator.Internal*) native);
                }

                public static decl_iterator __CreateInstance(decl_iterator.Internal native)
                {
                    return new decl_iterator(native);
                }

                private static decl_iterator.Internal* __CopyValue(decl_iterator.Internal native)
                {
                    var ret = (decl_iterator.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private decl_iterator(decl_iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected decl_iterator(decl_iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public decl_iterator()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public decl_iterator(clang.Decl C)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                    Internal.ctor_1(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclContext.decl_iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public static clang.DeclContext.decl_iterator operator ++(clang.DeclContext.decl_iterator __op)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var __ret = Internal.OperatorPlusPlus_0(arg0);
                    clang.DeclContext.decl_iterator __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.DeclContext.decl_iterator.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.DeclContext.decl_iterator) clang.DeclContext.decl_iterator.NativeToManagedMap[__ret];
                    else __result0 = clang.DeclContext.decl_iterator.__CreateInstance(__ret);
                    return __result0;
                }

                public static bool operator ==(clang.DeclContext.decl_iterator x, clang.DeclContext.decl_iterator y)
                {
                    bool xNull = ReferenceEquals(x, null);
                    bool yNull = ReferenceEquals(y, null);
                    if (xNull || yNull)
                        return xNull && yNull;
                    var arg0 = ReferenceEquals(x, null) ? new clang.DeclContext.decl_iterator.Internal() : *(clang.DeclContext.decl_iterator.Internal*) (x.__Instance);
                    var arg1 = ReferenceEquals(y, null) ? new clang.DeclContext.decl_iterator.Internal() : *(clang.DeclContext.decl_iterator.Internal*) (y.__Instance);
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as decl_iterator;
                }

                public static bool operator !=(clang.DeclContext.decl_iterator x, clang.DeclContext.decl_iterator y)
                {
                    var arg0 = ReferenceEquals(x, null) ? new clang.DeclContext.decl_iterator.Internal() : *(clang.DeclContext.decl_iterator.Internal*) (x.__Instance);
                    var arg1 = ReferenceEquals(y, null) ? new clang.DeclContext.decl_iterator.Internal() : *(clang.DeclContext.decl_iterator.Internal*) (y.__Instance);
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Iterates over a filtered subrange of declarations stored in a
            /// DeclContext.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterates over a filtered subrange of declarations
            /// stored</para>
            /// <para>  /// in a DeclContext.</para>
            /// <para>  ///</para>
            /// <para>  /// This iterator visits only those declarations that are of
            /// type</para>
            /// <para>  /// SpecificDecl (or a class derived from it) and that meet
            /// some</para>
            /// <para>  /// additional run-time criteria. This iterator is used,
            /// for</para>
            /// <para>  /// example, to provide access to the instance methods within
            /// an</para>
            /// <para>  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl
            /// and</para>
            /// <para>  /// Acceptable = ObjCMethodDecl::isInstanceMethod).</para>
            /// </remarks>
            public unsafe partial class filtered_decl_iterator
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.DeclContext.decl_iterator.Internal Current;
                }
            }

            public unsafe partial class udir_iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13udir_iteratorC2ENS_23DeclContextLookupResult8iteratorE")]
                    internal static extern void ctor_0(global::System.IntPtr instance, clang.DeclContextLookupResult.iterator.Internal I);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang11DeclContext13udir_iteratorC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, udir_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, udir_iterator>();

                private readonly bool __ownsNativeInstance;

                public static udir_iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new udir_iterator((udir_iterator.Internal*) native);
                }

                public static udir_iterator __CreateInstance(udir_iterator.Internal native)
                {
                    return new udir_iterator(native);
                }

                private static udir_iterator.Internal* __CopyValue(udir_iterator.Internal native)
                {
                    var ret = (udir_iterator.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private udir_iterator(udir_iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected udir_iterator(udir_iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public udir_iterator(clang.DeclContextLookupResult.iterator I)
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(I, null) ? new clang.DeclContextLookupResult.iterator.Internal() : *(clang.DeclContextLookupResult.iterator.Internal*) (I.__Instance);
                    Internal.ctor_0(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclContext.udir_iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclContext> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclContext>();

            private readonly bool __ownsNativeInstance;

            public static DeclContext __CreateInstance(global::System.IntPtr native)
            {
                return new DeclContext((DeclContext.Internal*) native);
            }

            public static DeclContext __CreateInstance(DeclContext.Internal native)
            {
                return new DeclContext(native);
            }

            private static DeclContext.Internal* __CopyValue(DeclContext.Internal native)
            {
                var ret = (DeclContext.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DeclContext(DeclContext.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclContext(DeclContext.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected DeclContext(clang.Decl.Kind K)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = K;
                Internal.ctor_0(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclContext __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Decl.Kind getDeclKind()
            {
                var __ret = Internal.getDeclKind_0(__Instance);
                return __ret;
            }

            public string getDeclKindName()
            {
                var __ret = Internal.getDeclKindName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getParent - Returns the containing DeclContext.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getParent - Returns the containing DeclContext.</para>
            /// </remarks>
            public clang.DeclContext getParent()
            {
                var __ret = Internal.getParent_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getLexicalParent - Returns the containing lexical DeclContext.
            /// May be different from getParent, e.g.:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getLexicalParent - Returns the containing lexical
            /// DeclContext. May be</para>
            /// <para>  /// different from getParent, e.g.:</para>
            /// <para>  ///</para>
            /// <para>  ///   namespace A {</para>
            /// <para>  ///      struct S;</para>
            /// <para>  ///   }</para>
            /// <para>  ///   struct A::S {}; // getParent() == namespace 'A'</para>
            /// <para>  ///                   // getLexicalParent() == translation
            /// unit</para>
            /// <para>  ///</para>
            /// </remarks>
            public clang.DeclContext getLexicalParent()
            {
                var __ret = Internal.getLexicalParent_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DeclContext getLookupParent()
            {
                var __ret = Internal.getLookupParent_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ASTContext getParentASTContext()
            {
                var __ret = Internal.getParentASTContext_0(__Instance);
                clang.ASTContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTContext) clang.ASTContext.NativeToManagedMap[__ret];
                else __result0 = clang.ASTContext.__CreateInstance(__ret);
                return __result0;
            }

            public bool isClosure()
            {
                var __ret = Internal.isClosure_0(__Instance);
                return __ret;
            }

            public bool isObjCContainer()
            {
                var __ret = Internal.isObjCContainer_0(__Instance);
                return __ret;
            }

            public bool isFunctionOrMethod()
            {
                var __ret = Internal.isFunctionOrMethod_0(__Instance);
                return __ret;
            }

            public bool isFileContext()
            {
                var __ret = Internal.isFileContext_0(__Instance);
                return __ret;
            }

            public bool isTranslationUnit()
            {
                var __ret = Internal.isTranslationUnit_0(__Instance);
                return __ret;
            }

            public bool isRecord()
            {
                var __ret = Internal.isRecord_0(__Instance);
                return __ret;
            }

            public bool isNamespace()
            {
                var __ret = Internal.isNamespace_0(__Instance);
                return __ret;
            }

            public bool isStdNamespace()
            {
                var __ret = Internal.isStdNamespace_0(__Instance);
                return __ret;
            }

            public bool isInlineNamespace()
            {
                var __ret = Internal.isInlineNamespace_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this context is dependent on a template
            /// parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this context is dependent on
            /// a</para>
            /// <para>  /// template parameter.</para>
            /// </remarks>
            public bool isDependentContext()
            {
                var __ret = Internal.isDependentContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isTransparentContext - Determines whether this context is a
            /// &quot;transparent&quot; context, meaning that the members declared in this
            /// context are semantically declared in the nearest enclosing non-transparent
            /// (opaque) context but are lexically declared in this context. For example,
            /// consider the enumerators of an enumeration type: Here, E is a transparent
            /// context, so its enumerator (Val1) will appear (semantically) that it is in
            /// the same context of E. Examples of transparent contexts include:
            /// enumerations (except for C++0x scoped enums), and C++ linkage
            /// specifications.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTransparentContext - Determines whether this context is
            /// a</para>
            /// <para>  /// &quot;transparent&quot; context, meaning that the members
            /// declared in this</para>
            /// <para>  /// context are semantically declared in the nearest
            /// enclosing</para>
            /// <para>  /// non-transparent (opaque) context but are lexically declared
            /// in</para>
            /// <para>  /// this context. For example, consider the enumerators of
            /// an</para>
            /// <para>  /// enumeration type:</para>
            /// <para>  /// @code</para>
            /// <para>  /// enum E {</para>
            /// <para>  ///   Val1</para>
            /// <para>  /// };</para>
            /// <para>  /// @endcode</para>
            /// <para>  /// Here, E is a transparent context, so its enumerator (Val1)
            /// will</para>
            /// <para>  /// appear (semantically) that it is in the same context of
            /// E.</para>
            /// <para>  /// Examples of transparent contexts include: enumerations
            /// (except for</para>
            /// <para>  /// C++0x scoped enums), and C++ linkage specifications.</para>
            /// </remarks>
            public bool isTransparentContext()
            {
                var __ret = Internal.isTransparentContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this context or some of its ancestors is a
            /// linkage specification context that specifies C linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this context or some of its
            /// ancestors is a</para>
            /// <para>  /// linkage specification context that specifies C
            /// linkage.</para>
            /// </remarks>
            public bool isExternCContext()
            {
                var __ret = Internal.isExternCContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this context or some of its ancestors is a
            /// linkage specification context that specifies C++ linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this context or some of its
            /// ancestors is a</para>
            /// <para>  /// linkage specification context that specifies C++
            /// linkage.</para>
            /// </remarks>
            public bool isExternCXXContext()
            {
                var __ret = Internal.isExternCXXContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this declaration context is equivalent to the
            /// declaration context DC.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration context is
            /// equivalent</para>
            /// <para>  /// to the declaration context DC.</para>
            /// </remarks>
            public bool Equals(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.Equals_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this declaration context encloses the
            /// declaration context DC.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration context encloses
            /// the</para>
            /// <para>  /// declaration context DC.</para>
            /// </remarks>
            public bool Encloses(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.Encloses_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Find the nearest non-closure ancestor of this context, i.e. the
            /// innermost semantic parent of this context which is not a closure. A context
            /// may be its own non-closure ancestor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Find the nearest non-closure ancestor of this
            /// context,</para>
            /// <para>  /// i.e. the innermost semantic parent of this context which is
            /// not</para>
            /// <para>  /// a closure.  A context may be its own non-closure
            /// ancestor.</para>
            /// </remarks>
            public clang.Decl getNonClosureAncestor()
            {
                var __ret = Internal.getNonClosureAncestor_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getPrimaryContext - There may be many different declarations of
            /// the same entity (including forward declarations of classes, multiple
            /// definitions of namespaces, etc.), each with a different set of
            /// declarations. This routine returns the &quot;primary&quot; DeclContext
            /// structure, which will contain the information needed to perform name lookup
            /// into this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getPrimaryContext - There may be many different</para>
            /// <para>  /// declarations of the same entity (including forward
            /// declarations</para>
            /// <para>  /// of classes, multiple definitions of namespaces, etc.), each
            /// with</para>
            /// <para>  /// a different set of declarations. This routine returns
            /// the</para>
            /// <para>  /// &quot;primary&quot; DeclContext structure, which will
            /// contain the</para>
            /// <para>  /// information needed to perform name lookup into this
            /// context.</para>
            /// </remarks>
            public clang.DeclContext getPrimaryContext()
            {
                var __ret = Internal.getPrimaryContext_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getRedeclContext - Retrieve the context in which an entity
            /// conflicts with other entities of the same name, or where it is a
            /// redeclaration if the two entities are compatible. This skips through
            /// transparent contexts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getRedeclContext - Retrieve the context in which an entity
            /// conflicts with</para>
            /// <para>  /// other entities of the same name, or where it is a
            /// redeclaration if the</para>
            /// <para>  /// two entities are compatible. This skips through transparent
            /// contexts.</para>
            /// </remarks>
            public clang.DeclContext getRedeclContext()
            {
                var __ret = Internal.getRedeclContext_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the nearest enclosing namespace context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nearest enclosing namespace
            /// context.</para>
            /// </remarks>
            public clang.DeclContext getEnclosingNamespaceContext()
            {
                var __ret = Internal.getEnclosingNamespaceContext_0(__Instance);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the outermost lexically enclosing record context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the outermost lexically enclosing record
            /// context.</para>
            /// </remarks>
            public clang.RecordDecl getOuterLexicalRecordContext()
            {
                var __ret = Internal.getOuterLexicalRecordContext_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Test if this context is part of the enclosing namespace set of
            /// the context NS, as defined in C++0x [namespace.def]p9. If either context
            /// isn't a namespace, this is equivalent to Equals().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Test if this context is part of the enclosing
            /// namespace set of</para>
            /// <para>  /// the context NS, as defined in C++0x [namespace.def]p9. If
            /// either context</para>
            /// <para>  /// isn't a namespace, this is equivalent to Equals().</para>
            /// <para>  ///</para>
            /// <para>  /// The enclosing namespace set of a namespace is the namespace
            /// and, if it is</para>
            /// <para>  /// inline, its enclosing namespace, recursively.</para>
            /// </remarks>
            public bool InEnclosingNamespaceSetOf(clang.DeclContext NS)
            {
                var arg0 = ReferenceEquals(NS, null) ? global::System.IntPtr.Zero : NS.__Instance;
                var __ret = Internal.InEnclosingNamespaceSetOf_0(__Instance, arg0);
                return __ret;
            }

            public clang.DeclContext.decl_iterator decls_begin()
            {
                var __ret = Internal.decls_begin_0(__Instance);
                return clang.DeclContext.decl_iterator.__CreateInstance(__ret);
            }

            public clang.DeclContext.decl_iterator decls_end()
            {
                var __ret = Internal.decls_end_0(__Instance);
                return clang.DeclContext.decl_iterator.__CreateInstance(__ret);
            }

            public bool decls_empty()
            {
                var __ret = Internal.decls_empty_0(__Instance);
                return __ret;
            }

            public clang.DeclContext.decl_iterator noload_decls_begin()
            {
                var __ret = Internal.noload_decls_begin_0(__Instance);
                return clang.DeclContext.decl_iterator.__CreateInstance(__ret);
            }

            public clang.DeclContext.decl_iterator noload_decls_end()
            {
                var __ret = Internal.noload_decls_end_0(__Instance);
                return clang.DeclContext.decl_iterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Add the declaration D into this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Add the declaration D into this context.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine should be invoked when the declaration D has
            /// first</para>
            /// <para>  /// been declared, to place D into the context where it
            /// was</para>
            /// <para>  /// (lexically) defined. Every declaration must be added to
            /// one</para>
            /// <para>  /// (and only one!) context, where it can be visited via</para>
            /// <para>  /// [decls_begin(), decls_end()). Once a declaration has been
            /// added</para>
            /// <para>  /// to its lexical context, the corresponding DeclContext owns
            /// the</para>
            /// <para>  /// declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// If D is also a NamedDecl, it will be made visible within
            /// its</para>
            /// <para>  /// semantic context via makeDeclVisibleInContext.</para>
            /// </remarks>
            public void addDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.addDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Add the declaration D into this context, but suppress searches
            /// for external declarations with the same name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Add the declaration D into this context, but
            /// suppress</para>
            /// <para>  /// searches for external declarations with the same
            /// name.</para>
            /// <para>  ///</para>
            /// <para>  /// Although analogous in function to addDecl, this removes
            /// an</para>
            /// <para>  /// important check.  This is only useful if the Decl is
            /// being</para>
            /// <para>  /// added in response to an external search; in all other
            /// cases,</para>
            /// <para>  /// addDecl() is the right function to use.</para>
            /// <para>  /// See the ASTImporter for use cases.</para>
            /// </remarks>
            public void addDeclInternal(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.addDeclInternal_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Add the declaration D to this context without modifying any
            /// lookup tables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Add the declaration D to this context without
            /// modifying</para>
            /// <para>  /// any lookup tables.</para>
            /// <para>  ///</para>
            /// <para>  /// This is useful for some operations in dependent contexts
            /// where</para>
            /// <para>  /// the semantic context might not be dependent;  this
            /// basically</para>
            /// <para>  /// only happens with friends.</para>
            /// </remarks>
            public void addHiddenDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.addHiddenDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Removes a declaration from this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Removes a declaration from this context.</para>
            /// </remarks>
            public void removeDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.removeDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Checks whether a declaration is in this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Checks whether a declaration is in this
            /// context.</para>
            /// </remarks>
            public bool containsDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.containsDecl_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>lookup - Find the declarations (if any) with the given Name in
            /// this context. Returns a range of iterators that contains all of the
            /// declarations with this name, with object, function, member, and enumerator
            /// names preceding any tag name. Note that this routine will not look into
            /// parent contexts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// lookup - Find the declarations (if any) with the given Name
            /// in</para>
            /// <para>  /// this context. Returns a range of iterators that contains
            /// all of</para>
            /// <para>  /// the declarations with this name, with object, function,
            /// member,</para>
            /// <para>  /// and enumerator names preceding any tag name. Note that
            /// this</para>
            /// <para>  /// routine will not look into parent contexts.</para>
            /// </remarks>
            public clang.DeclContextLookupResult lookup(clang.DeclarationName Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var __ret = new clang.DeclContextLookupResult.Internal();
                Internal.lookup_0(new IntPtr(&__ret), __Instance, arg0);
                return clang.DeclContextLookupResult.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Find the declarations with the given name that are visible within
            /// this context; don't attempt to retrieve anything from an external
            /// source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Find the declarations with the given name that are
            /// visible</para>
            /// <para>  /// within this context; don't attempt to retrieve anything
            /// from an</para>
            /// <para>  /// external source.</para>
            /// </remarks>
            public clang.DeclContextLookupResult noload_lookup(clang.DeclarationName Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var __ret = new clang.DeclContextLookupResult.Internal();
                Internal.noload_lookup_0(new IntPtr(&__ret), __Instance, arg0);
                return clang.DeclContextLookupResult.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Makes a declaration visible within this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Makes a declaration visible within this
            /// context.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine makes the declaration D visible to name
            /// lookup</para>
            /// <para>  /// within this context and, if this is a transparent
            /// context,</para>
            /// <para>  /// within its parent contexts up to the first enclosing</para>
            /// <para>  /// non-transparent context. Making a declaration visible
            /// within a</para>
            /// <para>  /// context does not transfer ownership of a declaration, and
            /// a</para>
            /// <para>  /// declaration can be visible in many contexts that aren't
            /// its</para>
            /// <para>  /// lexical context.</para>
            /// <para>  ///</para>
            /// <para>  /// If D is a redeclaration of an existing declaration that
            /// is</para>
            /// <para>  /// visible from this context, as determined by</para>
            /// <para>  /// NamedDecl::declarationReplaces, the previous declaration
            /// will be</para>
            /// <para>  /// replaced with D.</para>
            /// </remarks>
            public void makeDeclVisibleInContext(clang.NamedDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.makeDeclVisibleInContext_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Mark the lookup table as needing to be built. This should be used
            /// only if setHasExternalLexicalStorage() has been called on any decl context
            /// for which this is the primary context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Mark the lookup table as needing to be built.  This
            /// should be</para>
            /// <para>  /// used only if setHasExternalLexicalStorage() has been called
            /// on any</para>
            /// <para>  /// decl context for which this is the primary context.</para>
            /// </remarks>
            public void setMustBuildLookupTable()
            {
                Internal.setMustBuildLookupTable_0(__Instance);
            }

            /// <summary>
            /// <para>Whether this DeclContext has external storage containing
            /// additional declarations that are lexically in this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this DeclContext has external storage
            /// containing</para>
            /// <para>  /// additional declarations that are lexically in this
            /// context.</para>
            /// </remarks>
            public bool hasExternalLexicalStorage()
            {
                var __ret = Internal.hasExternalLexicalStorage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>State whether this DeclContext has external storage for
            /// declarations lexically in this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief State whether this DeclContext has external storage
            /// for</para>
            /// <para>  /// declarations lexically in this context.</para>
            /// </remarks>
            public void setHasExternalLexicalStorage(bool ES)
            {
                Internal.setHasExternalLexicalStorage_0(__Instance, ES);
            }

            /// <summary>
            /// <para>Whether this DeclContext has external storage containing
            /// additional declarations that are visible in this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this DeclContext has external storage
            /// containing</para>
            /// <para>  /// additional declarations that are visible in this
            /// context.</para>
            /// </remarks>
            public bool hasExternalVisibleStorage()
            {
                var __ret = Internal.hasExternalVisibleStorage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>State whether this DeclContext has external storage for
            /// declarations visible in this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief State whether this DeclContext has external storage
            /// for</para>
            /// <para>  /// declarations visible in this context.</para>
            /// </remarks>
            public void setHasExternalVisibleStorage(bool ES)
            {
                Internal.setHasExternalVisibleStorage_0(__Instance, ES);
            }

            /// <summary>
            /// <para>Determine whether the given declaration is stored in the list of
            /// declarations lexically within this context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the given declaration is stored in
            /// the list of</para>
            /// <para>  /// declarations lexically within this context.</para>
            /// </remarks>
            public bool isDeclInLexicalTraversal(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.isDeclInLexicalTraversal_0(__Instance, arg0);
                return __ret;
            }

            public void dumpDeclContext()
            {
                Internal.dumpDeclContext_0(__Instance);
            }

            public void dumpLookups()
            {
                Internal.dumpLookups_0(__Instance);
            }

            public void dumpLookups(llvm.raw_ostream OS, bool DumpDecls)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.dumpLookups_1(__Instance, arg0, DumpDecls);
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classof(clang.DeclContext D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_1(arg0);
                return __ret;
            }

            protected clang.Decl FirstDecl
            {
                get
                {
                    clang.Decl __result0;
                    if (((Internal*) __Instance)->FirstDecl == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->FirstDecl))
                        __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[((Internal*) __Instance)->FirstDecl];
                    else clang.Decl.NativeToManagedMap[((Internal*) __Instance)->FirstDecl] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(((Internal*) __Instance)->FirstDecl);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->FirstDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            protected clang.Decl LastDecl
            {
                get
                {
                    clang.Decl __result0;
                    if (((Internal*) __Instance)->LastDecl == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->LastDecl))
                        __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[((Internal*) __Instance)->LastDecl];
                    else clang.Decl.NativeToManagedMap[((Internal*) __Instance)->LastDecl] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(((Internal*) __Instance)->LastDecl);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->LastDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class DeclBase
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18declaresSameEntityEPKNS_4DeclES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool declaresSameEntity_0(global::System.IntPtr D1, global::System.IntPtr D2);
            }

            /// <summary>
            /// <para>Determine whether two declarations declare the same
            /// entity.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether two declarations declare the same
            /// entity.</para>
            /// </remarks>
            public static bool declaresSameEntity(clang.Decl D1, clang.Decl D2)
            {
                var arg0 = ReferenceEquals(D1, null) ? global::System.IntPtr.Zero : D1.__Instance;
                var arg1 = ReferenceEquals(D2, null) ? global::System.IntPtr.Zero : D2.__Instance;
                var __ret = Internal.declaresSameEntity_0(arg0, arg1);
                return __ret;
            }
        }
    }

    namespace llvm
    {
    }
}
